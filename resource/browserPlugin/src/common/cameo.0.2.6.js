'use strict';
angular.element(window)
.on('cmBrowser:toApp', function(event){
    console.log('plugin called app')
    console.log(event.detail)
    console.log('#####')
})

window.addEventListener('load',function() {
    var event = new CustomEvent('cmBrowser:toPlugin',{'detail':{token:'xyz'}});
    window.dispatchEvent(event);
})

angular.module('cameoClient', [
    'ngRoute',
    'ngTouch',
    'angular-loading-bar',
    // cameo dependencies
    'cmConfig',
    'cmRoutes',
    'cmWidgets',
    'cmCore',
    'cmPhonegap',
    'cmUi',
    'cmSetup',
    'cmUser',
    'cmAppUser',
    'cmAppConversations',
    'cmContacts',
    'cmConversations',
    'cmValidate',
    'cmTouchEvents'
])

// cameo configuration for our providers
.config([
    'cmLanguageProvider', 'cmLoggerProvider', 'cmApiProvider', 'cmCallbackQueueProvider',
    'cmConfigProvider', 'cmEnvProvider', 'cmWebworkerFactoryProvider', 'cmRoutesProvider',
    function (cmLanguageProvider, cmLoggerProvider, cmApiProvider, cmCallbackQueueProvider,
              cmConfigProvider, cmEnvProvider, cmWebworkerFactoryProvider, cmRoutesProvider){

        cmLoggerProvider
            .debugEnabled( cmEnvProvider.get('enableDebug') );

		cmWebworkerFactoryProvider
            .setGlobalDefaultLimit( cmConfigProvider.get('webworkerDefaultGlobalLimit') )
            .setMobileDefaultLimit( cmConfigProvider.get('WebworkerDefaultLimitMobile') )
            .setAppDefaultLimit( cmConfigProvider.get('WebworkerDefaultLimitApp') )
            .setDesktopDefaultLimit( cmConfigProvider.get('WebworkerDefaultLimitDesktop') );

        cmApiProvider
            .restApiUrl( cmConfigProvider.get('restApi') )
            .callStackPath( cmConfigProvider.get('callStackPath') )
            .useCallStack( cmConfigProvider.get('useCallStack') )
            .commitSize( cmConfigProvider.get('commitSize') )
            .commitInterval( cmConfigProvider.get('commitInterval') )
            .useEvents( cmConfigProvider.get('useEvents') )
            .eventsPath( cmConfigProvider.get('eventsPath') )
            .eventsInterval( cmConfigProvider.get('eventsInterval') );

        cmLanguageProvider
            .cacheLangFiles( cmConfigProvider.get('cacheLangFiles') )
            .supportedLanguages( cmConfigProvider.get('supportedLanguages') )
            .pathToLanguages( cmConfigProvider.get('pathToLanguages') )
            .preferredLanguage('en')
            .useLocalStorage();

        cmCallbackQueueProvider
            .setQueueTime(250);


        cmRoutesProvider.create();
    }
])
// app run handling
.run([
    'cmSslCertificateChecker', 'cmNetworkInformation', 'cmPushNotificationAdapter',
    'cmPhonegap', 'cmLauncher', 'cmSplashScreen', 'cmKeyboard',
    function(cmSslCertificateChecker, cmNetworkInformation, cmPushNotificationAdapter,
             cmPhonegap, cmLauncher, cmSplashScreen, cmKeyboard){

        cmPhonegap.isReady('app.js',function(){
            // check ssl certificate
            cmSslCertificateChecker.init();
            // check internet connection
            cmNetworkInformation.init();
            // register device for pushnotification
            cmPushNotificationAdapter.init();
        });
    }
])
.run(function(){
    // start entropy collection for random number generator
    sjcl.random.startCollectors();
})
.run(['cmError', 'cmHistory',function(cmError, cmHistory){
    // only an inject is nessarary
}])
.run(['cmUserModel', 'cmBrowserNotifications', '$rootScope', function(cmUserModel, cmBrowserNotifications, $rootScope){
    if(cmUserModel.isAuth()){
        cmBrowserNotifications.askPermission();
    }

    $rootScope.$on('login', function(){
        cmBrowserNotifications.askPermission();
    })
}])
// router passing wrong route calls
.run([
    '$rootScope', '$location', '$route',
    'cmUserModel',
    function($rootScope, $location, $route,
             cmUserModel){

        function checkAccess(){
            var route = $route.current.$$route,
                guestVisibility =
                    route
                    && 'guests' in route
                    ? route.guests
                    : false,
                path = $location.$$path;

            switch(true){
                // exists none token then otherwise to login
                case cmUserModel.isAuth() === false:
                    if (!guestVisibility){
                        $rootScope.goTo('/login',true);
                    }
                break;
                // when token exists
                case ((path == '/login' || path == '/registration') && cmUserModel.isGuest() !== true):
                    $rootScope.goTo('/talks',true);
                break;
                // logout route
                case (path == '/logout'):
                    cmUserModel.doLogout(true,'app.js logout-route');
                break;
            }
        }

        $rootScope.$on('$locationChangeSuccess', function(event){
            checkAccess();
        });
    }
])

.run([
    '$rootScope', '$location', '$window', '$document', '$route', '$timeout',
    'cmUserModel', 'cmConversationFactory', 'cmContactsModel', 'cmRootService',
    'cmSettings', 'cmLanguage', 'cmLogger', 'cfpLoadingBar', 'cmEnv', 'cmVersion',
    'cmApi', 'cmAuthenticationRequest', 'cmSystemCheck',
    function ($rootScope, $location, $window, $document, $route, $timeout,
              cmUserModel, cmConversationFactory, cmContactsModel, cmRootService,
              cmSettings, cmLanguage, cmLogger, cfpLoadingBar, cmEnv, cmVersion,
              cmApi, cmAuthenticationRequest, cmSystemCheck) {

        //prep $rootScope with useful tools
        $rootScope.console  =   window.console;
        $rootScope.alert    =   window.alert;

        //add Overlay handles:
        $rootScope.showOverlay = function(id){ $rootScope.$broadcast('cmOverlay:show', id) };
        $rootScope.hideOverlay = function(id){ $rootScope.$broadcast('cmOverlay:hide', id) };

        // Make it easy for e2e-tests to monitor route changes:
        window._route = {};

        $rootScope.$on('$routeChangeStart', function(){
            window._route.path   = $location.$$path;
            window._route.status = 'loading';
        });

        $rootScope.$on('$routeChangeSuccess', function(){
            window._route.status = 'success';
        });

        $rootScope.$on('$routeChangeError', function(){
            window._route.status = 'error';
        });

        // Set view width e.g. 32rem
        function initScreenWidth(rem){
            var html    = $document[0].querySelector('html'),
                app     = $document[0].querySelector('#cm-app');

            //prevent screen size to change when content overflows
            html.style.overflowY = 'scroll';

            var height          = window.innerHeight,
                width           = html.offsetWidth,
                landscape       = width > 720 || width > height,
                effective_width = landscape ? Math.min(height, 420) : width;

            html.style.fontSize  = (effective_width/rem) +'px';
            app.style.maxWidth   = rem+'rem';
            angular.element(app).toggleClass('landscape', landscape);
        }

        // Actually set view width to 32 rem
        initScreenWidth(32);

        $timeout(function(){
            initScreenWidth(32);
        },1000);

        // For dev purposes only:
//            window.onresize = function() {
//                initScreenWidth(32)
//            }

        /**
         * Loading Bar on RouteChange
         */
        $rootScope.$on('$routeChangeStart', function(){
            if(cmEnv.loadingBar !== false){
                cfpLoadingBar.start();
            }
        });

        $rootScope.$on('$routeChangeSuccess', function(){
            if(cmEnv.loadingBar !== false){
                cfpLoadingBar.complete();
            }
        });

        //check on resize if the screen is too small for header an footer ( i.e. onscreen keyboard is active)
        angular.element($window).bind('resize', function(){
            var cm_app = $document[0].querySelector('#cm-app')
            if(cm_app.offsetWidth > $window.innerHeight){
                angular.element(cm_app).addClass('reduced-screen')
            } else {
                angular.element(cm_app).removeClass('reduced-screen')
            }
        });

        // Todo: whats is todo??
        if(cmUserModel.getToken())
            cmApi.listenToEvents()

        // Systemcheck
        cmSystemCheck.run(true);
    }
]);
angular.module('cmConfig',[])
.provider('cmConfig', [
    function(){
        var self = {
            target: 'default',
            restApi: 'http://localhost:9000/a/',
            defaultApiVersion: 'v1',
            version: '0.2.6',

            commitSize: 50,
            commitInterval: 500,
            useCallStack: false,
            callStackPath: '/callStack',
            useEvents: true,
            eventsPath: '/eventSubscription',
            eventsInterval: '5000',

			webworkerDefaultGlobalLimit : 2,
    		WebworkerDefaultLimitMobile: 2,
    		WebworkerDefaultLimitApp: 2,
    		WebworkerDefaultLimitDesktop: 2,

            browserNotificationTimeout: 5000,
            
            token: null,
            supportedLanguages: ['de', 'en'],
            pathToLanguages: 'i18n',
            cacheLangFiles: false,
            errorOnTodoInI18n: ('false' == 'true'),

            routes: {
                'start': {
                    guests: false,
                    routes: ['/start'],
                    waitForUserModel: true
                },
                'start-download': {
                    guests: false,
                    routes: ['/start/download']
                },
                'start-welcome': {
                    guests: false,
                    routes: ['/start/welcome'],
                    waitForUserModel: true
                },
                'start-quickstart': {
                    hasCtrl: true,
                    guests: false,
                    routes: ['/start/quickstart']
                },
                'login': {
                    isDefault: true,
                    css: 'no-header no-footer',
                    guests: true,
                    waitForFirstBoot: true
                },
                'help': {
                    routes: ['/help'],
                    guests: false
                },
                'settings': {
                    routes: ['/settings'],
                    guests: false
                },
                'settings-account': {
                    routes: ['/settings/account'],
                    guests: false
                },
                'settings-about': {
                    routes: ['/settings/about'],
                    guests: false
                },
                'settings-app': {
                    routes: ['/settings/app'],
                    guests: false
                },
                'settings-notify': {
                    routes: ['/settings/notify'],
                    guests: false
                },
                'settings-identity-list': {
                    guests: false,
                    routes: ['/settings/identity/list']
                },
                'settings-identity-create': {
                    guests: false,
                    routes: ['/settings/identity/create']
                },
                'settings-identity-edit': {
                    guests: false,
                    routes: ['/settings/identity/edit']
                },
                'settings-identity-key-list': {
                    guests: false,
                    routes: ['/settings/identity/key/list']
                },
                'settings-identity-key-create': {
                    hasCtrl: true,
                    guests: false,
                    routes: ['/settings/identity/key/create']
                },
                'settings-identity-key-edit': {
                    guests: false,
                    routes: ['/settings/identity/key/edit/:keyId?']
                },
                'settings-identity-key-import': {
                    guests: false,
                    routes: ['/settings/identity/key/import']
                },
                'authentication' :{
                    hasCtrl: true,
                    routes: [
                        '/authentication/:keyId?',
                        '/authentication/identity/:identityId?'
                    ],
                    waitForUserModel: true,
                    guests: false
                },
                'talks': {
                    waitForUserModel: true,
                    waitForFirstBoot: true
                },
                'conversation': {
                    routes:[
                        '/conversation',
                        '/conversation/:conversationId?'
                    ],
                    hasCtrl: true,
                    waitForUserModel: true,
                    waitForFirstBoot: true
                },
                'conversation-security': {
                    routes:[
                        '/conversation/:conversationId/security'
                    ],
                    hasCtrl: true,
                    waitForUserModel: true
                },
                'conversation-recipients': {
                    routes:[
                        '/conversation/:conversationId/recipients'
                    ],
                    hasCtrl: true,
                    waitForUserModel: true
                },
                'purl': {
                    routes:[
                        '/purl/:purlId'
                    ],
                    hasCtrl: true,
                    guests: true,
                    waitForPurl: true
                },
                'purl-security': {
                    routes:[
                        '/purl/:purlId/security'
                    ],
                    hasCtrl: true,
                    guests: true,
                    waitForPurl: true
                },
                'purl-recipients': {
                    routes:[
                        '/purl/:purlId/recipients'
                    ],
                    hasCtrl: true,
                    guests: true,
                    waitForPurl: true
                },
                'password-lost': {
                    templateUrl: 'routes/password/lost/password-lost.html',
                    routes:[
                        '/password/lost',
                        '/password'
                    ],
                    guests: true
                },
                'password-code': {
                    templateUrl: 'routes/password/code/password-code.html',
                    routes:[
                        '/password/code'
                    ],
                    guests: true
                },
                'password-reset': {
                    templateUrl: 'routes/password/reset/password-reset.html',
                    routes:[
                        '/password/reset/:resetId',
                        '/passwordReset/:resetId'
                    ],
                    hasCtrl: true,
                    guests: true
                },
                'registration': {
                    guests: true
                },
                'systemcheck': {
                    guests: true
                },
                'profile': {

                },
                'filter': {
                    hasCtrl: true
                },
                'contact-list': {
                    routes:[
                        '/contact/list/:section?',
                        '/contact',
                        '/contacts'
                    ],
                    waitForUserModel: true
                },
                'contact-request-list': {
                    routes:[
                        '/contact/request/list',
                        '/contact/request'
                    ],
                    hasCtrl: true,
                    waitForUserModel: true,
                    waitForFirstBoot: true
                },
                'contact-create': {
                    routes:['/contact/create']
                },
                'contact-import': {
                    routes:['/contact/import']
                },
                'contact-edit': {
                    routes:['/contact/edit/:id?'],
                    hasCtrl: true
                },
                'verification': {
                    routes:['/verification/:secret'],
                    hasCtrl: true
                },
                'server_down' : {
                    templateUrl: 'routes/landingpages/server_down.html'
                },
                'terms': {
                    css: 'no-footer',
                    guests: true
                },
                'disclaimer': {
                    guests: true
                },
                '404': {
                    templateUrl: 'routes/404/404.html',
                    guests: true
                },
                'version': {
                    hasCtrl: true,
                    guests: true
                },
                'notifications': {
                    hasCtrl: true
                },
                'error':{
                    routes: ['/error'],
                    hasCtrl: true,
                    templateUrl: 'routes/error/error.html',
                    guests: true
                },
                'setup-account':{
                    hasCtrl: true,
                    routes: ['/setup/account'],
                    guests: false,
                    waitForUserModel: true
                },
                'setup-identity':{
                    hasCtrl: true,
                    routes: ['/setup/identity'],
                    guests: false,
                    waitForUserModel: true
                },
                'setup-keyinfo': {
                    hasCtrl: true,
                    routes: ['/setup/keyinfo'],
                    guests: false,
                    waitForUserModel: true
                },
                'test': {
                    hasCtrl: true,
                    guests: false,
                    routes: ['/test']
                }
            },

            static: JSON.parse('{"appProtocol":"cameonet","appLinks":{"android":{"href":"https://play.google.com/store/apps/details?id=de.cameonet","icon":"gfx/app_icons/300x98_android_store.png","direct":{"href":"/dist/dl/#apk","icon":"gfx/app_icons/300x98_android_apk_download.png"}},"ios":{"href":"https://itunes.apple.com/us/app/cameonet/id923287434","icon":"gfx/app_icons/300x98_apple_store.png","direct":{"href":"","icon":"gfx/app_icons/300x98_apple_ipa_download.png"}},"winphone":{"href":"","icon":"gfx/app_icons/300x98_windows_store.png","direct":{"href":"","icon":"gfx/app_icons/300x98_windows_xpa_download.png"}}},"appIcon":"gfx/icon_128x128.png","remSize":"32","minimumDesktopDimension":"1024x768","certificates":{"stage":{"server":"https://stage.cameo.io","fingerprint":"97 93 A7 DB BE 1E 34 F6 CB 0D CA 62 5E DF D8 92 87 95 5E AD"},"prod":{"server":"https://www.cameonet.de","fingerprint":"41 53 8F D8 23 98 5B 48 F7 0D C3 DD 89 DD CE 8C 00 9D 85 D5"}},"thirdPartyLibraries":{"date":"1420794299000","libraries":[{"name":"AngularJS","url":"angularjs.org"},{"name":"AngularJS translate","url":"https://github.com/angular-translate"},{"name":"AngularJS loading bar","url":"https://chieffancypants.github.io/angular-loading-bar"},{"name":"AngularJS emoji filter","url":"https://github.com/globaldev/angular-emoji-filter"},{"name":"captchagen","url":"https://github.com/wearefractal/captchagen"},{"name":"JSEncrypt","url":"https://github.com/travist/jsencrypt"},{"name":"Stanford Javascript Crypto Library (SJCL)","url":"https://crypto.stanford.edu/sjcl"},{"name":"CryptoJS","url":"https://www.code.google.com/p/crypto-js"},{"name":"FileSaver.js","url":"https://github.com/eligrey/FileSaver.js"},{"name":"Blob.js","url":"https://github.com/eligrey/Blob.js"},{"name":"passchk.js","url":"https://rumkin.com/tools/password/passchk.php"},{"name":"spin.js","url":"http://fgnass.github.io/spin.js"},{"name":"FontLoader","url":"https://github.com/smnh/FontLoader"}]}}'),

            autoLoginData: {
                'Dumpuser local': {
                    user: '2VqTftqh',
                    pass: 'password'
                },
                'SillySammet dev': {
                    user: 'silly_sammet',
                    pass: 'password'
                }
            },

            menu: {
                'conversation/new': {i18n:'MENU.NEW_TALK', icon:'cm-new-talk', rootScopeCallback:'createNewConversation', 'data-qa':'menu-btn-new-conversation'},
                'contact/create': {i18n:'MENU.NEW_CONTACT', icon:'cm-new-contact'},
                'settings/identity/key/list': {i18n:'MENU.OWN_KEYS', icon:'cm-key'},
                'contact/request/list': {'data-qa':'btn-menu-contact-requests', i18n:'MENU.REQUESTS', icon:'cm-new-contact-query', css:'cm-menu-notify qa-btn-request-notify', drtv:'cm-friend-request-counter'},
                'settings': {i18n:'MENU.SETTINGS', icon:'cm-settings'},
                'help': {i18n:'MENU.HELP', icon:'cm-info', 'data-qa':'btn-menu-help'}
			},

            footer: {
                'talks': {i18n:'DRTV.FOOTER.TALKS', icon:'cm-talk'},
                'contact/list': {i18n:'DRTV.FOOTER.CONTACTS', icon:'cm-person'}
            },

            routeSettings: {
                'account': {i18n:'SETTINGS.ACCOUNT', icon:'cm-person', 'data-qa':'btn-settingsAccount'},
                'identity/edit': {i18n:'SETTINGS.IDENTITY', icon:'cm-avatar'},
                'identity/key/list': {i18n:'MENU.OWN_KEYS', icon:'cm-key'},
                'notify': {i18n:'SETTINGS.NOTIFY', icon:'cm-bell'},
                'contacts': {i18n:'SETTINGS.CONTACTS', icon:'cm-address-book', disabled:true},
                'app': {i18n:'SETTINGS.APP', icon:'cm-fix'},
                'contracts': {i18n:'SETTINGS.CONTRACTS', icon:'cm-clipboard', disabled:true},
                'about': {i18n:'SETTINGS.PAGES.ABOUT_US.TITLE', icon:'cm-rhino-positive'}
            },

            routeHelp: {
                'start/quickstart': {i18n:'START.QUICKSTART.HEADLINE', icon:'cm-info', 'data-qa':'btn-help-quickstart'},
                'support': {i18n:'HELP.LABEL.SUPPORT',icon:'cm-rhino-bubble-glyph',externLink:'http://support.cameonet.de', 'data-qa':'btn-help-support'},
                'settings/about': {i18n:'SETTINGS.PAGES.ABOUT_US.TITLE', icon:'cm-rhino-positive'}
            }
        };
        // performance page
        if('true' == 'true') {
            self.menu['performance'] = {
                i18n: 'SETTINGS.PAGES.PERFORMANCE.TITLE',
                icon: 'cm-not-connected',
                link: 'performance.html'
            };
        }

        this.get = function(key){
            return self[key];
        };

        this.$get = function(){
            return self;
        }
    }
])

.provider('cmEnv', [
    function() {
        var self = {
            autoLogin: ('true' == 'true'),
            loadingBar: ('true' == 'true'),
            enableDebug: ('true' == 'true')
        };

        this.get = function(key){
            return self[key];
        };

        this.$get = function () {
            return self;
        };
    }
])

.constant('cmVersion',{
    version: '0.2.6',
    last_build: '-'
});

angular.module('comps/conversations/drtv-answer.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-answer.html',
'<div class="wrap" id="files-droparea"><div class="attachments" data-qa="attachments-btn" cm-reactive><i class="fa cm-attachment"></i><div cm-user-rights><cm-file-choose cm-droparea="files-droparea"></cm-file-choose><cm-files-preview></cm-files-preview><cm-choose-source cm-options="{tooltip:\'up\'}"></cm-choose-source></div><div data-qa="btn-fast-registration" class="webreader-uploading" cm-user-rights="showForGuest" ng-click="openFastRegister()"></div></div><div class="message" data-qa="answer-ctn"><textarea id="answer-textarea" data-qa="input-answer" name="input-answer" ng-model="newMessageText" cm-resize-textarea cm-send-on-return cm-max-rows="8" cm-last-focus ></textarea><div class="inputter"></div></div><div class="btns-right"><cm-emoji-handler></cm-emoji-handler><div class="post-wrap" data-qa="btn-send-answer" ng-click="send($event)" cm-reactive><i class="fa cm-post with-cursor {{conversation.lockStatus.class}}-wrap" ng-class="{ \'cm-post-idle\':isSending, \'cm-post-attention\':isSendingAbort }"></i></div></div></div><cm-emoji-list ng-model="newMessageText" cm-textarea="answer-textarea"></cm-emoji-list>');
}]);
angular.module('comps/conversations/drtv-messages-timeline.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-messages-timeline.html',
'<div ng-repeat="message in (filteredData = (conversation.messages | orderBy:\'created\':false))" cm-scroll-to="{anchor:\'#conversation-bottom\',force:\'bottom\'}" cm-last-message><cm-date-seperator cm-timestamp="message.created" cm-timestamp-prev="filteredData[$index - 1].created"></cm-date-seperator><cm-message cm-data="message" cm-data-conversation="conversation"></cm-message></div>');
}]);
angular.module('cmAppConversations', [
    'cmCore',
    'cmFiles',
    'cmSecurityAspects',
    'cmUser'
,'comps/conversations/drtv-answer.html','comps/conversations/drtv-messages-timeline.html'])
.directive('cmAnswer',[
    'cmDevice', 'cmKeyboard',
    '$rootScope',
    function (cmDevice, cmKeyboard,
              $rootScope){
        return {
            restrict: 'E',
            templateUrl: 'comps/conversations/drtv-answer.html',
            link: function (scope, element) {
                if(cmDevice.isDesktop('cmAnswer'))
                    element.find('textarea')[0].focus();

                var textarea = element[0].querySelector('#answer-textarea')

                function clickWatcher(){
                    cmKeyboard.one('visible', function(){
                        $rootScope.$emit('scroll:to');
                    });

                    cmKeyboard.one('hidden', function(){
                        $rootScope.$emit('scroll:to');
                    });
                }

                if(cmDevice.isApp()){
                    angular.element(textarea)
                        .on('click', clickWatcher);

                    scope.$on('$destroy', function () {
                        angular.element(textarea)
                            .off('click', clickWatcher);
                    });
                }
            }
        }
    }
])
.directive('cmMessagesTimeline',[
    function (){
        return {
            restrict: 'E',
            templateUrl: 'comps/conversations/drtv-messages-timeline.html'
        }
    }
])
angular.module('routes/404/404.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/404/404.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-logo cm-weight="4"></cm-logo></cm-header><h2 class="border-bottom">404</h2><!--<article class="content">--><!--<cm-info-bubble class="cm-alert">--><!--<pre>--><!--{{data_str|strnl2nl}}--><!--</pre>--><!--</cm-info-bubble>--><!--</article>--><cm-footer><button class="cm-btn-grey dib w50" ng-click="goto(\'/logout\')"> {{\'ERROR.LOGOUT\'|cmTranslate}}</button><button class="cm-btn-grey dib w50" ng-click="goto(\'/talks\')"> {{\'ERROR.BACK_TO_TALKS\'|cmTranslate}}</button></cm-footer></section>');
}]);
angular.module('routes/authentication/authentication.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/authentication/authentication.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-authentication key-id = "keyId" identity-id = "identityId"></cm-widget-authentication></section>');
}]);
angular.module('routes/confirm/confirm.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/confirm/confirm.html',
'<button cm-confirm="{{secret}}" ng-click="confirm()">confirm</button>');
}]);
angular.module('routes/contact/create/contact-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/contact/create/contact-create.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/contact/list"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-contact-create></cm-widget-contact-create></section>');
}]);
angular.module('routes/contact/edit/contact-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/contact/edit/contact-edit.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/contact/list"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-contact-edit cm-data="contact" ng-if="contact"></cm-widget-contact-edit></section>');
}]);
angular.module('routes/contact/import/contact-import.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/contact/import/contact-import.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/contact/list"></cm-back><cm-identity cm-weight="6" cm-reactive></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-contact-import></cm-widget-contact-import></section>');
}]);
angular.module('routes/contact/list/contact-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/contact/list/contact-list.html',
'<section class="theme-a fill-bg"><!-- header --><cm-header cm-rubber-space><cm-identity cm-weight="4"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" data-qa="new-conversation-btn" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-header-list-search cm-weight="1" ng-model="search"></cm-header-list-search><cm-menu cm-weight="1"></cm-menu></cm-header><cm-context-bar></cm-context-bar><cm-default-pages></cm-default-pages><cm-widget-contact-list></cm-widget-contact-list></section>');
}]);
angular.module('routes/contact/request/list/contact-request-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/contact/request/list/contact-request-list.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/contact/list"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-contact-request-list></cm-widget-contact-request-list></section>');
}]);
angular.module('routes/contact/search/contact-search.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/contact/search/contact-search.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/contact/list"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-contact-search></cm-widget-contact-search></section>');
}]);
angular.module('routes/conversation/conversation.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/conversation/conversation.html',
'<section class="theme-a"><cm-header cm-rubber-space><div cm-weight="1"><cm-back back-to="/talks" ng-if="conversationId == \'new\'"></cm-back><cm-back back-to="/talks" plain-back="true" ng-if="conversationId != \'new\'"></cm-back></div><cm-identity cm-weight="4"></cm-identity><cm-security-indicator cm-weight = "2" cm-data = "conversation" ng-click = "gotoConversation(conversation.id,\'security\')" cm-reactive ></cm-security-indicator><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-conversation cm-data="conversation"></cm-widget-conversation></section>');
}]);
angular.module('routes/conversation/recipients/conversation-recipients.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/conversation/recipients/conversation-recipients.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="conversation/{{conversation.id}}"></cm-back><cm-identity cm-weight="3"></cm-identity><cm-security-indicator cm-weight = "2" cm-data = "conversation" ng-click = "gotoConversation(conversation.id,\'security\')" cm-reactive ></cm-security-indicator><cm-header-list-search cm-weight="1" ng-model="search" cm-options="{scrollTo:true}"></cm-header-list-search><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-conversation-recipients cm-data="conversation" cm-search="search"></cm-widget-conversation-recipients></section>');
}]);
angular.module('routes/conversation/security/conversation-security.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/conversation/security/conversation-security.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="conversation/{{conversationId}}"></cm-back><cm-identity cm-weight="4"></cm-identity><cm-security-indicator cm-weight = "2" cm-data = "conversation" cm-reactive ></cm-security-indicator><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-conversation-security cm-data="conversation"></cm-widget-conversation-security></section>');
}]);
angular.module('routes/disclaimer/disclaimer.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/disclaimer/disclaimer.html',
'<div class="page-header"><h2>Disclaimer</h2></div><div class="well well-lg"><p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus.</p><p>Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero.</p><p>Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum.</p><p>Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit.</p><p>Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque.</p><p>Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna</p></div>');
}]);
angular.module('routes/error/error.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/error/error.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-logo cm-weight="1"></cm-logo></cm-header><h2 class="border-bottom">{{\'ERROR.HEADER\'|cmTranslate}}</h2><article class="content"><cm-info-bubble class="cm-alert"><pre> {{data_str|strnl2nl}}</pre></cm-info-bubble></article><cm-footer><button class="cm-btn-grey dib w50" ng-click="goto(\'/logout\')"> {{\'ERROR.LOGOUT\'|cmTranslate}}</button><button class="cm-btn-grey dib w50" ng-click="goto(\'/talks\')"> {{\'ERROR.BACK_TO_TALKS\'|cmTranslate}}</button></cm-footer></section>');
}]);
angular.module('routes/filter/filter.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/filter/filter.html',
'<div cm-notify></div><div class="page-header"><h2>filter</h2></div><form class="form-horizontal" role="form" ng-submit="getMessages()" autocomplete="off"><div class="form-group"><label for="filter" class="col-sm-1 control-label">Filter</label><div class="col-sm-5"><textarea class="form-control" id="filter" ng-model="filter"></textarea></div></div><div class="form-group "><div class="col-sm-5 col-sm-offset-1"><select class="form-control" ng-change="setFilter()" ng-options="filter.name for filter in filters" ng-model="filterSelect"></select></div></div><div class="form-group"><div class="col-sm-offset-1 col-sm-5"><button type="submit" class="btn btn-primary btn-sm">get Messages</button><button type="button" class="btn btn-default btn-sm" ng-click="getMessages()">next Messages</button><button type="button" class="btn btn-default btn-sm" ng-click="getMessageCount()">get Message Count</button></div></div><div> Time[ms]: {{totalTime}} <br> <br> Total number of Messages: {{messageCount}} <br> Offset: {{offset}} <br> Messages:<br> <br><ul><li class="message-list" ng-repeat="message in messages"> {{message.messageBody}}<br><b>{{message.created}}</b></li></ul></div></form>');
}]);
angular.module('routes/help/help.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/help/help.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/talks"></cm-back><cm-identity cm-weight="4"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-help-list></cm-widget-help-list></div>');
}]);
angular.module('routes/landingpages/server_down.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/landingpages/server_down.html',
'Der Sever ist down, alles ist doof.');
}]);
angular.module('routes/login/login.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/login/login.html',
'<section class="theme-b fill-bg"><cm-widget-login></cm-widget-login></section>');
}]);
angular.module('routes/mediawall/mediawall.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/mediawall/mediawall.html',
'<span class="label">Nums: {{ assets.length }} / {{numberOfAssets}}</span><ul><li ng-repeat="asset in assets"> {{ asset.uploaded }} {{ asset.assetId }} {{ asset.type }}</li></ul>');
}]);
angular.module('routes/notifications/notifications.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/notifications/notifications.html',
'<cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/talks"></cm-back><div cm-weight="6"></div><cm-menu cm-weight="1"></cm-menu></cm-header><section class="notification"><header class="inScreen"><i class="fa cm-fix"></i> {{\'NOTIFICATIONS.HEADER\' | cmTranslate}}<button ng-click="ring();">ring!</button><button ng-click="warn();">warn!</button><button ng-click="info();">info!</button><button ng-click="success();">success!</button><button ng-click="error();">error!</button></header><ul><li ng-repeat="notify in notifications"><span class="item clearfix"><span class="title"><span>{{notify.label | cmTranslate}}</span></span></span></li></ul></section>');
}]);
angular.module('routes/password/code/password-code.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/password/code/password-code.html',
'<section class="theme-b fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/password/lost"></cm-back><cm-logo cm-weight="6"></cm-logo><div cm-weight="1"></div></cm-header><cm-widget-password-code></cm-widget-password-code></section>');
}]);
angular.module('routes/password/lost/password-lost.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/password/lost/password-lost.html',
'<section class="theme-b fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/login"></cm-back><cm-logo cm-weight="6"></cm-logo><div cm-weight="1"></div></cm-header><cm-widget-password-lost></cm-widget-password-lost></section>');
}]);
angular.module('routes/password/reset/password-reset.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/password/reset/password-reset.html',
'<section class="theme-b fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/login"></cm-back><cm-logo cm-weight="6"></cm-logo><div cm-weight="1"></div></cm-header><cm-widget-password-reset cm-data="resetId"></cm-widget-password-reset></section>');
}]);
angular.module('routes/purl/purl.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/purl/purl.html',
'<section class="theme-a" ng-show="!showSignIn"><cm-header cm-rubber-space ng-if="!headerGuest"><cm-back cm-weight="1" back-to="/talks" plain-back="true"></cm-back><cm-identity cm-weight="4"></cm-identity><cm-security-indicator cm-weight="2" ng-if = "conversation" cm-data = "conversation" cm-leading-icon = "cm-lock" ng-click = "gotoPurl(purlId, \'security\')" cm-reactive ></cm-security-indicator><cm-menu cm-weight="1" cm-reactive></cm-menu></cm-header><cm-header ng-if="headerGuest" cm-rubber-space><div cm-weight="2"></div><cm-logo cm-weight="4"></cm-logo><cm-security-indicator cm-weight="2" ng-if = "conversation" cm-data = "conversation" cm-leading-icon = "cm-lock" ng-click = "gotoPurl(purlId, \'security\')" cm-reactive ></cm-security-indicator></cm-header><cm-second-header ng-if="headerGuest" cm-rubber-space><div cm-weight="1" cm-reactive ng-click="gotoRegistration()" data-qa="btn-fast-sign-in"><i class="fa cm-register"></i><span>{{\'PURL.SIGN_IN\'|cmTranslate}}</span></div><div cm-weight="1" cm-reactive ng-click="goToApp(appParams)" ng-show="isMobile"><i class="fa cm-rhino-bubble-glyph"></i><span>{{\'PURL.TO_APP\'|cmTranslate}}</span></div></cm-second-header><cm-widget-conversation cm-data="conversation"></cm-widget-conversation></section>');
}]);
angular.module('routes/purl/recipients/purl-recipients.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/purl/recipients/purl-recipients.html',
'<section class="theme-a fill-bg"><cm-header ng-if="conversation" cm-rubber-space><cm-back cm-weight="1" back-to="purl/{{purlId}}"></cm-back><div cm-weight="1"></div><cm-logo cm-weight="4"></cm-logo><cm-security-indicator cm-weight = "2" cm-data = "conversation" cm-leading-icon = "cm-lock" ng-click = "gotoPurl(purlId,\'security\')" cm-reactive ></cm-security-indicator></cm-header><cm-widget-conversation-recipients cm-data="conversation"></cm-widget-conversation-recipients></section>');
}]);
angular.module('routes/purl/security/purl-security.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/purl/security/purl-security.html',
'<section class="theme-a fill-bg"><cm-header ng-if="conversation" cm-rubber-space><cm-back cm-weight="1" back-to="purl/{{purlId}}"></cm-back><div cm-weight="1"></div><cm-logo cm-weight="4"></cm-logo><cm-security-indicator cm-weight = "2" cm-data = "conversation" cm-leading-icon = "cm-lock" cm-reactive ></cm-security-indicator></cm-header><cm-widget-conversation-security cm-data="conversation"></cm-widget-conversation-security></section>');
}]);
angular.module('routes/registration/registration.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/registration/registration.html',
'<section class="theme-b fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/login"></cm-back><cm-logo cm-weight="6"></cm-logo><div cm-weight="1"></div></cm-header><cm-widget-registration></cm-widget-registration></section>');
}]);
angular.module('routes/settings/about/settings-about.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/about/settings-about.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-settings-about-us></cm-widget-settings-about-us></div>');
}]);
angular.module('routes/settings/account/settings-account.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/account/settings-account.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-settings-account></cm-widget-settings-account></div>');
}]);
angular.module('routes/settings/app/settings-app.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/app/settings-app.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-settings-app></cm-widget-settings-app></div>');
}]);
angular.module('routes/settings/identity/create/settings-identity-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/create/settings-identity-create.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings/identity/key/list"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-identity-create></cm-widget-identity-create></section>');
}]);
angular.module('routes/settings/identity/edit/settings-identity-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/edit/settings-identity-edit.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-identity-edit></cm-widget-identity-edit></section>');
}]);
angular.module('routes/settings/identity/key/create/settings-identity-key-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/key/create/settings-identity-key-create.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space ng-if="backBtn"><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-header cm-rubber-space ng-if="!backBtn"><cm-logo cm-weight="6"></cm-logo></cm-header><cm-widget-identity-key-create></cm-widget-identity-key-create></section>');
}]);
angular.module('routes/settings/identity/key/edit/settings-identity-key-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/key/edit/settings-identity-key-edit.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-identity-key-edit></cm-widget-identity-key-edit></section>');
}]);
angular.module('routes/settings/identity/key/import/settings-identity-key-import.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/key/import/settings-identity-key-import.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-identity-key-import></cm-widget-identity-key-import></section>');
}]);
angular.module('routes/settings/identity/key/list/settings-identity-key-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/key/list/settings-identity-key-list.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-identity-key-list></cm-widget-identity-key-list></section>');
}]);
angular.module('routes/settings/identity/list/settings-identity-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/identity/list/settings-identity-list.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewIdentity()" data-qa="create-identity-btn" cm-icon="avatar-add" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-identity-list></cm-widget-identity-list></section>');
}]);
angular.module('routes/settings/notify/settings-notify.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/notify/settings-notify.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/settings"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-settings-notify></cm-widget-settings-notify></div>');
}]);
angular.module('routes/settings/settings.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/settings/settings.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/talks"></cm-back><cm-identity cm-weight="5"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-settings-list></cm-widget-settings-list></div>');
}]);
angular.module('routes/setup/account/setup-account.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/setup/account/setup-account.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-logo cm-weight="6"></cm-logo></cm-header><cm-widget-setup-account></cm-widget-setup-account></div>');
}]);
angular.module('routes/setup/identity/setup-identity.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/setup/identity/setup-identity.html',
'<div class="theme-a fill-bg"><cm-header cm-rubber-space><cm-logo cm-weight="6"></cm-logo></cm-header><cm-widget-setup-identity></cm-widget-setup-identity></div>');
}]);
angular.module('routes/setup/keyinfo/setup-keyinfo.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/setup/keyinfo/setup-keyinfo.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-logo cm-weight="6"></cm-logo></cm-header><cm-widget-setup-keyinfo></cm-widget-setup-keyinfo></section>');
}]);
angular.module('routes/start/download/start-download.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/start/download/start-download.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-identity cm-weight="7"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><div class="cm-header-block"></div><cm-widget-download></cm-widget-download></section>');
}]);
angular.module('routes/start/quickstart/start-quickstart.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/start/quickstart/start-quickstart.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space ng-if="startRoute"><cm-identity cm-weight="7"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><div class="cm-header-block" ng-if="startRoute"></div><cm-header cm-rubber-space ng-if="!startRoute"><cm-back cm-weight="1" back-to="/talks"></cm-back><cm-identity cm-weight="6"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><cm-widget-quickstart cm-start-route="startRoute"></cm-widget-quickstart></section>');
}]);
angular.module('routes/start/start.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/start/start.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-identity cm-weight="7"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><div class="cm-header-block"></div><cm-widget-welcome></cm-widget-welcome></section>');
}]);
angular.module('routes/start/welcome/start-welcome.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/start/welcome/start-welcome.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-identity cm-weight="7"></cm-identity><cm-menu cm-weight="1"></cm-menu></cm-header><div class="cm-header-block"></div><cm-widget-welcome></cm-widget-welcome></section>');
}]);
angular.module('routes/systemcheck/systemcheck.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/systemcheck/systemcheck.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/login"></cm-back><cm-logo cm-weight="6"></cm-logo><div cm-weight="1"></div></cm-header><cm-widget-systemcheck></cm-widget-systemcheck></section>');
}]);
angular.module('routes/talks/talks.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/talks/talks.html',
'<section class="theme-a fill-bg"><cm-header cm-rubber-space><cm-identity cm-weight="4"></cm-identity><cm-add-button cm-weight="1" ng-click="createNewConversation()" data-qa="new-conversation-btn" cm-icon="new-talk" cm-reactive></cm-add-button><cm-add-button cm-weight="1" ng-click="createNewContact()" data-qa="add-contact-btn" cm-icon="new-contact" cm-reactive></cm-add-button><cm-header-list-search cm-weight="1" ng-model="search"></cm-header-list-search><cm-menu cm-weight="1"></cm-menu></cm-header><cm-context-bar></cm-context-bar><cm-default-pages></cm-default-pages><cm-widget-talks></cm-widget-talks></section>');
}]);
angular.module('routes/terms/terms.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/terms/terms.html',
'<section class="theme-b fill-bg"><cm-header cm-rubber-space><cm-back cm-weight="1" back-to="/registration"></cm-back><cm-logo cm-weight="6"></cm-logo><div cm-weight="1"></div></cm-header><cm-widget-terms></cm-widget-terms></section>');
}]);
angular.module('routes/test/test.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/test/test.html',
'');
}]);
angular.module('routes/verification/verification.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/verification/verification.html',
'It worked, lading page; verification; <a href="#"> zurück </a>');
}]);
angular.module('routes/version/version.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('routes/version/version.html',
'<div class="well">Version: {{ cmVersion.version }}<br />Last Build: {{ cmVersion.last_build }}</div>');
}]);
angular.module('cmRoutes',['routes/404/404.html','routes/authentication/authentication.html','routes/confirm/confirm.html','routes/contact/create/contact-create.html','routes/contact/edit/contact-edit.html','routes/contact/import/contact-import.html','routes/contact/list/contact-list.html','routes/contact/request/list/contact-request-list.html','routes/contact/search/contact-search.html','routes/conversation/conversation.html','routes/conversation/recipients/conversation-recipients.html','routes/conversation/security/conversation-security.html','routes/disclaimer/disclaimer.html','routes/error/error.html','routes/filter/filter.html','routes/help/help.html','routes/landingpages/server_down.html','routes/login/login.html','routes/mediawall/mediawall.html','routes/notifications/notifications.html','routes/password/code/password-code.html','routes/password/lost/password-lost.html','routes/password/reset/password-reset.html','routes/purl/purl.html','routes/purl/recipients/purl-recipients.html','routes/purl/security/purl-security.html','routes/registration/registration.html','routes/settings/about/settings-about.html','routes/settings/account/settings-account.html','routes/settings/app/settings-app.html','routes/settings/identity/create/settings-identity-create.html','routes/settings/identity/edit/settings-identity-edit.html','routes/settings/identity/key/create/settings-identity-key-create.html','routes/settings/identity/key/edit/settings-identity-key-edit.html','routes/settings/identity/key/import/settings-identity-key-import.html','routes/settings/identity/key/list/settings-identity-key-list.html','routes/settings/identity/list/settings-identity-list.html','routes/settings/notify/settings-notify.html','routes/settings/settings.html','routes/setup/account/setup-account.html','routes/setup/identity/setup-identity.html','routes/setup/keyinfo/setup-keyinfo.html','routes/start/download/start-download.html','routes/start/quickstart/start-quickstart.html','routes/start/start.html','routes/start/welcome/start-welcome.html','routes/systemcheck/systemcheck.html','routes/talks/talks.html','routes/terms/terms.html','routes/test/test.html','routes/verification/verification.html','routes/version/version.html'])
.controller('AuthenticationCtrl', [
    '$scope',
    '$routeParams',

    function($scope, $routeParams) {
        $scope.keyId        = $routeParams.keyId
        $scope.identityId   = $routeParams.identityId
    }
])
.controller('ContactEditCtrl',[
    'cmContactsModel',
    '$routeParams', '$scope',
    function(cmContactsModel, $routeParams, $scope){
        $scope.contactId = $routeParams.id;

        $scope.contact = cmContactsModel.contacts.find($routeParams.id);

        cmContactsModel.contacts.on('register', function(event, contact){
            if(contact.id == $routeParams.id){
                $scope.contact = contact;
            }
        })
    }
])
.controller('ContactRequestListCtrl',[
    '$scope',
    '$routeParams',
    function($scope, $routeParams){
        $scope.route = $routeParams.section || '';
    }
])
.controller('ConversationCtrl', [
    '$rootScope',
    '$scope',
    '$routeParams',
    '$location',
    'cmConversationFactory',
    function($rootScope, $scope, $routeParams, $location, cmConversationFactory){

        var force_new       =   $routeParams.conversationId == 'new',
            conversation_id =   force_new ?  undefined : $routeParams.conversationId


        $scope.conversation =   conversation_id
                                ?   cmConversationFactory.create(conversation_id)
                                :   ($rootScope.pendingConversation || cmConversationFactory.new());


        if(!$scope.conversation.state.is('new') && force_new)
            $scope.conversation = cmConversationFactory.new();
    }
])
.controller('ConversationRecipientsCtrl', [
    '$rootScope',
    '$scope',
    '$routeParams',
    '$location',
    'cmConversationFactory',
    function($rootScope, $scope, $routeParams, $location, cmConversationFactory){

        var force_new       =   $routeParams.conversationId == 'new',
            conversation_id =   force_new ?  undefined : $routeParams.conversationId


        $scope.conversation =   conversation_id
                                ?   cmConversationFactory.create(conversation_id)
                                :   ($rootScope.pendingConversation || cmConversationFactory.new())


        if(!$scope.conversation.state.is('new') && force_new)
            $scope.conversation = cmConversationFactory.create()

    }
])
.controller('ConversationSecurityCtrl', [

    '$rootScope',
    '$scope',
    '$routeParams',
    '$location',
    'cmConversationFactory',

    function($rootScope, $scope, $routeParams, $location, cmConversationFactory){

        var force_new       =   $routeParams.conversationId == 'new',
            conversation_id =   force_new ?  undefined : $routeParams.conversationId


        $scope.conversation =   conversation_id
                                ?   cmConversationFactory.create(conversation_id)
                                :   ($rootScope.pendingConversation || cmConversationFactory.new())


        if(!$scope.conversation.state.is('new') && force_new)
            $scope.conversation = cmConversationFactory.create()

    }
])
.controller('ErrorCtrl', [
    '$scope',
    '$rootScope',
    '$document',
    function ($scope, $rootScope, $document) {
        // if no errorThrown return to talks
        if(!('errorThrown' in $rootScope))
            $rootScope.goto('/talks');

        // at pending error to scope
        $scope.data_str = JSON.stringify($rootScope.errorThrown, undefined, 2);

        // hide broken page
        var views = $document[0].querySelectorAll('[ng-view]');
        if(views.length > 1)
            angular.element(views[1]).addClass('ng-hide');
    }
])
.controller('FilterCtrl', [
    '$scope',
    '$http',
    '$cookieStore',
    'cmLogger',
    'cmCrypt',
    function ($scope, $http, $cookieStore, cmLogger, cmCrypt) {

        $scope.messages = [];
        $scope.messageCount = 0;
        $scope.filter = "{}";
        $scope.limit = 50;
        $scope.offset = 0;

        $scope.filters = [
            {name: "all", filter: "{}"},
            {name: "filter group (from)", filter: '{"fromGroups":["group1"]}'},
            {name: "filter group (to)", filter: '{"toGroups":["group1"]}'},
            {name: "filter date (start)", filter: '{"startDate":"1391784822"}'},
            {name: "filter date (end)", filter: '{"endDate":"1391784822"}'}
        ];

        $scope.setFilter = function () {
            $scope.filter = $scope.filterSelect.filter
        };

        $scope.getMessages = function () {

            if ($scope.messages.length > 0) {
                $scope.offset = $scope.offset + $scope.limit
            }

            var start = new Date();

            $http({
                    method: "POST",
                    url: app.cameo.restApi + "/message/filter?token=" + $cookieStore.get("token") + "&offset=" + $scope.offset + "&limit=" + $scope.limit,
                    data: $scope.filter
                }
            ).success(function (res) {
                $scope.messages = res.data;

                $scope.totalTime = ((new Date()).getMilliseconds() - start.getMilliseconds())
            }).error(function (res) {
                cmLogger.error("error", res)
            });
        };

        $scope.getMessageCount = function () {
            $http({
                method: "POST",
                url: app.cameo.restApi + "/message/filter/count?token=" + $cookieStore.get("token"),
                data: $scope.filter
            }).success(function (res) {
                $scope.messageCount = res.data;
            }).error(function (res) {
                cmLogger.errorData("error", res)
            });
        };

}])
.controller('NotificationsCtrl', [
    '$scope',
    'cmNotify',
    function($scope, cmNotify){
        $scope.notifications = cmNotify;

        $scope.ring = function(){
            cmNotify.create({
                label:'NOTIFICATIONS.TYPES.FRIEND_REQUEST',
                bell: true
            });
        }

        $scope.warn = function(){
            cmNotify.warn('DRTV.EXTERN_CONTACT.INFO.EMPTY.DISPLAYNAME',{ttl:2000});
        }

        $scope.info = function(){
            cmNotify.info('NOTIFICATIONS.TYPES.FRIEND_REQUEST',{ttl:0, displayType:'modal'});
        }

        $scope.success = function(){
            cmNotify.success('NOTIFICATIONS.TYPES.FRIEND_REQUEST',{ttl:0, displayType:'modal'});
        }

        $scope.error = function(){
            cmNotify.error('DRTV.EXTERN_CONTACT.INFO.SAVE_FAIL',{ttl:2000});
        }
    }
])

    .controller('PasswordResetCtrl',[
        '$scope', '$routeParams',
        function($scope, $routeParams){
            $scope.resetId = $routeParams.resetId || '';
        }
    ])

.controller('PurlCtrl',[
    'cmUserModel', 'cmModal', 'cmPurlModel', 'cmConversationFactory', 'cmDevice',
    '$scope', '$rootScope', '$routeParams', 'resolveData',
    function(cmUserModel, cmModal, cmPurlModel, cmConversationFactory, cmDevice,
             $scope, $rootScope, $routeParams, resolveData){

        $rootScope.pendingPurl      = null;
        $scope.showSignIn           = false;
        $scope.purlId               = $routeParams.purlId || '';
        $scope.headerGuest          = true;

        $scope.appParams = 'purlId=' + $routeParams.purlId;
        $scope.isMobile = cmDevice.isMobile() && !cmDevice.isApp();

        if(typeof resolveData == 'object'){
            if(typeof resolveData.identity == 'object' && typeof resolveData.conversation == 'object'){
                // identity check internal || external user
                cmPurlModel.handleIdentity(resolveData.identity);

                if(resolveData.identity.userType == 'external'){
                    $rootScope.pendingPurl = $routeParams.purlId;
                } else {
                    $scope.headerGuest = false;
                }

                if(typeof resolveData.token !== 'undefined'){
                    cmPurlModel.handleToken(resolveData.token)
                }

                var conversation_id = cmPurlModel.handleConversation(resolveData.conversation);

                $scope.conversation = cmConversationFactory.create(conversation_id);
            } else if(typeof resolveData.status == 'number' && resolveData.status == 401){
                $rootScope.$broadcast('logout', {goToLogin: false, where: 'purl-ctrl getPurl reject'})
                $rootScope.showLogin();
                $scope.showSignIn = true;
            } else {
                $rootScope.goTo('/404');
            }
        }
    }
])
.controller('PurlRecipientsCtrl',[

    '$scope',
    '$rootScope',
    '$routeParams',
    'cmModal',
    'cmPurlModel',
    'cmConversationFactory',

    function($scope, $rootScope, $routeParams, cmModal, cmPurlModel, cmConversationFactory){

        $rootScope.pendingPurl      = null;
        $scope.showSignIn           = false;
        $scope.purlId               = $routeParams.purlId || '';

        if($routeParams.purlId){
            cmPurlModel.getPurl($routeParams.purlId).then(
                function(data){
                    // identity check internal || external user
                    cmPurlModel.handleIdentity(data.identity);

                    if(data.identity.userType == 'external'){
                        $scope.showSignIn = true;
                        $rootScope.pendingPurl = $routeParams.purlId;
                    }

                    if(typeof data.token !== 'undefined'){
                        cmPurlModel.handleToken(data.token)
                    }

                    var conversation_id = cmPurlModel.handleConversation(data.conversation);

                    $scope.conversation = cmConversationFactory.create(conversation_id)
                },

                function(response){
                    if(typeof response !== 'undefined' && 'status' in response){
                        if(response.status == 401){
                            $rootScope.$broadcast('logout', {goToLogin: false, where: 'purl-ctrl getPurl reject'})
                            $scope.showLogin();
                        } else if(response.status == 404){
                            $scope.goto('/404');
                        }
                    } else {
                        $scope.goto('/404');
                    }
                }
            );
        }

        /**
         * modal for fast registration
         */
        $scope.openFastRegister = function(){
            cmModal.create({
                    id: 'fast-registration',
                    'class': 'webreader',
                    type: 'alert',
                    //nose: 'bottom-left',
                    'cm-close-btn': false,
                    'cm-footer-label': 'MODAL.WEBREADER.LATER',
                    'cm-footer-icon': 'cm-close'
                },'' +
                    '<div class="attention">' +
                    '<i class="fa cm-attention"></i> {{\'MODAL.WEBREADER.NOTICE\'|cmTranslate}}' +
                    '</div>'+
                    '<a href="#/registration" class="redirect" data-qa="btn-register-modal">' +
                    '<i class="fa cm-key"></i> {{\'MODAL.WEBREADER.REGISTRATION\'|cmTranslate}}' +
                    '</a>'
            );
            cmModal.open('fast-registration')
        };

        $scope.showLogin = function () {
            cmModal.create({
                id: 'login',
                'class': 'with-title no-padding',
                'cm-close-btn': false,
                'cm-close-on-backdrop': false
            },'<div cm-login></div>');
            cmModal.open('login');

            $rootScope.$on('cmLogin:success', function(){
                location.reload();
            });
        };
    }
])
.controller('PurlSecurityCtrl',[

    '$scope',
    '$rootScope',
    '$routeParams',
    'cmModal',
    'cmPurlModel',
    'cmConversationFactory',

    function($scope, $rootScope, $routeParams, cmModal, cmPurlModel, cmConversationFactory){

        $rootScope.pendingPurl      = null;

        $scope.showSignIn           = false;
        $scope.purlId               = $routeParams.purlId || '';

        if($routeParams.purlId){
            cmPurlModel.getPurl($routeParams.purlId).then(
                function(data){
                    // identity check internal || external user
                    cmPurlModel.handleIdentity(data.identity);

                    if(data.identity.userType == 'external'){
                        $scope.showSignIn = true;
                        $rootScope.pendingPurl = $routeParams.purlId;
                    }

                    if(typeof data.token !== 'undefined'){
                        cmPurlModel.handleToken(data.token)
                    }

                    var conversation_id = cmPurlModel.handleConversation(data.conversation);

                    $scope.conversation = cmConversationFactory.create(conversation_id)
                },

                function(response){
                    if(typeof response !== 'undefined' && 'status' in response){
                        if(response.status == 401){
                            $rootScope.$broadcast('logout', {goToLogin: false, where: 'purl-ctrl getPurl reject'})
                            $scope.showLogin();
                        } else if(response.status == 404){
                            $scope.goto('/404');
                        }
                    } else {
                        $scope.goto('/404');
                    }
                }
            );
        }

        /**
         * modal for fast registration
         */
        $scope.openFastRegister = function(){
            cmModal.create({
                    id: 'fast-registration',
                    'class': 'webreader',
                    type: 'alert',
                    //nose: 'bottom-left',
                    'cm-close-btn': false,
                    'cm-footer-label': 'MODAL.WEBREADER.LATER',
                    'cm-footer-icon': 'cm-close'
                },'' +
                    '<div class="attention">' +
                    '<i class="fa cm-attention"></i> {{\'MODAL.WEBREADER.NOTICE\'|cmTranslate}}' +
                    '</div>'+
                    '<a href="#/registration" class="redirect" data-qa="btn-register-modal">' +
                    '<i class="fa cm-key"></i> {{\'MODAL.WEBREADER.REGISTRATION\'|cmTranslate}}' +
                    '</a>'
            );
            cmModal.open('fast-registration')
        };

        $scope.showLogin = function () {
            cmModal.create({
                id: 'login',
                'class': 'with-title no-padding',
                'cm-close-btn': false,
                'cm-close-on-backdrop': false
            },'<div cm-login></div>');
            cmModal.open('login');

            $rootScope.$on('cmLogin:success', function(){
                location.reload();
            });
        };
    }
])
.controller('SettingsIdentityKeyCreateCtrl', [
    '$rootScope',
    '$scope',
    function($rootScope, $scope) {
        $scope.backBtn = true;
        if(typeof $rootScope.generateAutomatic != 'undefined'){
            $scope.backBtn = false;
        }
    }
])
.controller('SettingsNotifyCtrl', [
    // no dependencies
    function() {
        // nothing to do here
    }
])
.controller('SetupAccountCtrl', [
    'cmHistory', '$rootScope',
    function(cmHistory, $rootScope) {
        /**
         * @todo
         */
        if(cmHistory.getPrev() != '/registration' || cmHistory.getPrev() != '/setup/account'){
            //$rootScope.goTo('/settings/account', true);
        }
    }
])
.controller('SetupIdentityCtrl', [
    'cmHistory', '$rootScope',
    function(cmHistory, $rootScope) {
        /**
         * @todo
         */
        if(!cmHistory.comesFrom('/setup/account')){
            //$rootScope.goTo('/settings/identity/edit', true);
        }
    }
])
.controller('SetupKeyinfoCtrl', [
    'cmSettings',
    '$rootScope',
    function(cmSettings, $rootScope) {
        var skip = cmSettings.get('skipKeyInfo') || false;

        if(skip){
            $rootScope.goTo('/talks');
        }
    }
])

.controller('StartQuickstartCtrl', [
    'cmHistory',
    '$scope',
    function(cmHistory,
             $scope) {
        $scope.startRoute = false;

        if(cmHistory.comesFrom('/start')){
            $scope.startRoute = true;
        }
    }
])
.controller('TestCtrl',
    function ($scope, $rootScope, $q, $timeout, $interval, cmModal) {

        $rootScope.$broadcast('cmApi:sleep')

    }
)

.controller('PurlCtrl',[
    'cmUserModel', 'cmModal', 'cmPurlModel', 'cmConversationFactory', 'cmDevice',
    '$scope', '$rootScope', '$routeParams', 'resolveData',
    function(cmUserModel, cmModal, cmPurlModel, cmConversationFactory, cmDevice,
             $scope, $rootScope, $routeParams, resolveData){

        $rootScope.pendingPurl      = null;
        $scope.showSignIn           = false;
        $scope.purlId               = $routeParams.purlId || '';
        $scope.headerGuest          = true;

        $scope.appParams = 'purlId=' + $routeParams.purlId;
        $scope.isMobile = cmDevice.isMobile() && !cmDevice.isApp();

        if(typeof resolveData == 'object'){
            if(typeof resolveData.identity == 'object' && typeof resolveData.conversation == 'object'){
                // identity check internal || external user
                cmPurlModel.handleIdentity(resolveData.identity);

                if(resolveData.identity.userType == 'external'){
                    $rootScope.pendingPurl = $routeParams.purlId;
                } else {
                    $scope.headerGuest = false;
                }

                if(typeof resolveData.token !== 'undefined'){
                    cmPurlModel.handleToken(resolveData.token)
                }

                var conversation_id = cmPurlModel.handleConversation(resolveData.conversation);

                $scope.conversation = cmConversationFactory.create(conversation_id);
            } else if(typeof resolveData.status == 'number' && resolveData.status == 401){
                $rootScope.$broadcast('logout', {goToLogin: false, where: 'purl-ctrl getPurl reject'})
                $rootScope.showLogin();
                $scope.showSignIn = true;
            } else {
                $rootScope.goTo('/404');
            }
        }
    }
])
.controller('VersionCtrl',[
    '$scope','cmVersion',
    function($scope, cmVersion){
        $scope.cmVersion = cmVersion;
    }
])

angular.module('comps/user/drtv-identity-tag.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/drtv-identity-tag.html',
'<cm-avatar cm-data="identity"></cm-avatar><section class="identityName"><div class="displayName">{{identity.getDisplayName()}}</div><div class="cameoId">{{identity.cameoId}}</div></section><section class="icon-list" ng-class="{\'with-two-icons\':identity.isActive}"><i class="fa cm-write" ng-if="identity.isActive"></i><i class="fa" ng-class="{\'cm-radio-1\':identity.isActive,\'cm-radio-0\':!identity.isActive}"></i></section>');
}]);
angular.module('cmAppUser',[
    'cmCore',
    'cmFiles'
,'comps/user/drtv-identity-tag.html'])
.directive('cmIdentityTag', [
    // no dependencies
    function(){
        return {
            restrict: 'E',
            scope: {
                identity: "=cmData"
            },
            templateUrl: 'comps/user/drtv-identity-tag.html',
            controller: function ($scope) {

            }
        }
    }
])

angular.module('comps/contacts/drtv-contact-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-create.html',
'<cm-scrollable><article class="content edit-identity-head clearfix"><div class="cm-fl mr5"><cm-avatar cm-data="identity" cm-avatar-view="{{chooseAvatar?\'unknown\':\'\'}}" class="big"></cm-avatar></div><div class="cm-fl w72"><ul class="no-border"><li ng-click="goToSearch()" data-qa="btn-identity-search" cm-reactive><article class="item"><span class="clearfix"><i class="fa cm-search fa-2x"></i> {{\'CONTACTS.LABEL.SEARCH_IDENTITY\'|cmTranslate}}</span><section class="icon-list"><i class="fa cm-right position-exception"></i></section></article></li><li ng-click="goTo(\'/contact/import\')" data-qa="btn-local-import" cm-reactive ng-if="canReadLocalContacts()"><article class="item"><span class="clearfix"><i class="fa cm-mobile fa-2x"></i> {{\'CONTACTS.LABEL.IMPORT_LOCAL\'|cmTranslate}}</span><section class="icon-list"><i class="fa cm-right position-exception"></i></section></article></li></ul></div></article><hr class="margin-small" /><form name="cmForm" novalidate autocomplete="off"><article class="content"><label>{{\'CONTACT.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon" ng-class="{\'cm-input-disabled\':disabled}"><input tabindex="1" data-qa="input-displayname" type="text" name="displayName" ng-model="formData.displayName" ng-disabled="disabled" /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show="cmForm.displayName.$dirty && cmForm.displayName.$invalid"><div ng-show="cmForm.displayName.$error.required"><i class="fa cm-info"></i> {{\'CONTACT.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="2" cm-label="CONTACT.PLACEHOLDER.PHONENUMBER" cm-info="CONTACT.INFO.INVALID.PHONENUMBER" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="3" cm-label="CONTACT.PLACEHOLDER.EMAIL" cm-info="CONTACT.INFO.INVALID.EMAIL" ></cm-form-email></form></cm-scrollable><cm-footer ng-hide="disabled"><button data-qa="btn-create-contact" class="cm-btn-grey" id="registerUserButton" ng-click="saveUser()" cm-reactive><span ng-show="!showLoader"> {{\'CONTACT.FOOTER.SAVE\'|cmTranslate}} <i class="fa cm-checkbox-right"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/contacts/drtv-contact-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-edit.html',
'<cm-scrollable><article class="content edit-identity-head clearfix"><div class="cm-fl mr5"><cm-avatar cm-data="contact.identity" cm-avatar-view="{{chooseAvatar?\'unknown\':\'\'}}" ng-show="contact.identity" class="big"></cm-avatar></div><div class="cm-fl w72"><ul class="no-border"><li><article class="item"><span class="clearfix"><cm-contact-trust cm-data="contact" cm-with-text></cm-contact-trust></span><section class="icon-list"><i class="fa cm-info"></i></section></article></li><li class="no-border" data-qa="start-trust-handshake-btn" ng-click="goToAuthentication(contact.identity)" ng-if="!isTrusted && hasKeys && hasLocalKey"><article class="item"><span class="clearfix"><i class="fa cm-handshake"></i> {{\'CONTACT.TRUST.START\'|cmTranslate}}</span><section class="icon-list"><i class="fa cm-right"></i></section></article></li></ul></div></article><hr class="margin-small" /><!-- show all talks with this user --><!--<article class="item"><span class="body"><i class="fa cm-talk"></i> Alle Talks mit diesem Kontakt anzeigen</span><span class="icon-list"><i class="fa cm-right position-exception"></i></span></article><hr class="margin-small" /> --><form name="cmForm" novalidate autocomplete="off"><article class="content" ng-if="!showCameoId" data-qa="internal-user"><label>{{\'CONTACT.PLACEHOLDER.CAMEOID\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-left-icon" ng-class="{\'cm-input-disabled\':disabled}"><i class="fa cm-rhino-positive without-cursor"></i><input data-qa="input-cameoId" disabled type="text" name="cameoId" ng-model="contact.identity.cameoId" /></div></article><hr class="margin-small" ng-if="!showCameoId" /><article class="content"><label>{{\'CONTACT.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}</label><div class="cm-input-ctn" ng-class="{\'cm-input-disabled\':disabled,\'with-inside-icon\':!disabled}"><input tabindex="1" data-qa="input-displayname" type="text" name="displayName" ng-model="formData.displayName" ng-disabled="disabled" required /><i class="fa cm-write" ng-show="!disabled"></i></div><cm-info-bubble class="cm-alert" ng-show="cmForm.displayName.$dirty && cmForm.displayName.$invalid"><div ng-show="cmForm.displayName.$error.required"><i class="fa cm-info"></i> {{\'CONTACT.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="2" cm-label="CONTACT.PLACEHOLDER.PHONENUMBER" cm-info="CONTACT.INFO.INVALID.PHONENUMBER" cm-disable="disabled" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="3" cm-label="CONTACT.PLACEHOLDER.EMAIL" cm-info="CONTACT.INFO.INVALID.EMAIL" cm-disable="disabled" ></cm-form-email></form><hr class="margin-small above-button" /><article class="item" data-qa="btn-delete-contact" ng-click="contact.delete()" cm-reactive><span class="body"><i class="fa cm-trash"></i> {{::\'CONTACT.PLACEHOLDER.DELETE\'|cmTranslate}}</span><span class="icon-list"><i class="fa cm-right"></i></span></article><hr class="margin-small under-button" /></cm-scrollable><cm-footer><button data-qa="btn-create-contact" class="cm-btn-grey" id="registerUserButton" ng-click="saveUser()" data-qa="btn-footer" cm-reactive><span ng-show="!showLoader && !isPristine" data-qa="btn-saveUser"> {{\'CONTACT.FOOTER.SAVE\'|cmTranslate}}<i class="fa cm-checker"></i></span><span ng-show="isPristine" data-qa="btn-pristineBack"> {{\'CONTACT.FOOTER.BACK\'|cmTranslate}}<i class="fa cm-out"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/contacts/drtv-contact-import.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-import.html',
'<cm-scrollable><article class="content" ng-click="chooseContact()"><cm-info-bubble nose-x="55%"><span ng-bind-html="\'CONTACTS.INFO.IMPORT_RIGHTS\' | cmParse"></span></cm-info-bubble></article><hr class="margin-small" /><form name="cmForm" novalidate autocomplete="off"><article class="content"><label>{{\'CONTACT.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon cm-icon-grey"><input tabindex="1" data-qa="input-displayname" type="text" name="displayName" ng-model="formData.displayName" required /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show="error.displayName"><div ng-show="error.displayName"><i class="fa cm-info"></i> {{\'CONTACT.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><article class="content with-radiobutton" ng-repeat="item in formData.phoneNumbers"><label> {{\'CONTACT.PLACEHOLDER.PHONENUMBER\'|cmTranslate }}<span ng-if="item.type">&nbsp;{{item.type}}</span></label><div class="cm-input-ctn with-inside-icon cm-icon-grey"><input tabindex="2" data-qa="input-phonenumber" type="text" name="phoneNumber_{{$index}}" ng-model="item.value" cm-validate-phone /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show="cmForm.phoneNumber_{{$index}}.$dirty && cmForm.phoneNumber_{{$index}}.$invalid"><div ng-show="cmForm.phoneNumber_{{$index}}.$invalid"><i class="fa cm-info"></i> {{\'CONTACT.INFO.INVALID.PHONENUMBER\'|cmTranslate}}<span ng-if="item.type">&nbsp;{{item.type}}</span></div></cm-info-bubble><i class="fa cm-radio-0" ng-class="{\'cm-radio-1\':isSelected(item,\'phoneNumber\')}" ng-click="chooseItem(item,\'phone\')"></i></article><article class="content"><cm-info-bubble class="cm-alert" ng-show="error.selectPhoneNumber"><div ng-show="error.selectPhoneNumber"><i class="fa cm-info"></i> {{\'CONTACT.INFO.SELECT.PHONENUMBER\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><article class="content with-radiobutton" ng-repeat="item in formData.emails"><label> {{\'CONTACT.PLACEHOLDER.EMAIL\'|cmTranslate }}<span ng-if="item.type">&nbsp;{{item.type}}</span></label><div class="cm-input-ctn with-inside-icon cm-icon-grey"><input tabindex="3" data-qa="input-email" name="email_{{$index}}" ng-model="item.value" cm-validate-email /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show="cmForm.email_{{$index}}.$dirty && cmForm.email_{{$index}}.$invalid"><div ng-show="cmForm.email_{{$index}}.$invalid"><i class="fa cm-info"></i> {{\'CONTACT.INFO.INVALID.EMAIL\'|cmTranslate}}<span ng-if="item.type">>&nbsp;{{item.type}}</span></div></cm-info-bubble><i class="fa cm-radio-0" ng-class="{\'cm-radio-1\':isSelected(item,\'email\')}" ng-click="chooseItem(item,\'email\')"></i></article><article class="content"><cm-info-bubble class="cm-alert" ng-show="error.selectEmail"><div ng-show="error.selectEmail"><i class="fa cm-info"></i> {{\'CONTACT.INFO.SELECT.EMAIL\'|cmTranslate}}</div></cm-info-bubble></article></form></cm-scrollable><cm-footer><button data-qa="btn-create-contact" class="cm-btn-grey" id="registerUserButton" ng-click="importContact()" cm-reactive><span ng-show="!showLoader"> {{\'CONTACT.FOOTER.SAVE\'|cmTranslate}} <i class="fa cm-checkbox-right"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/contacts/drtv-contact-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-list.html',
'<cm-loader ng-show="isLoading" class="fullscreen"></cm-loader><ul><li ng-repeat="contact in contacts | cmSearch:\'contacts\':search | cmPendingFirst as localResults" class="tag-with-icon-list"><cm-contact-tag cm-contact="contact" ng-class="{\'cm-disabled\':contact.contactType == \'pending\'}" cm-reactive cm-context="{model:contact, type:\'contact\', tap:gotoContact(contact)"></cm-contact-tag><section class="icon-list"><i class="fa cm-new-talk" ng-click="startConversationWithContact($event,contact)" data-qa="start-new-conversation-btn" cm-reactive ng-hide="contact.contactType == \'pending\'"></i><i class="fa cm-trash" cm-reactive ng-show="contact.contactType == \'pending\'" data-qa="btn-delete-friendrequest" ng-click="deleteFriendRequest(contact)" cm-reactive></i></section></li><li class="with-inside-left-icon" ng-show="(localResults.length == 0)"><i class="fa cm-attention"></i><div class="item"> {{::\'CONTACTS.SEARCH.INFO_NOTHING_FOUND\'|cmTranslate}}</div></li><li class="with-inside-left-icon with-inside-icon" cm-show-on-filter="search" cm-show-on-min-length="3" ng-click="toogleSearch(search)" data-qa="btn-search" cm-reactive><i class="fa cm-group"></i><div class="item"><span ng-show="activateSearch">{{::\'CONTACTS.SEARCH.SERVER_SEARCH.BUTTON_ACTIVE\'|cmTranslate}}</span><span ng-show="!activateSearch">{{::\'CONTACTS.SEARCH.SERVER_SEARCH.BUTTON_INACTIVE\'|cmTranslate}}</span></div><i class="fa" ng-class="{\'cm-down\':!activateSearch,\'cm-up\':activateSearch}"></i></li><li ng-show="showLoader"><cm-loader cm-color="ci-color"></cm-loader></li><li class="with-inside-left-icon" ng-show="(activateSearch && !showLoader && results.length == 0)"><i class="fa cm-attention"></i><div class="item"> {{::\'CONTACTS.SEARCH.SERVER_SEARCH.INFO_NOTHING_FOUND\' | cmTranslate}}</div></li><li class="tag-with-icon-list" ng-repeat="item in results" ng-click="openModal(\'modalSendRequest\',item)" cm-reactive data-qa="contact-search-item"><cm-contact-search-tag cm-contact="item"></cm-contact-search-tag><section class="icon-list"><i class="fa cm-new-contact"></i></section></li></ul><cm-modal id="modalSendRequest" class="no-padding" cm-data-as="contact" cm-title="CONTACTS.HEADING.SEND_REQUEST"><div class="modal-row" cm-rubber-space><cm-avatar cm-data="contact"></cm-avatar><div class="cm-request-brief" cm-weight="1"><strong>{{contact.getDisplayName()}}</strong></div></div><div class="modal-row"><textarea placeholder="{{::\'CONTACTS.PLACEHOLDER.REQUEST_MESSAGE\'|cmTranslate}}" ng-model="contact.message" data-qa="input-friendrequestMessage"></textarea></div><button class="cm-btn-grey" ng-click="sendRequest(contact)" data-qa="btn-sendRequest" cm-reactive> {{::\'CONTACTS.LABEL.SEND_REQUEST\'|cmTranslate}}<i class="fa cm-send"></i></button></cm-modal>');
}]);
angular.module('comps/contacts/drtv-contact-quick.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-quick.html',
'<form ng-submit="save()" name="cmForm"><article class="content"><label>{{\'CONTACT.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}</label><div class="cm-input-ctn"><input tabindex = "2" data-qa = "input-on-the-fly-displayname" type = "text" name = "displayName" ng-model = "displayName" /></div><cm-info-bubble class="cm-alert" ng-show="cmForm.displayName.$dirty && cmForm.displayName.$invalid && cmForm.displayName.length > 0"><div ng-show="cmForm.displayName.$error.required"><i class="fa cm-info"></i> {{\'CONTACT.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><article class="content"><label> {{\'SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.PHONENUMBER\'|cmTranslate}} / {{\'SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.EMAIL\'|cmTranslate}}</label><div class="cm-input-ctn"><input tabindex = "2" data-qa = "input-on-the-fly-mixed" type = "text" name = "mixed" ng-model = "mixed" cm-adaptive-change="3000" cm-validate-mixed required /></div><cm-info-bubble class="cm-alert" ng-show="mixed && cmForm.mixed.$invalid"><i class="fa cm-new-contact"></i> {{\'CONTACT.INFO.INVALID.MIXED\'|cmTranslate}}</cm-info-bubble></article><button type="submit" data-qa="btn-submit-on-the-fly-contact"><i ng-show="!showLoader" class="fa cm-new-contact"></i><cm-loader ng-show="showLoader"></cm-loader></button></form>');
}]);
angular.module('comps/contacts/drtv-contact-search-tag.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-search-tag.html',
'<cm-avatar cm-data="contact"></cm-avatar><cm-contact-trust cm-data="contact"></cm-contact-trust><section class="displayName" data-qa="contact-display-name"> {{contact.getDisplayName()}}</section><cm-contact-type cm-data="contact" cm-force-icon="cm-rhino-positive"></cm-contact-type>');
}]);
angular.module('comps/contacts/drtv-contact-tag.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-tag.html',
'<cm-avatar cm-data="contact.identity"></cm-avatar><cm-contact-trust cm-data="contact"></cm-contact-trust><section class="displayName" data-qa="contact-display-name"> {{contact.identity.getDisplayName()}}</section><cm-contact-type cm-data="contact"></cm-contact-type>');
}]);
angular.module('comps/contacts/drtv-contact-trust.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contact-trust.html',
'<span ng-if="!noKey && !hasAuthenticatedKey && !hasKey"><span class="aspect-icons loading"><i class="fa cm-checkbox"></i><i class="fa cm-checkbox"></i></span></span><span ng-if="noKey" data-qa="no-key"><span class="aspect-icons negative"><i class="fa cm-checkbox"></i><i class="fa cm-checkbox with-exclamation-mark"></i><i class="exclamation-mark">!</i></span><span class="aspect-text" ng-if="withText">{{\'CONTACT.TRUST.NO_CAMEOKEYS\'|cmTranslate}}</span></span><span ng-if="hasKey && !hasAuthenticatedKey" data-qa="untrusted-key"><span class="aspect-icons positive"><i class="fa cm-checkbox-bg"></i><i class="fa cm-checkbox with-exclamation-mark"></i><i class="exclamation-mark">!</i></span><span class="aspect-text" ng-if="withText">{{\'CONTACT.TRUST.HAS_CAMEOKEYS\'|cmTranslate}}</span></span><span ng-if="hasAuthenticatedKey" data-qa="trusted-key" class="positive"><span class="aspect-icons positive"><i class="fa cm-checkbox-bg"></i><i class="fa cm-checkbox-bg"></i></span><span class="aspect-text" ng-if="withText">{{\'CONTACT.TRUST.OK\'|cmTranslate}}</span></span>');
}]);
angular.module('comps/contacts/drtv-contacts-filter-controls.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-contacts-filter-controls.html',
'<div class="sort"><button ng-click="show_sort_overlay = !show_sort_overlay" > {{"CONTACTS.LABEL.SORT"|cmTranslate}}<i class="fa cm-arrange"></i></button><ul class = "overlay" ng-show = "show_sort_overlay" ><li>item 1</li><li>item 2</li><li>item 3</li><li>item 4</li><li>item 5</li><li>item 6</li></ul></div><div class="filter"><button ng-click = "show_filter_overlay = !show_filter_overlay" > {{"CONTACTS.LABEL.FILTER"|cmTranslate}}<i class="fa cm-filter"></i></button><ul class = "overlay" ng-show = "show_filter_overlay" ><li>item 1</li><li>item 2</li><li>item 3</li><li>item 4</li><li>item 5</li><li>item 6</li></ul></div>');
}]);
angular.module('comps/contacts/drtv-request-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-request-list.html',
'<article class="content" ng-show="isLoading"><cm-loader></cm-loader></article><article class="content mb15"ng-show="!requests.length && !isLoading"><cm-info-bubble nose-x="45%" class="cm-alert"><i class="fa cm-info"></i> {{\'CONTACTS.INFO.NO_REQUESTS\'|cmTranslate}}</cm-info-bubble></article><section ng-if="(requests.length > 0)"><ul class="no-border-top"><li ng-repeat="request in requests" data-qa="contact-list-element"><div class="contact-request-item"><cm-avatar cm-data="request.identity"></cm-avatar><section class="requestIdentity w75"><div class="displayName" data-qa="contact-display-name">{{request.identity.getDisplayName()}}</div></section></div><article class="content mt15 mb15" ng-if="(request.message && request.message != \'\')"><cm-info-bubble nose-x="30%"> {{request.message}}</cm-info-bubble></article><div class="cm-request-bar"><button ng-click="acceptRequest(request)" data-qa="btn-acceptRequest" cm-reactive><i class="fa cm-checkbox-right"></i>{{\'CONTACTS.REQUESTS.ACCEPT\'|cmTranslate}}</button><button ng-click="rejectRequest(request)" data-qa="btn-rejectRequest" cm-reactive><i class="fa cm-reject"></i> {{\'CONTACTS.REQUESTS.REJECT\'|cmTranslate}}</button><!--<button ng-click="ignoreRequest(request)" ng-if="false" cm-reactive><i class="fa cm-ignore"></i> {{\'CONTACTS.REQUESTS.IGNORE\'|cmTranslate}}</button>--></div></li></ul></section>');
}]);
angular.module('comps/contacts/drtv-type-chooser.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/contacts/drtv-type-chooser.html',
'<div class="btn-group btn-group-justified"><div class="btn-group" ng-repeat="button in buttons"><button type="button" class="btn btn-default btn-xs" ng-class="{\'btn-primary\':(active == button.value)}" ng-click="setActive(button.value)"> {{button.i18n|cmTranslate}}</button></div></div>');
}]);
angular.module('cmContacts',[
    'cmConfig',
    'cmCore',
    'cmPhonegap',
    'cmValidate',
    'cmSecurityAspects'
,'comps/contacts/drtv-contact-create.html','comps/contacts/drtv-contact-edit.html','comps/contacts/drtv-contact-import.html','comps/contacts/drtv-contact-list.html','comps/contacts/drtv-contact-quick.html','comps/contacts/drtv-contact-search-tag.html','comps/contacts/drtv-contact-tag.html','comps/contacts/drtv-contact-trust.html','comps/contacts/drtv-contacts-filter-controls.html','comps/contacts/drtv-request-list.html','comps/contacts/drtv-type-chooser.html'])
/**
 * @deprecated
 */

.directive('cmContactBrief', [
    function(){
        return {
            restrict : 'AE',
            template: '<div class="name" data-qa="contact-display-name">' +
                        '{{contact.identity.getDisplayName()}}' +
                      '</div>'
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactList
 * @description
 * Lists contacts.
 *
 * @restrict AE
 */


.directive('cmContactCreate', [
    'cmLocalContacts', 'cmContactsModel', 'cmUtil', 'cmNotify', 'cmLoader', 'cmModalContactImport', 'cmFilter',
    '$rootScope','$q',
    function(cmLocalContacts, cmContactsModel, cmUtil, cmNotify, cmLoader, cmModalContactImport, cmFilter,
             $rootScope, $q){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'comps/contacts/drtv-contact-create.html',
            controller: function($scope, $element, $attrs){
                $scope.cmUtil = cmUtil;
                var loader = new cmLoader($scope);

                $scope.canReadLocalContacts = function(){
                    return cmLocalContacts.canRead();
                };

                $scope.goToSearch = function(){
                    if($scope.formData.displayName != ''){
                        cmFilter.set($scope.formData.displayName)
                    }

                    cmFilter.setSearchVisibility(true);

                    $rootScope.goTo('/contact/list');
                };

                $scope.disabled = false;
                $scope.chooseAvatar = true;
                $scope.showCameoId = true;

                function reset(){
                    $scope.formData = {
                        displayName: '',
                        phoneNumber: '',
                        mergedPhoneNumber: '',
                        email: ''
                    };
                }

                reset();

                $scope.validateForm = function(){
                    var deferred = $q.defer(),
                        objectChange = {};

                    function checkDisplayName() {
                        var value = $scope.formData.displayName;
                        if (value != undefined && value != '') {
                            objectChange.displayName = value;
                        }
                    }

                    function checkPhoneNumber() {
                        var value = $scope.formData.mergedPhoneNumber;
                        if (value != undefined && value != '') {
                            objectChange.phoneNumber = value;
                        }
                    }

                    function checkEmail() {
                        var value = $scope.formData.email;
                        if (value != undefined && value != '') {
                            objectChange.email = value;
                        }
                    }

                    checkDisplayName();
                    checkPhoneNumber();
                    checkEmail();

                    if($scope.cmForm.$valid !== false && Object.keys(objectChange).length > 0){
                        deferred.resolve(objectChange);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.saveUser = function(){
                    if(loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm().then(
                        function(objectChange) {
                            cmContactsModel
                                .addContact({
                                    identity: objectChange
                                })
                                .then(
                                    function (data) {
                                        loader.stop();
                                        return new cmModalContactImport(data);
                                    },
                                    function () {
                                        loader.stop();
                                        cmNotify.error('CONTACT.INFO.ERROR.SAVE', {ttl: 5000});
                                        return $q.reject();
                                    }
                                )
                                .finally(function(){
                                    loader.stop();
                                    $scope.gotoContactList();
                                });
                        },
                        function(){
                            loader.stop();
                        }
                    )
                };
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmContacts.directive:cmContactEdit
 * @description
 * contact form
 *
 * @restrict E
 */


.directive('cmContactEdit', [
    'cmIdentityFactory', 'cmUtil', 'cmNotify', 'cmUserModel',
    'cmContactsModel', 'cmLogger', 'cmLoader', 'cmPristine',
    '$rootScope', '$q',
    function(cmIdentityFactory, cmUtil, cmNotify, cmUserModel,
             cmContactsModel, cmLogger, cmLoader, cmPristine,
             $rootScope, $q){

        return {
            restrict: 'E',
            scope: {
                contact: '=cmData'
            },
            templateUrl: 'comps/contacts/drtv-contact-edit.html',
            controller: function ($scope, $element, $attrs) {
                var loader = new cmLoader($scope);

                $scope.hasLocalKey = !!cmUserModel.loadLocalKeys().length;

                $scope.chooseAvatar = false;

                $scope.isTrusted = undefined;
                $scope.hasKeys = undefined;

                function reset(){
                    $scope.formData = {
                        displayName: $scope.contact.identity.displayName,
                        phoneNumber: $scope.contact.identity.phoneNumber.value,
                        mergedPhoneNumber: '',
                        email: $scope.contact.identity.email.value
                    };

                    $scope.hasLocalKey = !!cmUserModel.loadLocalKeys().length;

                    $scope.chooseAvatar = false;

                    $scope.isTrusted = undefined;
                    $scope.hasKeys = undefined;

                    $scope.disabled = $scope.contact.contactType == 'internal' ? true : false;

                    if (!$scope.disabled) {
                        $scope.showCameoId = true;
                    } else {
                        $scope.showCameoId = false;
                    }

                    $scope.hasKeys = ($scope.contact.identity.keys.length > 0);

                    cmUserModel.verifyTrust($scope.contact.identity)
                        .then(function () {
                            $scope.isTrusted = true;
                        });
                }

                $scope.contact.identity.on('update:finished', reset);

                $scope.$on('$destroy', function () {
                    $scope.contact.identity.off('update:finished', reset);
                });

                reset();



                /**
                 * handle every single contact via model
                 */
                $scope.startConversation = function () {
                    if ($scope.contact.contactType != 'pending') {
                        delete $rootScope.pendingConversation;
                        if ($scope.identity) {
                            $rootScope.pendingRecipients = [$scope.identity]
                        } else {
                            cmLogger.error('Unable to find identity on contact. ' + $scope.contact)
                        }
                        $rootScope.goTo('/conversation/new');
                    }
                };

                $scope.goToAuthentication = function (identity) {
                    if (identity.userType != 'external' && identity.keys.length > 0) {
                        $rootScope.goTo('authentication/identity/' + identity.id);
                    }
                };

                $scope.validateForm = function () {
                    var deferred = $q.defer(),
                        objectChange = {};

                    function checkDisplayName() {
                        var value = $scope.formData.displayName;
                        if (value != $scope.contact.identity.displayName) {
                            objectChange.displayName = value;
                        }
                    }

                    function checkPhoneNumber() {
                        var defValue = $scope.contact.identity.phoneNumber,
                            value = $scope.formData.mergedPhoneNumber;
                        if (value != undefined
                            && defValue && value != defValue.value) {
                            objectChange.phoneNumber = value;
                        }
                    }

                    function checkEmail() {
                        var defValue = $scope.contact.identity.email,
                            value = $scope.formData.email;
                        if (value != undefined
                            && defValue && value != defValue.value) {
                            objectChange.email = value;
                        }
                    }

                    checkDisplayName();
                    checkPhoneNumber();
                    checkEmail();

                    if ($scope.cmForm.$valid !== false && Object.keys(objectChange).length > 0) {
                        deferred.resolve(objectChange);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.saveUser = function () {
                    if ($scope.isPristine) {
                        $rootScope.goBack();
                        return false;
                    }

                    if (loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm().then(
                        function (objectChange) {

                            $scope.contact.save(objectChange).then(
                                function () {
                                    cmPristine.resetView($scope);
                                    reset();
                                    loader.stop();
                                },
                                function () {
                                    cmNotify.error('CONTACT.INFO.ERROR.EDIT', {ttl: 5000});
                                    loader.stop();
                                }
                            );
                        },
                        function () {
                            loader.stop();
                            cmUtil.scrollToInputError()
                        }
                    )
                };

                /**
                 * Pristine Service Handling
                 */
                cmPristine.initView($scope);
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactList
 * @description
 * Lists contacts.
 *
 * @restrict AE
 */


.directive('cmContactImport', [
    'cmContactsModel', 'cmUtil', 'cmNotify', 'cmLocalContacts', 'cmLoader', 'cmModalContactImport',
    '$rootScope', '$q',
    function(cmContactsModel, cmUtil, cmNotify, cmLocalContacts, cmLoader, cmModalContactImport,
             $rootScope, $q){

        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'comps/contacts/drtv-contact-import.html',

            controller: function($scope, $element, $attrs){
                $scope.cmUtil = cmUtil;
                var loader = new cmLoader($scope);

                function resetErrors(){
                    $scope.error = {
                        displayName: false,
                        selectPhoneNumber: false,
                        selectEmail: false
                    };
                }

                function reset(){
                    resetErrors();

                    $scope.formData = {
                        displayName: '',
                        phoneNumbers: [{value:'',type:''}],
                        emails: [{value:'',type:''}],
                        selected: {
                            phoneNumber: '',
                            email: ''
                        }
                    };
                }

                reset();

                $scope.chooseContact = function(){
                    cmLocalContacts.selectOne().then(
                        function (contact) {
                            reset();

                            if(contact.displayName == '')
                                contact.displayName = undefined;

                            $scope.formData.displayName = contact.displayName || 'name' in contact ? contact.name.formatted : '';

                            if(contact.phoneNumbers != null && contact.phoneNumbers.length > 0) {
                                $scope.formData.phoneNumbers = contact.phoneNumbers;
                            }

                            if(contact.emails != null && contact.emails.length > 0) {
                                $scope.formData.emails = contact.emails;
                            }
                        }
                    )
                };

                $scope.chooseItem = function(item, type){
                    switch(type){
                        case 'phone':
                            if($scope.formData.phoneNumber != item.value)
                                $scope.formData.phoneNumber = item.value;
                            else
                                $scope.formData.phoneNumber = '';
                        break;
                        case 'email':
                            if($scope.formData.email != item.value)
                                $scope.formData.email = item.value;
                            else
                                $scope.formData.email = '';
                        break;
                    }
                };

                $scope.isSelected = function(item, type){
                    return item.value != '' && item.value == $scope.formData[type];
                };

                $scope.validateForm = function(){
                    resetErrors();

                    var deferred = $q.defer(),
                        objectChange = {},
                        isValid = true;

                    function checkDisplayName() {
                        var value = $scope.formData.displayName;
                        if (value == '') {
                            $scope.error.displayName = true;
                            isValid = false;
                        } else {
                            objectChange.displayName = value;
                        }
                    }

                    function checkSelection(){
                        var valuePhone = $scope.formData.phoneNumber,
                            valueEmail = $scope.formData.email;
                        // both is empty
                        if(valuePhone == '' && valueEmail == ''
                        || !valuePhone && !valueEmail){
                            $scope.error.selectPhoneNumber = true;
                            $scope.error.selectEmail = true;
                            isValid = false;
                        } else {
                            if(valuePhone && valuePhone != '')
                                objectChange.phoneNumber = valuePhone;
                            if(valueEmail && valueEmail != '')
                                objectChange.email = valueEmail;
                        }
                    }

                    checkDisplayName();
                    checkSelection();

                    if($scope.cmForm.$valid !== false && isValid !== false && Object.keys(objectChange).length > 0){
                        deferred.resolve(objectChange);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.importContact = function(){
                    if(loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm().then(
                        function(objectChange) {
                            cmContactsModel
                            .addContact({
                                identity: objectChange
                            })
                            .then(
                                function (data) {
                                    loader.stop();
                                    return new cmModalContactImport(data);
                                },
                                function () {
                                    loader.stop();
                                    cmNotify.error('CONTACT.INFO.ERROR.SAVE', {ttl: 5000});
                                    return $q.reject();
                                }
                            )
                            .finally(function(){
                                loader.stop();
                                $scope.gotoContactList();
                            })

                        },
                        function(){
                            loader.stop();
                        }
                    );
                };

                // init
                if(cmLocalContacts.canRead()) {
                    $scope.chooseContact();
                } else {
                    $rootScope.goBack();
                    return false;
                }
            }
        }
    }
])
.directive('cmContactList',[
    'cmContactsModel', 'cmIdentityFactory', 'cmFilter',
    'cmLoader', 'cmLogger', 'cmModal', 'cmNotify', 'cmContactsAdapter',
    '$rootScope', '$timeout',
    function (cmContactsModel, cmIdentityFactory, cmFilter,
              cmLoader, cmLogger, cmModal, cmNotify, cmContactsAdapter,
              $rootScope, $timeout) {
        return {
            restrict: 'AE',
            scope: true,
            templateUrl: 'comps/contacts/drtv-contact-list.html',

            controller: function ($scope, $element, $attrs) {
                $scope.isLoading    = false;

                $scope.contacts     = cmContactsModel.contacts;
                $scope.contactsQty  = cmContactsModel.contacts.length;

                cmContactsModel.on('start:load-contacts', function () {
                    $scope.isLoading = true;
                });

                cmContactsModel.on('finish:load-contacts', function () {
                    $scope.isLoading = false;
                });

                /**
                 * contact server search
                 */
                var loader = new cmLoader($scope);

                $scope.activateSearch = false;
                $scope.searchCameoId = {};
                $scope.results = [];

                $scope.timeout = null;

                $scope.toogleSearch = function(){
                    if($scope.activateSearch){
                        $scope.activateSearch = false;
                        $scope.results = [];
                    } else {
                        $scope.activateSearch = true;
                        $scope.sendSearch(cmFilter.get());
                    }
                };

                $scope.sendSearch = function(search){
                    if(typeof search != 'string' || search.length < 3){
                        return false;
                    }

                    loader.start();

                    if($scope.timeout != null) $timeout.cancel($scope.timeout);

                    $scope.timeout = $timeout(function(){
                        cmContactsModel.searchCameoIdentity(search).then(
                            function(data){
                                var tmp = [];
                                angular.forEach(data, function(value){
                                    tmp.push(cmIdentityFactory.create(value, true));
                                });
                                $scope.results = tmp;
                            }
                        ).finally(
                            function(){
                                loader.stop();
                            }
                        );
                    },500);

                    return true;
                };

                var filter = cmFilter.get();
                if(typeof filter == 'string' && filter != ''){
                    $scope.toogleSearch();
                } else if(cmFilter.getSearchVisibility()) {
                    $scope.toogleSearch();
                }

                function onClearFilter(){
                    $scope.activateSearch = false;
                    $scope.results = [];
                }

                cmFilter.onClear('contact-list',onClearFilter);

                var filterListener = $scope.$watch('search', function(newValue){
                    if($scope.activateSearch){
                        $scope.sendSearch(newValue);
                    }
                });

                $scope.$on('$destroy', function(){
                    filterListener();
                    onClearFilter();
                });

                /**
                 * Send friendship via model to api
                 * @param id
                 */
                $scope.sendRequest = function(contact){
                    if(angular.isDefined(contact.id)){
                        cmContactsModel
                            .sendFriendRequest(contact.id, contact.message)
                            .then(
                            function(){
                                // clear from list
                                var index = $scope.results.indexOf(contact);
                                $scope.results.splice(index,1);
                                // notify
//                                cmNotify.success('CONTACTS.INFO.REQUEST.SENDED', {displayType:'modal', ttl:3000});
                                cmContactsModel.trigger('friendRequest:sent');
                                cmModal.closeAll();
                            },
                            function(){
                                cmNotify.error('CONTACTS.INFO.REQUEST.FAILED', {displayType:'modal'});
                            }
                        )
                    }
                };

                $scope.deleteFriendRequest = function(contact, withoutModal){
                    return (function(){
                        return withoutModal
                        ? $q.when()
                        : cmModal.confirm({
                            title: 'CONTACT.MODAL.DELETE_FRIENDREQUEST.HEADER',
                            text: 'CONTACT.MODAL.DELETE_FRIENDREQUEST.TEXT'
                        })
                    }()).then(function(){
                        cmContactsModel
                            .deleteFriendRequest(contact)
                    });
                }
            }
        }
    }
])

.directive('cmContactQuick', [

    'cmContactsModel',
    'cmIdentityFactory',
    'cmTranslate',
    'cmLoader',
    '$q',

    function(cmContactsModel, cmIdentityFactory, cmTranslate, cmLoader,
             $q){

        return {
            restrict:       'E',
            scope:          {
                                select          : "=cmDataSelected",
                                conversation    : "=cmDataConversation"
                            },
            templateUrl:    'comps/contacts/drtv-contact-quick.html',

            controller: function($scope, $element, $attrs){
                var loader = new cmLoader($scope);

                $scope.displayName = '';

                $attrs.$observe("cmInput", function(value){
                    $scope.mixed = value;
                });

                $scope.validateForm = function(){
                    var deferred = $q.defer(),
                        data = {};

                    function checkDisplayName() {
                        if ($scope.displayName && $scope.displayName != '') {
                            data.displayName = $scope.displayName;
                        }
                    }

                    function checkMixed() {
                        if ($scope.mixed.length > 0
                            && $scope.mixed[0].value != undefined
                            && $scope.mixed[0].value != ''
                            ) {
                            data.mixed = $scope.mixed[0].value;
                        }
                    }

    
                    checkDisplayName();
                    checkMixed();

                    if($scope.cmForm.$valid != false){
                        deferred.resolve(data);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.save = function(){
                    if (loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm()
                    .then(
                        function(){
                            return cmContactsModel
                                    .addContact({
                                        identity: {
                                            displayName:    $scope.displayName,
                                            mixed:          $scope.mixed
                                        } 
                                    })
                                    .then(function(contact){
                                        if($scope.selected)
                                            $scope.selected[contact.identity.id] = true;

                                        if($scope.conversation)
                                            $scope.conversation.addRecipient(contact.identity);

                                        // reset
                                        $scope.displayName = '';
                                        $scope.mixed = '';
                                        loader.stop();
                                    }, function(){
                                        loader.stop();
                                    });
                        },
                        function(){
                            $scope.cmForm.mixed.$invalid = true;
                            loader.stop();
                        }
                    );
                };
            }
        }
    }
])
.directive('cmContactSearchTag',[
    'cmUserModel',
    '$rootScope', '$routeParams', '$timeout',
    function (cmUserModel,
              $rootScope, $routeParams, $timeout){
        return {
            restrict: 'AE',
            scope: {
                contact: "=cmContact"
            },
            templateUrl: 'comps/contacts/drtv-contact-search-tag.html'
        }
    }
])
.directive('cmContactTag',[
    'cmUserModel',
    '$rootScope', '$routeParams', '$timeout',
    function (cmUserModel,
              $rootScope, $routeParams, $timeout){
        return {
            restrict: 'AE',
            scope: {
                contact: "=cmContact"
            },
            templateUrl: 'comps/contacts/drtv-contact-tag.html',
            link: function(scope, element){
                if('id' in $routeParams
                    && scope.contact
                    && scope.contact.id == $routeParams.id){
                    element.addClass('is-active');
                }
            },
            controller: function($scope){
                $scope.editContact = function () {
                    if($scope.contact.contactType != 'pending') {
                        $rootScope.goTo('/contact/' + $scope.contact.id);
                    }
                };
            }
        }
    }
])
.directive('cmContactTrust',[
    'cmContactsModel',
    function (cmContactsModel){
        return {
            restrict: 'E',
            templateUrl: 'comps/contacts/drtv-contact-trust.html',
            controller: function($scope, $element, $attrs){

                $scope.withText = ('cmWithText' in $attrs) ? true : false;

                var contact,
                    watchOn = true;

                function init(){
                    $scope.$on('$destroy',function(){
                        if(contact && 'securityAspects' in contact)
                            contact.securityAspects.off('refresh', refresh);
                    });

                    initWatch();
                }

                function initWatch(data){
                    if(!watchOn || !data)
                        return false;

                    contact = data.contactType
                    ? data
                    : cmContactsModel.findByIdentity(data);

                    if(contact)
                        watchOn = false;
                    else
                        return false;

                    contact.securityAspects.on('refresh', refresh);

                    refresh();
                }

                function refresh(){
                    contact.securityAspects
                        .get()
                        .then(function(){
                            $scope.noKey = contact.securityAspects.applies('NO_KEY');
                            $scope.hasKey = contact.securityAspects.applies('AT_LEAST_ONE_KEY');
                            $scope.hasAuthenticatedKey = contact.securityAspects.applies('AT_LEAST_ONE_AUTHENTICATED_KEY');
                        });
                }

                init();

                $scope.$watchCollection($attrs.cmData, initWatch);
            }
        }
    }
])
.directive('cmContactType',[
    'cmContactsModel',
    function (cmContactsModel){
        return {
            restrict: 'AE',
            link: function(scope, element, attrs){
                function refresh(data){

                    if(!attrs.cmForceIcon){
                        // data maybe a contact or an identity
                        var identity = data.identity || data;

                        var contact = data.contactType
                                ? data
                                : cmContactsModel.findByIdentity(data),
                            type    = contact ? contact.contactType : 'unknown',
                            icon    = ''

                        icon = (type == 'internal') ? 'cm-rhino-positive'   : icon;
                        icon = (type == 'external') ? 'cm-address-book'     : icon;
                        icon = (type == 'local')    ? 'cm-mobile'           : icon;
                        icon = (type == 'pending')  ? 'cm-rhino-positive'   : icon;
                        icon = (type == 'unknown')  ? 'cm-address-book'     : icon;
                    } else {
                        icon = attrs.cmForceIcon;
                    }


                    element.children().remove();

                    element.append(
                        angular.element('<i></i>')
                        .addClass('fa')
                        .addClass(icon)
                    ).addClass(type);
                }

                scope.$watchCollection(attrs.cmData, refresh);
            }
        }
    }
])

.directive('cmContactsFilterControls',[
    function (){
        return{
            restrict : 'AE',
            scope : true,
            templateUrl : 'comps/contacts/drtv-contacts-filter-controls.html'
        }
    }
])

.directive('cmFriendRequestCounter', [
    'cmContactsModel', 'cmNotify',
    function (cmContactsModel, cmNotify) {
        return {
            restrict : 'E',
            scope: true,
            link: function(scope, element){
                scope.counter = 0;

                scope.setColor = function(){
                    if(scope.counter > 0){
                        element.parent().parent().addClass('info');
                    } else {
                        element.parent().parent().removeClass('info');
                    }
                };

                scope.show = function(){
                    scope.counter = cmContactsModel.requests.length;

                    if(scope.counter > 0){
                        element.html(' (' + scope.counter +')');
                    } else {
                        element.html('');
                        cmNotify.unringBimmel('friendRequest');
                    }

                    scope.setColor();
                };

                function refresh(){
                    scope.show();
                }

                cmContactsModel.requests.on('register deregister', refresh);
                cmContactsModel.on('friendRequests:loaded friendRequests:updated friendRequests:deleted', refresh);

                refresh();

                scope.$on('$destroy', function(){
                    cmContactsModel.requests.off('register deregister', refresh);
                    cmContactsModel.off('friendRequests:loaded friendRequests:updated', refresh);
                });
            }
        }
    }
])
.directive('cmKeyLevel',[
    function (){
        return {
            restrict: 'E',
            template: '<cm-icons icons="cm-lock" alt="cm-unlock" count="{{count}}"></cm-icons>',
            controller: function($scope, $element, $attrs){
                $scope.$watch($attrs.cmData, function(keySize){
                    $scope.count = 0;

                    if(keySize >= 2048){
                        $scope.count = 2;
                    }
                });
            }
        }
    }
])
.directive('cmRequestList', [
    'cmContactsModel', 'cmNotify',
    function(cmContactsModel, cmNotify){
        return {
            restrict: 'E',
            templateUrl: 'comps/contacts/drtv-request-list.html',
            controller: function ($scope) {
                $scope.requests = cmContactsModel.requests;
                $scope.isLoading = false;

                cmNotify.unringBimmel('friendRequest');

                /**
                 * fired by repeat and accept that
                 * @param id
                 */
                $scope.acceptRequest = function(item){
                    if(typeof item == 'object'){
                        item.accept().then(
                            function(){
                                cmContactsModel.removeFriendRequest(item);
                                cmContactsModel.trigger('friendRequests:updated');
                                cmNotify.unringBimmel('friendRequest');
                            }
                        )
                    }
                };

                /**
                 * fired by repeat delete request
                 * @param id
                 */
                $scope.rejectRequest = function(item){
                    if(typeof item == 'object'){
                        item.reject().then(
                            function(){
                                cmContactsModel.removeFriendRequest(item);
                                cmContactsModel.trigger('friendRequests:updated');
                                cmNotify.unringBimmel('friendRequest');
                            }
                        )
                    }
                };

                $scope.ignoreRequest = function(item){
                    if(typeof item == 'object'){
                        item.ignore().then(
                            function(){
                                cmContactsModel.removeFriendRequest(item);
                                cmContactsModel.trigger('friendRequests:updated');
                                cmNotify.unringBimmel('friendRequest');
                            }
                        )
                    }
                }
            }
        }
    }
])
.directive('cmTypeChooser',[
    'cmLogger',
    function (cmLogger){
        // defined types
        var types = {
            types: [
                {i18n:'DRTV.TYPE_CHOOSER.PRIVATE',value:'private','default':true},
                {i18n:'DRTV.TYPE_CHOOSER.BUSINESS',value:'business'},
                {i18n:'DRTV.TYPE_CHOOSER.OTHER',value:'other'}
            ],
            provider: [
                {i18n:'DRTV.TYPE_CHOOSER.LANDLINE',value:'landline'},
                {i18n:'DRTV.TYPE_CHOOSER.IP',value:'ip'},
                {i18n:'DRTV.TYPE_CHOOSER.FAX',value:'fax'},
                {i18n:'DRTV.TYPE_CHOOSER.MOBILE',value:'mobile','default':true}
            ]
        };

        return {
            scope: true,
            templateUrl: 'comps/contacts/drtv-type-chooser.html',
            controller: function($scope, $element, $attrs){
                $scope.buttons = [];
                // TODO: reset parent form must reset types
                // handle special type of choose default
                if('chooseType' in $attrs && $attrs.chooseType in types){
                    $scope.buttons = types[$attrs.chooseType];
                } else {
                    $scope.buttons = types.types;
                }

                /**
                 * search in buttons array for value or default
                 * @string value
                 * @boolean searchDefault
                 * @returns {string}
                 */
                function find(value, searchDefault){
                    var btn = "";
                    angular.forEach($scope.buttons, function(button){
                        if(searchDefault != undefined && 'default' in button){
                            btn = button.value;
                        }
                        if(value != undefined && button.value == value){
                            btn = button.value;
                        }
                    });
                    return btn
                }

                /**
                 * set button to active and set parent scope variable
                 * @string value
                 */
                $scope.setActive = function(value ,isFirst){

                    if(isFirst == undefined && 'cmDisabled' in $attrs && $scope.$eval($attrs.cmDisabled) == true){
                        return false;
                    }

                    $scope.active = find(value);
                    // addtion to parent data collection
                    if($scope.data != undefined && $attrs['chooseToData'] != undefined)
                        $scope.data[$attrs.chooseToData] = $scope.active;

                    // direct addtion to item
                    if('cmChooseValueTo' in $attrs && $scope.$eval($attrs['cmChooseValueTo']) != undefined){
                        $scope.$eval($attrs['cmChooseValueTo']).type = $scope.active;
                    }
                };

                // set default button
                $scope.setActive(find(null, true),true)
            }
        }
    }
])
.factory('cmContactContextModel', [
    'cmStateManagement', 'cmObject', 'cmLogger',
    'cmContactModel',
    '$rootScope', '$q',
    function(cmStateManagement, cmObject, cmLogger,
             cmContactModel,
             $rootScope, $q) {

        function cmContactContextModel(data){
            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state = new cmStateManagement();

            this.id = undefined;
            this.model = undefined;

            function init(model){
                //cmLogger.debug('cmContactContextModel init');

                // check instance of model, if wrong trigger deregister
                self.importData(model);
            }

            this.importData = function(model){
                //cmLogger.debug('cmContactContextModel.importData');

                this.model = model || this.model;
                this.id = this.model.id;
            };

            this.delete = function(){
                //cmLogger.debug('cmContactContextModel.delete');

                return this.model.delete(true);
            };

            init(data);
        }

        return cmContactContextModel;
    }
])

.factory('cmSecurityAspectsContact',[

    'cmSecurityAspects',
    'cmUserModel',
    '$q',

    function(cmSecurityAspects, cmUserModel, $q){
//        var securityAspectsConversation = new cmSecurityAspects()

        function securityAspectsContact(contact){
            var self = new cmSecurityAspects( {languagePrefix: 'SECURITY_ASPECT.CONTACT'} )

            self
            .setTarget(contact)

            self
                .addAspect({
                    id: 'NO_KEY',
                    value: -1,
                    check: function(contact){
                        return contact.identity.keys.length == 0
                    },
                    toggleCheck: function(contact){
                        return false
                    },
                    toggleCall: function(contact){
                        
                    }
                })
                .addAspect({
                    id: 'AT_LEAST_ONE_KEY',
                    value: 1,
                    check: function(contact){
                        return contact.identity.keys.length > 0
                    },
                    toggleCheck: function(contact){
                        return false
                    },
                    toggleCall: function(contact){
                        
                    }
                })
                .addAspect({
                    id: 'AT_LEAST_ONE_AUTHENTICATED_KEY',
                    value: 1,
                    check: function(contact){
                        return  cmUserModel.verifyIdentityKeys(contact.identity)
                                .then(function(ttrusted_keys){
                                    return  ttrusted_keys.length > 0                                             
                                })
                    },
                    toggleCheck: function(contact){
                        return false
                    },
                    toggleCall: function(contact){
                        
                    }
                });

                cmUserModel.on('update:finished', self.scheduleRefresh)

            return self;
        }

        return securityAspectsContact
    }
])
.filter('cmPendingFirst', [

    //no dependencies
    
    function(){
        return  function(arrayOfContacts){
                    var copy = arrayOfContacts.slice(0)
                    return copy.sort(function(contact1, contact2){
                       
                        var a           =   contact1.contactType == 'pending' ? 1 : 0,
                            b           =   contact2.contactType == 'pending' ? 1 : 0

                        return b-a
                    })
                }
    }
])
.service('cmModalContactImport', [
    'cmModal', 'cmIdentityFactory', 'cmUserModel', 'cmConversationFactory',
    '$filter',
    function (cmModal, cmIdentityFactory, cmUserModel, cmConversationFactory,
              $filter) {
        return function cmContactImportModal(data) {

            var messageData = {
                from: '',
                to: ''
            };

            if ('identity' in data) {
                var identity = cmIdentityFactory.create(data.identity, true);
                messageData.from = cmUserModel.data.identity.getDisplayName();
                messageData.to = identity.getDisplayName();
            }

            return cmModal.confirm({
                title: 'CONTACT.IMPORT.NOTIFICATION.HEADER',
                text: 'CONTACT.IMPORT.NOTIFICATION.TEXT',
                html: '<textarea class="confirm-textarea" ng-model="data.messageTemplate"> </textarea>',
                data: {
                    messageTemplate: $filter('cmTranslate')('CONTACT.IMPORT.NOTIFICATION.MESSAGE_TEMPLATE', messageData)
                }
            }).then(function (modalScope) {
                var conversation = cmConversationFactory
                    .create()
                    .addRecipient(identity)
                    .disableEncryption();

                return conversation.save()
                    .then(function () {
                        var message = conversation.messages.create({
                            conversation: conversation,
                            id: '#new_message',
                            fromIdentity: cmUserModel.data.identity,
                            text: modalScope.data.messageTemplate
                        });

                        return conversation.sendMessage(message, null, true);
                    });
            });
        }
    }
])

.factory('cmContactModel', [
    'cmContactsAdapter', 'cmIdentityFactory', 'cmObject',
    'cmStateManagement', 'cmUtil', 'cmLogger', 'cmSecurityAspectsContact', 'cmModal',
    '$q',
    function(cmContactsAdapter, cmIdentityFactory, cmObject,
             cmStateManagement, cmUtil, cmLogger, cmSecurityAspectsContact, cmModal,
             $q){
        function ContactModel(data){
            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state         = new cmStateManagement(['loading']);

            this.id            = undefined;
            this.contactType   = undefined;
            this.group         = [];
            this.identity      = cmIdentityFactory.new();

            this.securityAspects    = new cmSecurityAspectsContact(this);

            function init(data){
                //cmLogger.debug('cmContactModel:init');

                // via id
                if(typeof data == 'string' && data.length > 0){
                    self.id = data;
                    self.update();
                    // via data.id
                } else if(typeof data == 'object' && ('id' in data)){
                    self.id = data.id;
                    if(cmUtil.objLen(data) < 2){
                        self.update();
                    } else {
                        self.importData(data);
                    }
                } else {
                    //todo
                }
            }

            this.importData = function(data) {
                //cmLogger.debug('cmContactModel.importData');

                if(typeof data !== 'object'){
                    cmLogger.debug('cmContactModel:import:failed - no data!');
                    return this;
                }

                this.id = data.id || this.id;
                this.contactType = data.contactType || this.contactType;
                this.groups = data.groups || this.groups;

                if(data.identity){
                    data.identity.userType = this.contactType
                }

                this.identity = data.identity ? cmIdentityFactory.create(data.identity, true) : this.identity;


                this.trigger('update:finished');
            };

            this.setContactType = function(type){
                this.contactType = type;
                return this;
            };

            this.update = function(){
                //cmLogger.debug('cmContactModel.update');

                if(this.id && !this.state.is('loading')){
                    this.state.set('loading');

                    cmContactsAdapter.getOne(this.id).then(
                        function(data){
                            self.importData(data);
                        },
                        function(){
                            cmLogger.debug('cmContactModel.update fail!');
                        }
                    ).finally(
                        function(){
                            self.state.unset('loading');
                        }
                    );
                }
            };

            this.save = function(objectChange){
                //cmLogger.debug('cmContactModel.save');

                var defer = $q.defer();

                if(this.id){
                    cmContactsAdapter.editContact(this.id, objectChange).then(
                        function(){
                            self.identity.importData(objectChange);
                            defer.resolve();
                        },
                        function(){
                            defer.reject();
                        }
                    );
                } else {
                    cmLogger.debug('cmContactModel.save fails - no contact id!');
                    defer.reject();
                }

                return defer.promise;
            };

            this.delete = function(withoutModal){
                return (function(){
                    return withoutModal
                    ? $q.when()
                    : cmModal.confirm({
                        title: 'CONTACT.MODAL.DELETE.HEADER',
                        text: 'CONTACT.MODAL.DELETE.TEXT'
                    })
                }()).then(function(){
                    return cmContactsAdapter.deleteContact(self.id)
                }).then(function(){
                    self.trigger('deleted:finished',self);
                    return $q.when();
                });
            };

            init(data);

            this.identity.on('update:finished', function(){
                self.securityAspects.scheduleRefresh();
            });
        }

        return ContactModel;
    }
])
.service('cmContactsAdapter',[
    'cmApi',
    'cmObject',
    'cmLogger',
    'cmUtil',
    function (cmApi, cmObject, cmLogger, cmUtil){

        var adapter =  {
            /**
             * Search for cameoId Users
             * @param string
             * @returns {*|HttpPromise}
             */
            searchCameoIdentity: function(string, excludeContacts){
                return cmApi.post({
                    path:'/identity/search',
                    data: {
                        search: string,
                        fields: ['cameoId','displayName'],
                        excludeContacts: excludeContacts || true
                    }
                });
            },
            /**
             * Get Contact List
             * @param limit
             * @param offset
             * @returns {*|Array|Object|Mixed|promise|!webdriver.promise.Promise}
             */
            getAll: function(limit, offset){
                return cmApi.get({
                    path:'/contacts' + cmUtil.handleLimitOffset(limit,offset)
                });
            },
            /**
             * Get one Contact in Detail
             * @param id
             * @returns {*|Array|Object|Mixed|promise|!webdriver.promise.Promise}
             */
            getOne: function(id){
                return cmApi.get({
                    path:'/contact/'+id
                })
            },
            /**
             * Get User Groups
             * @returns {*|Array|Object|Mixed|promise|!webdriver.promise.Promise}
             */
            getGroups: function(){
                return cmApi.get({
                    path:'/contact-groups'
                });
            },
            /**
             * Get User from one User Group
             * @param group
             * @param limit
             * @param offset
             * @returns {*|Array|Object|Mixed|promise|!webdriver.promise.Promise}
             */
            getAllFromGroup: function(group,limit,offset){
                return cmApi.get({
                    path:'/contact-group/' + group + cmUtil.handleLimitOffset(limit,offset)
                });
            },
            getFriendRequests: function(){
                return cmApi.get({
                    path:'/friendRequests'
                });
            },
            sendFriendRequest: function(id, message){
                return cmApi.post({
                    path:'/friendRequest',
                    data: {identityId: id, message: message || null}
                });
            },
            answerFriendRequest: function(id, type){
                return cmApi.post({
                    path:'/friendRequest/answer',
                    data: {identityId:id, answerType:type}
                });
            },
            deleteFriendRequest: function(id){
                return cmApi.delete({
                    path:'/friendRequest/'+id
                });
            },
            addContact: function(data){
                return cmApi.post({
                    path:'/contact',
                    data: {identity:data.identity||{}, groups:data.groups||[]}
                });
            },
            editContact: function(id, data){
                return cmApi.put({
                    path:'/contact/'+id,
                    data: data||{}
                });
            },
            deleteContact: function(id){
                return cmApi.delete({
                    path:'/contact/'+id
                });
            }
        };

        cmObject.addEventHandlingTo(adapter);

        cmApi.on('identity:update', function (event, data){
//            cmLogger.debug('cmContactsAdapter.on:identity:update')
            adapter.trigger('identity:updated', data);
        });

        cmApi.on('friendRequest:new', function(event, data){
            adapter.trigger('friendRequest:new', data);
        });

        cmApi.on('friendRequest:accepted', function(event, data){
            adapter.trigger('friendRequest:accepted', data);
        });

        cmApi.on('friendRequest:deleted', function(event, data){
            adapter.trigger('friendRequest:deleted', data);
        });

        cmApi.on('friendRequest:rejected', function(event, data){
            //cmLogger.debug('cmContactsAdapter cmApi.on:friendRequest:rejected');
            adapter.trigger('friendRequest:rejected', data);
        });

        cmApi.on('contact:update', function(event, data){
            //cmLogger.debug('cmContactsAdapter cmApi.on:contact:update');
            adapter.trigger('contact:update', data);
        });

        cmApi.on('contact:deleted', function(event, data){
            //cmLogger.debug('cmContactsAdapter cmApi.on:contact:update');
            adapter.trigger('contact:deleted', data);
        });

        cmApi.on('subscriptionId:changed', function(){
            //cmLogger.debug('cmContactsAdapter.on subscriptionId:changed');
            adapter.trigger('subscriptionId:changed');
        });

        return adapter;
    }
])
.service('cmContactsModel',[
    'cmFactory', 'cmUserModel', 'cmContactModel', 'cmContactsAdapter', 'cmIdentityFactory',
    'cmFriendRequestModel', 'cmStateManagement', 'cmUtil', 'cmObject', 'cmLogger',
    'cmNotify', 'cmBrowserNotifications',
    '$q', '$rootScope',
    function (cmFactory, cmUserModel, cmContactModel, cmContactsAdapter, cmIdentityFactory,
              cmFriendRequestModel, cmStateManagement, cmUtil, cmObject, cmLogger,
              cmNotify, cmBrowserNotifications,
              $q, $rootScope){
        var self = this,
            events = {};

        this.state  = new cmStateManagement(['loading-contacts','loading-groups','loading-requests']);

        this.contacts = new cmFactory(cmContactModel,
            function sameByData(instance, data){
                return data && data.id != '' &&
                      (data.id == instance.id ||
                       data.identity &&
                       data.identity.id &&
                       instance &&
                       instance.identity &&
                       instance.identity.id &&
                       data.identity.id == instance.identity.id)
            },
            function sameByInstance(instance_1, instance_2){
                return      instance_1
                &&  instance_1.identity
                &&  instance_1.identity.id
                &&  instance_2
                &&  instance_2.identity
                &&  instance_2.identity.id
                &&  instance_1.identity.id == instance_2.identity.id
            });

        // TODO: groups must be in factory style with models
        this.groups         =   [];//new cmFactory(function(){return this;});
        this.requests       =   new cmFactory(cmFriendRequestModel, 
            function sameByData(instance, data){
                return      data
                        &&  data.identity
                        &&  data.identity.id
                        &&  instance
                        &&  instance.identity
                        &&  instance.identity.id
                        &&  data.identity.id == instance.identity.id
            },
            function sameByInstance(instance_1, instance_2){
                return      instance_1
                        &&  instance_1.identity
                        &&  instance_1.identity.id
                        &&  instance_2
                        &&  instance_2.identity
                        &&  instance_2.identity.id
                        &&  instance_1.identity.id == instance_2.identity.id
            });

        this.findByIdentity = function(identity){
            return this.contacts.filter(function(contact){
                return contact.identity == identity
            })[0]
        };

        this.findByIdentityId = function(identityId){
            return this.contacts.filter(function(contact){
                return contact.identity.id == identityId
            })[0]
        };
  
        cmObject.addEventHandlingTo(this);

        /**
         * Init Object
         */
        function init(){
//            cmLogger.debug('cmContactsModel:init');
            self.getAll();
            //self.getGroups();
            self.getFriendRequests();
        }

        /**
         * Reset Object
         */
        function reset(){
            //cmLogger.debug('cmContactsModel:reset');
            self.contacts.reset('cmContactsModel.contacts');
            self.groups = [];
            self.requests.reset('cmContactsModel.request');
        }

        /**
         * add to contacts and creates identities
         * @param contact
         * @private
         */

        function _add(contact, forceImport){
            return self.contacts.create(contact, forceImport)
        }

        this._clearContacts = function(){
            this.contacts.reset()
        };

        /**
         * Model Logic
         */
        this.searchCameoIdentity = function(cameoId){
            return cmContactsAdapter.searchCameoIdentity(cameoId, true);
        };

        this.getAll = function(limit, offset, forceImport){
//            cmLogger.debug('cmContactsModel:getAll');
            var i = 0;

            if(cmUserModel.isAuth() !== false && cmUserModel.isGuest() !== true){
                if(!this.state.is('loading-contacts')){
                    this.trigger('start:load-contacts');
                    self.state.set('loading-contacts');

                    cmContactsAdapter.getAll().then(
                        function(data){
                            while(i < data.length){
                                _add(data[i], forceImport);
                                i++;
                            }
                        }
                    ).finally(function(){
                        self.trigger('finish:load-contacts');
                        self.state.unset('loading-contacts');
                    })
                }
            }

            return this;
        };

        this.getOne = function(id){
            return cmContactsAdapter.getOne(id);
        };

        this.getGroups = function(){
//            cmLogger.debug('cmContactsModel:getGroups');

            if(this.groups.length < 1 && cmUserModel.isAuth() !== false && cmUserModel.isGuest() !== true){
                if(!this.state.is('loading-groups')) {
                    this.state.set('loading-groups');

                    cmContactsAdapter.getGroups().then(
                        function (data) {
                            self.groups = data;
                        }
                    ).finally(function(){
                        self.state.unset('loading-groups')
                    });
                }
            }

            return this;
        };

        this.getAllFromGroup = function(group,limit,offset){
            return cmContactsAdapter.getAllFromGroup(group,limit,offset);
        };

        /**
         * Friend Request Handling
         */


        this.getFriendRequests = function(){
//            cmLogger.debug('cmContactsModel:getFriendRequests');
            if(cmUserModel.isAuth() !== false && cmUserModel.isGuest() !== true){
                if(!this.state.is('loading-requests')){
                    this.state.set('loading-requests');

                    cmContactsAdapter.getFriendRequests().then(
                        function(data) {
//                        cmLogger.debug('cmContactsModel:getFriendRequests:done');
                            var old_length = self.requests.length;

                            angular.forEach(data, function (request_data) {
                                self.requests.create(request_data)
                            });

                            if (old_length < self.requests.length) {
                                self.trigger('friendRequests:loaded');
                            }
                        }
                    ).finally(function(){
                        self.state.unset('loading-requests');
                    })
                }
            }
        };

        this.removeFriendRequest = function(request){
            this.requests.deregister(request)

            return this;
        };

        this.sendFriendRequest = function(id, message){
            return cmContactsAdapter.sendFriendRequest(id, message);
        };

        this.deleteFriendRequest = function(contact){
            return cmContactsAdapter
                .deleteFriendRequest(contact.identity.id)
                .then(function(){
                    self.contacts.deregister(contact);
                });
        };

        this.addContact = function(data){
            var defer = $q.defer();

            this.trigger('before-add-contact');

            return  cmContactsAdapter
                    .addContact(data)
                    .then(function(data){
                        self.trigger('add-contact', data);
                        var contact = _add(data);
                        self.trigger('after-add-contact', data);
                        return contact;
                    });
        };

        /**
         * @deprecated
         */
        this.editContact = function(id, data){
            cmLogger.debug('cmContactsModel.editContact is deprecated! - Use now cmContactModel.save()');

            var defer = $q.defer();
            cmContactsAdapter
                .editContact(id, data)
                .then(
                function(data){
//                _edit(data);
                    defer.resolve();
                },
                function(){
                    defer.reject();
                }
            );

            return defer.promise;
        };

        /**
         * event handling
         */
        $rootScope.$on('logout', function(){
            reset();
        });

        $rootScope.$on('login', function(){
            reset();
        });

        $rootScope.$on('identity:switched', function(){
            reset();
        });

        this.on('friendRequests:updated friendRequest:sent after-add-contact', function(){
            this._clearContacts();
            init();
        });

        cmContactsAdapter.on('friendRequest:new', function(event, data){
            if(data.to == cmUserModel.data.identity.id){
                var request = self.requests.create(data.friendRequest);

                cmBrowserNotifications.showFriendRequest(request.identity);
            }
        });

        cmContactsAdapter.on('friendRequest:deleted', function(event, data){
            self.requests.forEach(function(request){
                if(request.identity.id == data.from)
                    self.requests.deregister(request)
            });
        });

        cmContactsAdapter.on('friendRequest:accepted', function(event, data){
            // Friend request sent by the current user was accepted:
            if(data.from == cmUserModel.data.identity.id){
                self.contacts.create(data.contact, true);
            }

            // Friend request accepted by the current user (on a different device):
            if(data.to == cmUserModel.data.identity.id){
                self.requests.forEach(function(request){
                    if(request.identity.id == data.from) {
                        self.requests.deregister(request);
                        self.contacts.create(data.contact, true);
                    }
                });
            }
        });

        cmContactsAdapter.on('friendRequest:rejected', function(event, data){
            if(data.to == cmUserModel.data.identity.id){
                self.requests.forEach(function(request){
                    if(request.identity.id == data.from)
                        self.requests.deregister(request)
                });

                cmNotify.unringBimmel();
            }

            if(data.from == cmUserModel.data.identity.id){
                self.contacts.forEach(function(contact){
                    if(contact.identity.id == data.to)
                        self.contacts.deregister(contact)
                });
            }
        });

        this.requests.on('register', function(){
            cmNotify.create({label:'NOTIFICATIONS.TYPES.FRIEND_REQUEST',type:'friendRequest', bell:true});
        });

        this.contacts.on('deleted:finished', function(event, data){
            self.contacts.deregister(data);
            $rootScope.goto('/contact/list');
        });

        cmContactsAdapter.on('identity:updated', function(event, data){
            if(typeof data.id != 'undefined') {
                var contact = self.contacts.filter(function (contact) {
                    return contact.identity.id == data.id
                })[0];

                if (typeof contact == 'object' && 'identity' in contact && typeof contact.identity.importData == 'function') {
                    contact.identity.importData(data);
                }
            }
        });

        cmContactsAdapter.on('contact:update', function(event, data){
            self.contacts.create(data, true);
        });

        cmContactsAdapter.on('contact:deleted', function(event, data){
            self.contacts.deregister(data);
        });

        cmContactsAdapter.on('subscriptionId:changed', function(){
            self.getAll(true);
            self.getFriendRequests();
        });



        cmUserModel.on('update:finished', function(){
            init();
        });
    }
])
.factory('cmFriendRequestModel',[
    'cmContactsAdapter',
    'cmIdentityFactory',
    'cmObject',
    'cmLogger',
    function (cmContactsAdapter, cmIdentityFactory, cmObject, cmLogger){
        var FriendRequestModel = function(data){

            this.message        = '';
            this.timeOfCreation = 0;
            this.identity       = undefined;
            this.id             = undefined;

            this.accept = function(){
                cmLogger.debug('cmFriendRequestModel:accept');

                return cmContactsAdapter.answerFriendRequest(this.identity.id, 'accept');
            };

            this.reject = function(){
                cmLogger.debug('cmFriendRequestModel:reject');

                return cmContactsAdapter.answerFriendRequest(this.identity.id, 'reject');
            };

            this.ignore = function(){
                cmLogger.debug('cmFriendRequestModel:ignore');

                return cmContactsAdapter.answerFriendRequest(this.identity.id, 'ignore');
            };

            this.importData = function(data){
                this.identity       = 'identity' in data ? cmIdentityFactory.create(data.identity) : this.identity 
                this.message        = data.message || this.message
                this.timeOfCreation = data.created || this.timeOfCreation
                this.id             = this.identity && this.identity.id
            };

            cmObject.addEventHandlingTo(this)
            this.importData(data)
        }

        return FriendRequestModel;
    }
])
angular.module('comps/conversations/drtv-conversation-tag.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-conversation-tag.html',
'<cm-avatar cm-data="avatarIdentity"></cm-avatar><div class="details"><div class="subject is-selectable" data-qa="conversation-subject" ng-bind-html="(conversation.subject || \'CONVERSATION.NO_SUBJECT\' )| cmParse"></div><cm-message class = "message" cm-data = "conversation.lastMessage" text-only = "true" data-qa = "conversation-last-message" ng-hide = true ></cm-message><div class="recipients"><cm-recipients-comma-seperated cm-data="conversation"></cm-recipients-comma-seperated></div></div><div class="meta"><div class="top"><cm-lock-level cm-level="conversation.lockStatus.level"></cm-lock-level><span class="last-updated small"><cm-time-converter cm-timestamp="timeOfLastUpdate" cm-special-type="conversation-tag"></cm-time-converter></span></div><div class="bottom"><cm-recipient-counter ng-if="conversation.recipients.length > 2">{{::conversation.recipients.length||0}}</cm-recipient-counter><span class="message-count is-selectable" ng-class="{\'cm-orange\' : conversation.unreadMessages > 0, \'cm-light-grey\': conversation.unreadMessages == 0}" ng-if="settings.get(\'enableUnreadMessages\') && (conversation.unreadMessages > -1)" data-qa="ctn-unread-messages"> ({{conversation.unreadMessages || 0}}) </span><span class="message-count is-selectable"> {{conversation.numberOfMessages || 0}} </span></div></div>');
}]);
angular.module('comps/conversations/drtv-conversation.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-conversation.html',
'<cm-scrollable cm-data="cm-answer"><div class="conversation-header"><h2><span ng-if="conversation.state.is(\'new\')"><i class="fa cm-talk"></i> {{::\'CONVERSATION.HEADING\'|cmTranslate}}</span><span ng-if="!conversation.state.is(\'new\') && conversation.subject" class="single-line"><i class="fa cm-talk"></i><span ng-bind-html="::conversation.subject|cmParse" data-qa="text-subject" class="is-selectable"></span></span></h2><cm-conversation-menu cm-data="conversation" data-qa="menu-conversation"></cm-conversation-menu></div><section class="body-group recipients" ng-if="conversation.state.is(\'new\') || !conversation.state.is(\'new\') && conversation.recipients.length > 1"><h3 ng-click="goto(\'conversation/\'+(conversation.id||\'new\')+\'/recipients\')" cm-reactive data-qa="btn-add-recipients" cm-user-rights><i class="fa" ng-class="{\'cm-new-contact\':conversation.recipients.length == 1, \'cm-list\':conversation.recipients.length > 1}"></i> {{::\'CONVERSATION.PLACEHOLDER.RECIPIENTS\'|cmTranslate}}<span class="recipients-counter is-selectable">({{conversation.recipients.length-1}})</span><span class="recipient-name is-selectable" ng-show="showGrid">{{recipientName}}</span></h3><div class="recipients-list"><div class="scroller" ng-class="{ \'show-scrollbar\': conversation.recipients.length > 7 && showGrid, \'disable-scrollbar\': !showGrid }"><div class="add-new-recipients" ng-click="goto(\'conversation/\'+(conversation.id||\'new\')+\'/recipients\')" cm-reactive ng-if="conversation.recipients.length == 1 && conversation.state.is(\'new\')"><cm-avatar cm-avatar-view="unknown"></cm-avatar><span>{{\'CONVERSATION.PLACEHOLDER.ADD_RECIPIENTS\'|cmTranslate}}</span></div><cm-avatar cm-data="recipient" ng-click="showName(recipient)" ng-class="{ \'name-shown\': recipientName == recipient.getDisplayName() }" ng-repeat="recipient in conversation.recipients|cmHideAppOwner|orderBy:\'getDisplayName()\':false" cm-first-of-repeat="showName(recipient)" ng-show="showGrid"></cm-avatar><cm-recipients-comma-seperated cm-data="conversation" ng-show="!showGrid"></cm-recipients-comma-seperated></div><div class="cm-add-button" ng-click="toggleRecipientView()" cm-reactive ng-if="conversation.recipients.length > 1" ><i class="fa" ng-class="{\'cm-grid\':!showGrid,\'cm-menu-weight\':showGrid}"></i></div></div></section><section class="body-group no-pad border-top" ng-if="conversation.state.is(\'new\')"><article class="content cm-form-style mt5"><label>{{::\'CONVERSATION.PLACEHOLDER.SUBJECT\' | cmTranslate}}</label><div class="cm-input-ctn with-inside-icon"><input name="subject" type="text" data-qa="input-subject" ng-model="conversation.subject" placeholder="{{::\'CONVERSATION.PLACEHOLDER.NO_SUBJECT\'|cmTranslate}}" cm-adaptive-change /><i class="fa cm-write"></i></div></article><div class="h10"></div></section><button class="cm-btn-grey" ng-if="conversation && conversation.numberOfMessages > conversation.messages.length" ng-show="conversation.numberOfMessages != conversation.messages.length" ng-click="loadPreviousMessages()" data-qa="btn-load-more-messages" cm-reactive> {{::\'CONVERSATION.LABEL.LOAD_PREVIOUS\'|cmTranslate}}</button><div id="conversation-top"></div><cm-messages-timeline></cm-messages-timeline><div id="conversation-bottom" cm-scroll-to="{anchor:\'#conversation-bottom\',force:\'bottom\',onEvent:true}"></div></cm-scrollable><cm-answer></cm-answer><cm-modal-handshake-info id="handshake-info" nose-position="6rem"></cm-modal-handshake-info>');
}]);
angular.module('comps/conversations/drtv-message-assets.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-message-assets.html',
'<div class="assets clearfix {{conversation.lockStatus.class}}-wrap"><!-- <cm-loader ng-show = "message.state.is(\'sending\')" cm-color = "ci-color" type = "balls"></cm-loader> --><span class="date"><cm-time-converter cm-timestamp="message.created" cm-date-format="settings.get(\'timeFormat\')"></cm-time-converter></span><span class="envelope"><i class="fa" ng-class = "{\'cm-send\' : message.state.is(\'sending\'), \'cm-envelope-closed\' : !message.state.is(\'sending\')}"></i></span><span ng-if = "message.state.is(\'signed\')" data-qa = "signed"></span><span ng-if = "message.state.is(\'valid\')" data-qa = "valid"><i class = "fa cm-write"></i></span><span ng-if = "!message.state.is(\'signed\')" data-qa = "unsigned"></span><span ng-if = "message.state.is(\'defective\')" data-qa = "defective" class ="cm-orange"><i class = "fa cm-attention"></i></span><span ng-if = "message.state.is(\'authentic\')" data-qa = "authentic"><i class = "fa cm-contract"></i></span><span ng-if = "message.state.is(\'unverifiable\')" data-qa = "unverifiable"></span></div>');
}]);
angular.module('comps/conversations/drtv-message-file.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-message-file.html',
'<div class="file-download" ng-if="file.state.is(\'readyForDownload\') || file.state.is(\'onDownload\') || file.state.is(\'onUpload\')" ng-click="file.startDownloadChunks()" cm-reactive><div class="file-state"><div class="file {{::file.detectedExtension}}"></div><cm-progressbar cm-percent="progress" ng-if="file.state.is(\'onDownload\') || file.state.is(\'onUpload\')"></cm-progressbar></div><div class="file-informations"><span class="file-size"><i class="fa" ng-class="{\'cm-download\':!file.state.is(\'onUpload\'),\'cm-upload\':file.state.is(\'onUpload\')}"></i><br /> {{::cmUtil.bytesToStr(file.size)}}</span><span class="file-name"> {{::file.name}}</span></div></div><div ng-if="file.state.is(\'cached\')"><div class="file-image" ng-if="file.isEmbed(\'image\')" cm-fullscreen="{{file.name}} ({{cmUtil.bytesToStr(file.size)}})"><cm-loader cm-color="ci-color" class="full-inline" ng-show="!file.loaded"></cm-loader><img cm-blob-image="file" cm-stay-in-mask="cm-message-file" cm-pinch-and-pan="{initOnFullscreen:true}" /></div><div class="file-html5" ng-if="file.isEmbed(\'video\')"><cm-loader cm-color="ci-color" ng-show="!file.loaded"></cm-loader><video controls="true" cm-blob-video-audio="file"></video></div><div class="file-detail" ng-if="file.isEmbed(\'audio\') || !file.isEmbed()" ><div class="file-state"><div class="file {{::file.detectedExtension}}"></div><div class="file-html5" ng-if="file.isEmbed(\'audio\')"><audio controls="true" cm-blob-video-audio="file"></audio></div></div><div class="file-informations" ng-click="file.promptSaveAs()"><span class="file-size"><i class="fa cm-save"></i><br /> {{::cmUtil.bytesToStr(file.size)}}</span><span class="file-name"> {{::file.name}}</span></div></div></div>');
}]);
angular.module('comps/conversations/drtv-message.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-message.html',
'<article class="clearfix" ng-if="!textOnly && messageProper()"><div ng-if="!is_my_own_message" class="avatar cm-fl mr5"><cm-avatar cm-data="message.from"></cm-avatar></div><div class="message {{ is_my_own_message ? \'right\' : \'left\'}} cm-fl"><span class="nose {{ is_my_own_message ? \'right\' : \'left\'}}"><i class="fa {{ is_my_own_message ? \'cm-nose-right\' : \'cm-nose-left\'}}"></i></span><div class="author" ng-if="!is_my_own_message" data-qa="message-author"><span class="from is-selectable">{{ message.from.getDisplayName() }}</span></div><div class = "text" ng-class = "{\'own-message\':is_my_own_message}" ><span ng-if="!displayEncrypted() && message.text != \'\'" ng-bind-html="message.text|cmParse" cm-html-compile class="is-selectable"></span><span ng-if="displayEncrypted()" class="is-selectable">{{\'CONVERSATION.TEXT.ENCRYPTED\'|cmTranslate}}</span></div><div><cm-message-file ng-repeat="file in message.files"></cm-message-file></div><cm-message-assets></cm-message-assets></div></article><span ng-if="textOnly && messageProper()"><span class="is-selectable" ng-if="isType(\'text\') && !displayEncrypted()" ng-bind-html="message.text|cmParse:{autolink:true}"></span><span class="is-selectable" ng-if="isType(\'text\') && displayEncrypted()">{{\'CONVERSATION.TEXT.ENCRYPTED\'|cmTranslate}}</span><span class="is-selectable" ng-if="isType(\'image\')">{{\'CONVERSATION.TAG.IMAGE\'|cmTranslate}}</span><span class="is-selectable" ng-if="isType(\'file\')">{{\'CONVERSATION.TAG.FILE\'|cmTranslate}}</span></span>');
}]);
angular.module('comps/conversations/drtv-recipient-tag.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-recipient-tag.html',
'<cm-avatar cm-data="identity"></cm-avatar><cm-contact-trust cm-data="identity"></cm-contact-trust><section class="displayName" data-qa="contact-display-name"> {{identity.getDisplayName()}}</section><cm-contact-type cm-data="identity"></cm-contact-type>');
}]);
angular.module('comps/conversations/drtv-recipients.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-recipients.html',
'<cm-scrollable><ul ng-if="(conversation.recipients.length > 1)" ng-class="{\'mb15\': conversation.state.is(\'new\') && (conversation.recipients.length > 1)}" data-qa="list-recipients"><li ng-repeat="identity in conversation.recipients|cmHideAppOwner|orderBy:\'getDisplayName()\':false" class="tag-with-icon-list"><cm-recipient-tag cm-data-selected="selected" cm-data="identity" cm-data-conversation="conversation" ng-click="goToContactWithIdentity(identity)" cm-reactive></cm-recipient-tag><section class="icon-list" data-qa="btn-select-contact" ng-click="toggleRecipient(identity)" cm-reactive><i class="fa" ng-class="{\'cm-checkbox\':!selected[identity.id], \'cm-checkbox-right\':selected[identity.id]}"></i></section></li></ul><!--<hr ng-if="conversation.state.is(\'new\') && (conversation.recipients.length > 1)">--><div id="possible-recipient-list" cm-scroll-to="{anchor:\'#possible-recipient-list\',onEvent:true,timeout:50,addElementsHeight:\'cm-header\'}"></div><ul ng-if="conversation.state.is(\'new\')" class="contact-list"><li ng-repeat = "contact in contacts|cmRecipients:false:selected|cmSearch:\'contacts\':search" ng-if = "contact.contactType != \'pending\'" class="tag-with-icon-list" ><cm-recipient-tag cm-data="contact.identity" ng-click="goToContactWithIdentity(contact.identity)" cm-reactive></cm-recipient-tag><section class="icon-list" data-qa="btn-select-contact" ng-click="toggleRecipient(contact.identity)" cm-reactive><i class="fa" ng-class="{\'cm-checkbox\':!selected[identity.id], \'cm-checkbox-right\':selected[identity.id]}"></i></section></li><li><cm-contact-quick cm-input = "{{search}}" cm-identity-model = "identity" cm-data-selected = "selected" cm-data-conversation = "conversation" ></cm-contact-quick></li></ul></cm-scrollable><cm-footer><button ng-click="goBack()" class="cm-btn-grey" data-qa="btn-done" cm-weight="1" cm-reactive> {{\'RECIPIENTS.LABEL.DONE\'|cmTranslate}}</button></cm-footer>');
}]);
angular.module('comps/conversations/drtv-security-settings.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/drtv-security-settings.html',
'<cm-scrollable><div ng-if="conversation.securityAspects.getApplyingAspects()"><cm-security-aspect ng-repeat = "aspect in conversation.securityAspects.getPositiveAspects()" cm-data = "aspect" cm-show-toggle-options = "{{conversation.state.is(\'new\')}}" ></cm-security-aspect><cm-security-aspect ng-repeat = "aspect in conversation.securityAspects.getNegativeAspects()" cm-data = "aspect" cm-show-toggle-options = "{{conversation.state.is(\'new\')}}" ></cm-security-aspect></div><article class="item"><span class="body security-headline"> {{\'CONVERSATION.PLACEHOLDER.ENCRYPTION\' | cmTranslate}}</span><span class="icon-list security-settings" ng-click="toggleConversationEncryption()" data-qa="btn-encryption"><i class="fa" ng-class="{\'cm-checkbox\':!conversation.isEncrypted(), \'cm-checkbox-right\':conversation.isEncrypted(), \'cm-grey\':!conversation.state.is(\'new\')}" data-qa="icon-checkbox-encryption"></i></span></article><article class="item" ng-if="conversation.passwordRequired()" ng-class="{\'no-border\':(conversation.state.is(\'new\') && conversation.options.hasCaptcha)}"><span class="body security-headline"> {{\'CONVERSATION.PLACEHOLDER.PASSCAPTCHA\' | cmTranslate}}</span><span class="icon-list security-settings" ng-click="toggleCaptcha()" data-qa="btn-toggle-captcha"><i class="fa" ng-class="{\'cm-checkbox\':!conversation.options.hasCaptcha, \'cm-checkbox-right\':conversation.options.hasCaptcha, \'cm-grey\':!conversation.state.is(\'new\')}" data-qa="icon-checkbox-passcaptcha"></i></span></article><!--<article class="item" ng-if="(conversation.passwordRequired() && conversation.isEncrypted()) || conversation.hasPassword()">--><article class="item" ng-if="(conversation.passwordRequired() && conversation.options.hasCaptcha)"><section class="captcha" ng-if="conversation.state.is(\'new\') && conversation.options.hasCaptcha" data-qa="captcha-canvas"><cm-captcha></cm-captcha><p ng-if="!conversation.state.is(\'new\')"><button ng-click="requestCaptcha()"><i class="fa cm-key"></i> {{"CONVERSATION.LABEL.REQUEST_CAPTCHA"|cmTranslate}}</button></p><p ng-if="!conversation.state.is(\'new\')"><button ng-click="sendCaptcha()"><i class="fa cm-send"></i> {{"CONVERSATION.LABEL.SEND_CAPTCHA"|cmTranslate}}</button></p></section><span class="icon-list captcha-reload" ng-click="refreshCaptcha()" ng-if="conversation.state.is(\'new\')"><i class="fa cm-change"></i></span><section class="captcha" ng-if="!conversation.state.is(\'new\')" data-qa="captcha-image"><img cm-blob-image="conversation.passCaptcha" /></section></article><article class="item cm-form-style no-border pt15" ng-if="conversation.passwordRequired()"><span class="security-headline">{{\'CONVERSATION.PLACEHOLDER.PASSWORD\'|cmTranslate}}</span><div class="cm-input-ctn with-inside-icon" ng-class="{\'with-inside-icon\':!conversation.state.is(\'new\')}" cm-input-watcher><input data-qa = "input-password" type = "text" ng-model = "conversation.password" placeholder = "{{\'CONVERSATION.PLACEHOLDER.PASSWORD\'|cmTranslate}}" ng-change = "decrypt()" ng-disabled = "conversation.state.is(\'decrypted\')" cm-adaptive-change = "2000" /><i class="fa cm-write" ng-if="conversation.state.is(\'new\')"></i><i class="fa cm-checker" ng-if="!conversation.state.is(\'new\') && conversation.state.is(\'decrypted\')" data-qa="icon-conversation-decrypted"></i></div><cm-info-bubble class="cm-alert" ng-if="showPasswordLocalKeyInfo && conversation.state.is(\'new\')"><i class="fa cm-attention"></i> {{\'CONVERSATION.LABEL.SHOW_PW_INFO_BECAUSE_USER_HAS_NO_LOCAL_KEYS\'|cmTranslate}}</cm-info-bubble><cm-info-bubble class="classic-link" ng-click="goTo(\'/settings/identity/key/list\')" ng-if="conversation.options.showKeyInfo && conversation.state.is(\'new\')"> {{\'CONVERSATION.LABEL.KEY_GENERATION\'|cmTranslate}}</cm-info-bubble></article></cm-scrollable><cm-footer><button ng-click="goBack()" class="cm-btn-grey" data-qa="btn-security-done" cm-reactive> {{\'CONVERSATION.SETTINGS.OKAY\'|cmTranslate}}</button></cm-footer>');
}]);
angular.module('comps/conversations/menu/drtv-conversation-menu.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/menu/drtv-conversation-menu.html',
'<div class="cm-handler" ng-click="handleMenu()" data-qa="btn-open-conversation-menu" cm-reactive><i class="fa cm-menu"></i></div><div class="cm-menu-layer" ng-class="{\'is-active\':menuVisible}"><div class="cm-nose-wrapper" ng-click="handleMenu()"><i class="fa cm-nose-up"></i></div><ul><li data-qa="btn-add-recipient" ng-if="conversation.state.is(\'new\')" ng-click="goto(\'conversation/new/recipients\')" cm-reactive><i class="fa cm-checkbox-add"></i> {{::\'CONVERSATION.MENU.ADD_RECIPIENTS\'|cmTranslate}}</li><li data-qa="btn-show-recipient" ng-if="!conversation.state.is(\'new\') && conversation.recipients.length > 1" ng-click="goto(\'conversation/\'+(conversation.id||\'new\')+\'/recipients\')" cm-reactive><i class="fa cm-list"></i> {{::\'CONVERSATION.MENU.SHOW_RECIPIENTS\'|cmTranslate}}</li><li data-qa="btn-security-settings" ng-click="goto(\'conversation/\'+(conversation.id||\'new\')+\'/security\')" cm-reactive><i class="fa cm-lock"></i> {{::\'CONVERSATION.MENU.SECURITY_SETTINGS\'|cmTranslate}}</li><li data-qa="btn-delete-talk" ng-if="!conversation.state.is(\'new\')" ng-click="delete()" cm-reactive><i class="fa cm-trash"></i> {{::\'CONVERSATION.MENU.DELETE\'|cmTranslate}}</li></ul></div>');
}]);
angular.module('comps/conversations/modal/drtv-handshake-info.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/conversations/modal/drtv-handshake-info.html',
'<cm-modal id="{{modalId}}" cm-title="CONVERSATION.MODAL.ASYMMETRIC_KEY_TRUST_ERROR.HEADER" type="plain" nose="top-right" severity="info" nose-position="{{nosePosition||0}}" class="no-padding"><div class="modal-row taj"><span ng-bind-html="::\'CONVERSATION.MODAL.ASYMMETRIC_KEY_TRUST_ERROR.TEXT\' | cmParse"></span></div><div class="modal-row modal-link" ng-click="goTo(\'/authentication\')" cm-reactive data-qa="btn-modal-handshake-link"><i class="fa cm-handshake"></i> {{::\'IDENTITY.KEYS.AUTHENTICATION.HEADLINE\'|cmTranslate}}</div></cm-modal>');
}]);
angular.module('cmConversations', [
    'cmConfig',
    'cmCore',
    'cmFiles',
    'cmSecurityAspects',
    'cmUser',
    'cmValidate'
,'comps/conversations/drtv-conversation-tag.html','comps/conversations/drtv-conversation.html','comps/conversations/drtv-message-assets.html','comps/conversations/drtv-message-file.html','comps/conversations/drtv-message.html','comps/conversations/drtv-recipient-tag.html','comps/conversations/drtv-recipients.html','comps/conversations/drtv-security-settings.html','comps/conversations/menu/drtv-conversation-menu.html','comps/conversations/modal/drtv-handshake-info.html'])
.directive('cmCaptcha',[
    'cmCrypt', function (cmCrypt){
        return {
            restrict: 'AE',
            scope: true,
            require: '^cmConversation',
            template: '<canvas id="canvas"></canvas>', //MOCK

            controller:	function($scope, $element, $attrs){
                var captcha;

                $scope.captchaDim = $element[0].offsetWidth + 'x' + $element[0].offsetHeight;
                $scope.captchaFont = "sans";
                $scope.captchaImageData = '';

                $scope.create = function(){
                    var dim = $scope.captchaDim.split("x");
                    captcha = new Captchagen({
                        width: dim[0]
                        ,height: dim[1]
                        ,text: $scope.conversation.password || cmCrypt.generatePassword(6)
                        ,font: $scope.captchaFont
                    });
                    captcha.generate();

                    $scope.conversation.password = captcha.text();
                    $scope.conversation.tmpPassCaptcha = captcha.uri();
                };

                $scope.refreshCaptcha = function(){
                    captcha.refresh($scope.conversation.password);
                    $scope.conversation.tmpPassCaptcha = captcha.uri();
                };

                $scope.create();

                $scope.$watch('conversation.password', $scope.refreshCaptcha);
                $scope.$on('captcha:refresh',$scope.refreshCaptcha);
            }
        }
    }
])
.directive('cmConversationTag',[
    'cmUserModel',
    'cmSettings',
    '$routeParams',
    function (cmUserModel, cmSettings, $routeParams){
        return {
            restrict: 'AE',
            scope: {
                conversation: "=cmData"
            },
            templateUrl: 'comps/conversations/drtv-conversation-tag.html',
            priority: 0,
            link: function(scope, element){
                if('conversationId' in $routeParams
                && scope.conversation
                && scope.conversation.id == $routeParams.conversationId){
                    element.addClass('is-active');
                }
            },
            controller: function($scope){

                $scope.settings = cmSettings;

                function update(){
                    /**
                     * set Avatar Identity
                     */
                    if($scope.conversation.recipients.length > 2){
                        $scope.avatarIdentity = $scope.conversation.lastMessage.from;
                    } else {
                        if($scope.conversation.recipients.length == 1){
                            $scope.avatarIdentity = cmUserModel.data.identity;
                        } else {
                            var arr_recipients = $scope.conversation.recipients.filter(function(recipient){
                                return recipient.id != cmUserModel.data.identity.id;
                            });

                            $scope.avatarIdentity = arr_recipients[0];
                        }
                    }

                    $scope.timeOfLastUpdate = $scope.conversation.timeOfLastUpdate;
                }

                $scope.conversation.on('update:finished message:new',update);

                $scope.conversation.recipients.on('deregister', update)

                update();

                $scope.$on('$destroy', function () {
                    $scope.conversation.off('update:finished message:new', update);
                    $scope.conversation.recipients.off('deregister', update)
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetConversation
 * @description
 * Display Conversation and provides functionality.
 *
 * @restrict AE
 */


.directive('cmConversation', [

    'cmConversationFactory', 'cmUserModel', 'cmCrypt', 'cmLogger', 'cmNotify',
    'cmModal', 'cmEnv', 'cmSettings', 'cmKeyStorageService', 'cmTransferScopeData',
    'cmErrorCodes', 'cmAnswerFiles', 'cmKeyboard',
    '$location', '$rootScope', '$document', '$routeParams', '$q',

    function (cmConversationFactory, cmUserModel, cmCrypt, cmLogger, cmNotify,
              cmModal, cmEnv, cmSettings, cmKeyStorageService, cmTransferScopeData,
              cmErrorCodes, cmAnswerFiles, cmKeyboard,
              $location, $rootScope, $document, $routeParams, $q) {
        return {
            restrict: 'AE',
            templateUrl: 'comps/conversations/drtv-conversation.html',
            scope: true,

            controller: function ($scope, $element, $attrs) {
                
                var self                 = this,
                    conversation_subject = $scope.$eval($attrs.cmSubject),
                    conversation_offset  = $attrs.offset,
                    conversation_limit   = $attrs.limit,
                    filesForMessage      = [],
                    showedAsymmetricKeyError = false,
                    storageService = new cmKeyStorageService('conversation-recipient-view');

                $scope.goto = $rootScope.goto;
                $scope.openFastRegister = $rootScope.openFastRegister;
                $scope.showLogin = $rootScope.showLogin;

                $scope.isSending        = false;
                $scope.isSendingAbort   = false;

                $scope.recipientName = '';
                function showRecipientName(identity){
                    $scope.recipientName = identity.getDisplayName();
                }

                // show name of incoming identity
                $scope.showName = function(identity){
                    if(identity && !('isAppOwner' in identity) && $scope.recipientName != identity.getDisplayName()){
                        showRecipientName(identity);

                        identity.on('update:finished', function(){
                            showRecipientName(identity);
                        });
                    }
                };

                /**
                 * handle Recipient View
                 */
                $scope.showGrid = cmSettings.get('defaultShowRecipientAvatar'); // degault grid off, wenn recipient.length > 2
                if(!$scope.conversation.state.is('new')){
                    $scope.showGrid = storageService.get($scope.conversation.id)
                }

                $scope.toggleRecipientView = function(){
                    if($scope.showGrid){
                        $scope.showGrid = false;
                        if(!$scope.conversation.state.is('new')){
                            storageService.set($scope.conversation.id, false)
                        }
                    } else {
                        $scope.showGrid = true;
                        if(!$scope.conversation.state.is('new')){
                            storageService.set($scope.conversation.id, true)
                        }
                    }
                };

                $scope.loadPreviousMessages = function(){
                    $scope.conversation.update();
                };

                function checkConversationSetup(){
                    $scope.isSending        = true;
                    $scope.isSendingAbort   = false;

                    if(!$scope.conversation.checkConsistency()){
                        $scope.conversation.trigger('save:aborted');
                        $scope.isSendingAbort = true;
                        return $q.reject('conversation unreliable.')
                    }

                    // Is the conversation newly created and has not been saved to the backend yet?
                    return  $scope.conversation.state.is('new')
                                // the conversations has not been saved to the Backend, do it now:
                            ?   $scope.conversation.save()
                                // when that is done try again to send the message:
                                .then(function(conversation_data){
                                    $scope.conversation.importData(conversation_data)
                                    cmConversationFactory.register($scope.conversation);
                                    //$rootScope.$broadcast('new-conversation:ready')
                                    return $q.when()
                                })
                            :   $q.when()
                }

                function prepareFiles(passphrase){
                    /**
                     * check if files exists
                     * after success sendMessage
                     */
                    
                    var deferred = $q.defer();

                    cmAnswerFiles.validateChoosenFiles({
                        passphrase: passphrase,
                        conversationId: $scope.conversation.id
                    }).then(
                        function(files){
                            if (files.length > 0)
                                filesForMessage = files;
                            deferred.resolve()
                        },
                        function(error){
                            $scope.isSending = false;
                            $scope.isSendingAbort = true;

                            cmNotify.warn(error.codes[0], {
                                ttl: 0,
                                i18n: cmErrorCodes.toI18n(error.codes[0], {
                                    error: error.data,
                                    headers: error.headers
                                })
                            });

                            deferred.reject(data.errorCodes);
                        }
                    );

                    return deferred.promise;
                }

                /**
                 * start sending process
                 * with preparing files for upload
                 * after preparation send message
                 */
                $scope.send = function(event){
                    /**
                     * reset focus to answer textarea
                     */
                    cmKeyboard.focusLast(event);

                    if((!$scope.newMessageText || $scope.newMessageText.length == 0)
                    && cmAnswerFiles.files.length  == 0){
                        cmNotify.warn('CONVERSATION.WARN.MESSAGE_EMPTY', {ttl:5000});
                        return $q.reject('message invalid.')
                    }      

                    if($scope.isSending) {
                        return $q.reject('message upload already in progress.');
                    }

                    var new_message = $scope.conversation.messages
                    .create({
                        conversation:$scope.conversation,
                        id:'#new_message',
                        fromIdentity:cmUserModel.data.identity
                    })
                    .setText($scope.newMessageText);

                    new_message.state.set('sending');

                    /**
                     * important to set file view to dummy
                     */
                    if(cmAnswerFiles.files.length > 0){
                        new_message.state.set('waitForFiles');
                    }



                    return checkConversationSetup()
                    .then(function(){
                        return  $scope.conversation.getPassphrase()
                                .catch(function(){
                                        return  $scope.conversation.isEncrypted()
                                                ?   $q.reject('access denied')
                                                :   $q.when(null);
                                //Todo: null for 'not encrypted' old convention
                                })
                                .then(function(passphrase){
                                    return  $q.when()
                                            .then(function(){
                                                return prepareFiles(passphrase)
                                            })
                                            .then(function(){
                                                return $scope.conversation.sendMessage(new_message, filesForMessage);
                                            })

                                })
                    })
                    .then(
                        function(){
                            // tidy up:
                            clearTransferScopeData();
                            $scope.newMessageText = '';
                            filesForMessage = [];
                            cmAnswerFiles.reset();
                            $rootScope.$broadcast('cmAnswer:reset');

                            //Todo: This is not the right place to count messages:
                            $scope.conversation.numberOfMessages ++;
                        },
                        function(){
                            $scope.conversation.messages.deregister(new_message)
                        }
                    )
                    .finally(function(){
                        new_message.state.unset('sending');
                        new_message.state.unset('waitForFiles');
                        $scope.isSending = false;
                    });
                };

                $scope.showTrustError = function(){
                    //cmLogger.debug('cmConversationDRTV.showTrustError');

                    if(!$scope.conversation.state.is('new')
                        && $scope.conversation.getKeyTransmission() == 'asymmetric'
                        && $scope.conversation.userHasPrivateKey() == true
                        && !$scope.conversation.userHasAccess()){

                        cmModal.open('handshake-info');

                        return true;
                    }

                    return false;
                };

                $scope.showAsymmetricKeyError = function(){
//                    cmLogger.debug('cmConversationDRTV.showAsymmetricKeyError')

                    if(!$scope.conversation.state.is('new')
                        && $scope.conversation.getKeyTransmission() == 'asymmetric'
                        && $scope.conversation.userHasPrivateKey() == false
                    ){
                        cmNotify.warn('CONVERSATION.WARN.ASYMMETRIC_DECRYPT_ERROR',{ttl:0});
                        return true;
                    }
                    return false;
                };

                $scope.showGoToSettingsModal = function(){
                    if(
                            !$scope.conversation.state.is('new')
                        &&  $scope.conversation.passwordRequired()
                        &&  !$scope.conversation.password
                    ){
                        // switcher for purl and conversation
                        var settingsLinker = {type:'',typeId:''};
                        if('purlId' in $routeParams){
                            settingsLinker.type = 'purl';
                            settingsLinker.typeId = $routeParams.purlId;
                        } else {
                            settingsLinker.type = 'conversation';
                            settingsLinker.typeId = $routeParams.conversationId;
                        }
                        cmNotify.warn('CONVERSATION.WARN.PASSWORD_NEEDED',{ttl:0,i18n:settingsLinker});
                        return true
                    }

                    return false
                };

                this.addPendingRecipients = function(){
                    if($scope.conversation.state.is('new')){
                        $rootScope.pendingRecipients = $rootScope.pendingRecipients || [];
                        $rootScope.pendingRecipients.forEach(function(pendingRecipient){
                            $scope.conversation.addRecipient(pendingRecipient);
                        });
                        $rootScope.pendingRecipients = []
                    }
                };

                function init(conversation){
                    $scope.conversation = conversation;
                    $rootScope.pendingConversation = $scope.conversation;

                    // reload details of conversation
                    $scope.conversation.update(undefined, true);

                    self.addPendingRecipients();

                    $scope.show_contacts  = false;

                    /** Event callbacks **/
                    function callback_update_finished(){
                        $scope.showTrustError();
                        $scope.showAsymmetricKeyError();
                        $scope.showGoToSettingsModal();
                    }

                    function callback_password_missing(){
                        // switcher for purl and conversation
                        var settingsLinker = {type:'',typeId:''};
                        if('purlId' in $routeParams){
                            settingsLinker.type = 'purl';
                            settingsLinker.typeId = $routeParams.purlId;
                        } else {
                            settingsLinker.type = 'conversation';
                            settingsLinker.typeId = $routeParams.conversationId;
                        }
                        cmNotify.warn('CONVERSATION.WARN.NO_PASSWORD', {ttl:0, i18n: settingsLinker});
                    }

                    function callback_recipients_missing(){
                        cmModal.confirm({
                            title:  'CONVERSATION.WARN.RECIPIENTS_MISSING',
                            text:   'CONVERSATION.CONFIRM.RECIPIENTS_MISSING'
                        })
                        .then(function(){
                            $scope.conversation.solitary = true;
                            $scope.send();
                        })
                    }

                    function callback_save_aborted(){
                        $scope.isSending = false;
                    }

                    $scope.conversation
                    .one('update:finished',      callback_update_finished)
                    .on('password:missing',      callback_password_missing)
                    .on('recipients:missing',    callback_recipients_missing)
                    .on('save:aborted',          callback_save_aborted)

                    var stop_listening_to_logout =  $rootScope.$on('logout', function(){
                            $rootScope.pendingRecipients = [];
                            $rootScope.pendingConversation = null;
                        });

                    var stop_listening_to_idenity_switch =  $rootScope.$on('identity:switched', function(){
                            $rootScope.pendingRecipients = [];
                            $rootScope.pendingConversation = null;
                        });

                    var stop_listening_to_send_on_return = $rootScope.$on('sendOnReturn',$scope.send);

                    $scope.$on('$destroy', function(){
                        $scope.conversation.off('update:finished',       callback_update_finished);
                        $scope.conversation.off('password:missing',      callback_password_missing);
                        $scope.conversation.off('recipients:missing',    callback_recipients_missing);
                        $scope.conversation.off('save:aborted',          callback_save_aborted);

                        stop_listening_to_logout();
                        stop_listening_to_idenity_switch();
                        stop_listening_to_send_on_return();
                    });
                }

                // transfer data between routeChanges
                var clearTransferScopeData = cmTransferScopeData.create($scope,{
                    id:'conversation-'+($scope.conversation.id||'new'),
                    scopeVar:'newMessageText',
                    onSet: function(){
                        this.noneScopeData = cmAnswerFiles.getFilesForTransfer();
                    },
                    onGet: function(formData, noneScopeData){
                        if(noneScopeData != null)
                            cmAnswerFiles.setFiles(noneScopeData);
                    }
                });

                init($scope.conversation);
            }
        }
    }
])
.directive('cmLastMessage', [
    '$rootScope',
    function($rootScope){
        return {
            restrict: 'A',
            scope: true,
            controller: function($scope){
                function encryptedCallback(){
                    $rootScope.$emit('scroll:to');
                }

                if($scope.$last){
                    if($scope.message.state.is('sending')){
                        $rootScope.$emit('scroll:to');
                    }

                    $scope.message.trigger('last-message:read', $scope.message);


                    $scope.message.on('decrypt:success',encryptedCallback);

                    $scope.$on('$destroy',function(){
                        $scope.message.off('decrypt:success',encryptedCallback);
                    });
                }
            }
        }
    }
])
.directive('cmLockLevel',[
    function cmSafetyLevel(){
        return {
            restrict: 'AE',
            template: '',

            link: function(scope, element, attrs){

                function drawLevel(x){
                    // clear all
                    element.children().remove();
                    // draw x
                    if(x == 0) {
                        element.append('<i class="fa cm-unlock"></i>');
                    } else {
                        for (var i = 0; i < x; i++) {
                            element.append('<i class="fa cm-lock"></i>');
                        }
                    }
                }

                // for conversation model
                if(attrs.cmLevel) {
                    scope.$watch(attrs.cmLevel, function (level) {
                        drawLevel(level)
                    })
                }
            }
        }
    }
])
.directive('cmMessageAssets', [
    'cmSettings',
    function (cmSettings) {
        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'comps/conversations/drtv-message-assets.html',
            controller: function($scope){
                $scope.settings = cmSettings;
            }
        }
    }
])

    .directive('cmMessageFile', [
    'cmModal', 'cmUtil', 'cmFullscreen',
    function (cmModal, cmUtil, cmFullscreen) {
        return {
            restrict: 'E',
            require: '^cmMessage',
            templateUrl: 'comps/conversations/drtv-message-file.html',
            controller: function ($scope, $element) {
                $scope.cmUtil = cmUtil;
                $scope.progress = 0;

                // exists fileModel
                if(typeof $scope.file == 'object'){
                    $scope.file.on('progress:chunk', function(e, progress){
                        $scope.progress = progress;
                    });
                }
            }
        }
    }
])
/**
* @ngdoc directive
* @name cmConversations.directive:cmMessage
* @description
* handle all types of message
* text
* image
* video
* audio
* documents
*
* @restrict AE
*
* @example
 <example module="cmDemo">
     <file name="script.js">
         angular
         .module('cmDemo', ['cmUi'])
         .controller('Ctrl', function ($scope){
                $scope.conversation = {
                    getPassphrase: function(){
                        return $q.when('123123123123123123')
                    }
                };

                function decryptFiles(){

                }

                function isEncrypted(){
                    return false;
                }

                function state(state){
                    return {
                        is: function (_state_) {
                            return state == _state_;
                        }
                    }
                }

                function on(state){
                    var progress = 0;
                    return function(eventName, callback) {
                        if (eventName == 'progress:chunk' && state == 'progress') {
                            $interval(function(){

                                 if(progress>1)
                                    progress=0
                                 else
                                    progress+=0.1

                                 callback({},progress);

                            },1000)
                        }
                    }

                }
                function trigger(){}
                function isEmbed(type){
                    return function(_type_){
                        if(!type && !_type_)
                            return false;

                        return type == _type_ || !_type_ && this.type.indexOf(type) >= 0;
                    };
                }

                function createFile(config){
                    return {
                        id: config.id || 1,
                        on: on(config.on),
                        trigger: trigger,
                        state: state(config.state || ''),
                        isEmbed: isEmbed(config.type || ''),
                        name: config.name || 'Dark_Machine.jpg',
                        type: config.mimeType || 'image/jpeg',
                        detectedExtension: config.extension || 'jpg',
                        size: config.size || 1024,
                        loaded: false,
                        url: {
                            src: config.src || 'http://s10.postimg.org/exo8yf6eh/Dark_Machine.jpg'
                        }
                    }
                }

                $scope.messages = [
                    {
                        from: {
                            state: state,
                            avatarId: 'eQhldI981mHiZdOyPD2z',
                            getDisplayName:function(){return 'Author'},
                            on: on(),
                            trigger: trigger
                        },
                        id: 1,
                        text: '',
                        textOnly: false,
                        fileIds: [1],
                        files:[createFile({id:1,type:'image',state:'readyForDownload'})],
                        state: state(''),
                        on: on(),
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 3,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:2,size:(1024*1024)*340,type:'audio',state:'onDownload',name:'AlbumArt_{5FA05D35-A682-4AF6-96F7-0773E42D4D16-123231-312312345234534-dasd asda sdasd asd-asd}_Small.mp3',extension:'mp3',on:'progress'})],
                        state: state(''),
                        on: on(),
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 3,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:2,type:'image',state:'cached',src:' '})],
                        state: state(''),
                        on: on(),
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'image',state:'cached'})],
                        state: state(''),
                        on: on(),
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'image',state:'cached',src:'http://www.egghof.com/NewYork/Bilder/Freiheit.jpg'})],
                        state: state(''),
                        on: on,
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'image',state:'cached',src:'http://i.imgur.com/HuTSmQ0.png'})],
                        state: state(''),
                        on: on,
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'image',state:'cached',src:'blob:http%3A//localhost%3A8000/0515c053-7ef1-40ac-8da0-26ad801a5fcf'})],
                        state: state(''),
                        on: on,
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'video',state:'cached',src:'http://stream.flowplayer.org/bauhaus.mp4',extension:'mp4'})],
                        state: state(''),
                        on: on,
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'audio',state:'cached',src:'http://thesixteendigital.com.s3.amazonaws.com/testfiles/Hallelujah.mp3',extension:'mp3',name:'supergeil.mp3'})],
                        state: state(''),
                        on: on,
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    },
                    {
                        id: 2,
                        text: '',
                        textOnly: false,
                        fileIds: [2],
                        files:[createFile({id:3,type:'',state:'cached',src:'23wefrwer.pdf',name:'AlbumArt_{5FA05D35-A682-4AF6-96F7-0773E42D4D16-123231-312312345234534-dasd asda sdasd asd-asd}_Small.pdf',extension:'pdf'})],
                        state: state(''),
                        on: on,
                        trigger: trigger,
                        isOwn:function(){return true},
                        isEncrypted: isEncrypted,
                        decryptFiles: decryptFiles
                    }
                ];
         });
     </file>
     <file name="index.html">
         <cm-message ng-repeat="message in messages" cm-data="message" cm-data-conversation="conversation"></cm-message>
     </file>
 </example>
*/

.directive('cmMessage', [
    function () {
        return {
            restrict: 'AE',
            scope: {
                message: '=cmData',
                conversation: '=cmDataConversation'
            },
            templateUrl: 'comps/conversations/drtv-message.html',

            link: function(scope, element){

                function setFileView(){
                    element.addClass('file-view');
                }

                if(!scope.textOnly) {
                    // add css classes
                    if (scope.message.files.length > 0) {
                        setFileView();
                    }
                    if (scope.message.isOwn()) {
                        element.addClass('right');
                    }
                }

                function handleFiles(){
                    if(scope.message.id == '#new_message' && scope.message.state.is('waitForFiles')){
                        setFileView();
                    }

                    if (!scope.textOnly && scope.message.files.length > 0) {
                        setFileView();

                        scope.conversation.getPassphrase()
                        .then(
                            function(passphrase){
                                scope.message.decryptFiles(passphrase);
                            },
                            function(passphrase){
                                if(!scope.message.isEncrypted())
                                    scope.message.decryptFiles(null)
                            }
                        )
                    }
                }


                if(typeof scope.message == 'object' && typeof scope.message.on == 'function'){
                    //Todo: this should be 'one' not 'on', shouldn't it? Andreas

                    scope.message.on('init:files', function(){
                        handleFiles();
                    });
                }

                handleFiles();

            },

            controller: function ($scope, $element, $attrs) {
                $scope.textOnly = !!$scope.$eval($attrs.textOnly);

                $scope.is_my_own_message = ('isOwn' in $scope.message) ? $scope.message.isOwn() : false;

                $scope.isType = function(expectType){
                    if(typeof $scope.message.files !== 'undefined' && $scope.message.files.length > 0 && typeof $scope.message.files[0].type == 'string'){
                        var mimeType = $scope.message.files[0].type;
                        if(expectType == 'image' && mimeType.search('^image') != -1){
                            return true;
                        } else if(expectType == 'file' && mimeType.search('^image') == -1){
                            return true;
                        }
                    } else if(expectType == 'text')
                        return true;
                };

                $scope.displayEncrypted = function(){
                    if($scope.message.id == undefined){
                        /**
                         * hack for empty messages
                         */                        
                        return false;
                    }

                    if(
                            $scope.message.text != undefined 
                        ||  (
                                    $scope.message.text == undefined 
                                &&  typeof $scope.message.files !== 'undefined' 
                                &&  $scope.message.files.length > 0
                            )
                    ){
                        return false;
                    }
                    return true;
                };
                
                $scope.messageProper = function(){
                    var isInComplete    =   $scope.message.state.is('incomplete'),

                        textAvailable   =       typeof $scope.message.text == 'string'
                                            &&  $scope.message.text.length > 0,

                        encrypted       =       $scope.message.isEncrypted(),

                        filesAvailable  =       typeof $scope.message.fileIds == 'object'
                                            &&  $scope.message.fileIds.length > 0,

                        isSending       =   $scope.message.state.is('sending')

                    if(isInComplete)
                        return false;

                    return filesAvailable || textAvailable || encrypted || isSending;
                }
            }
        }
    }
])
.directive('cmPasswordInput',[
    function () {
        return {
            restrict: 		'A',
            scope:			false,

            link:			function(scope, element, attrs, ngModelCtrl){

                var status = angular.element('<i></i>').addClass('fa'),
                    timeout

                element.after(status)

                scope.refresh= function(){
                    element.val()
                        ?	status.addClass('fa-lock').removeClass('fa-unlock')
                        :	status.addClass('fa-unlock').removeClass('fa-lock')
                }

                scope.refresh()
                scope.$watch('passphrase', scope.refresh)
            }

        }
    }
])
.directive('cmRecipientCounter',[
    function(){
        return {
            restrict : 'AE',
            transclude: true,
            template : '<i class="fa cm-group background"></i><div class="foreground" ng-transclude></div>'
        }
    }
])
.directive('cmRecipientTag',[
    'cmContactsModel',
    '$rootScope',
    function (cmContactsModel,$rootScope){
        return {
            restrict: 'AE',
            scope: {
                identity: "=cmData"
            },
            templateUrl: 'comps/conversations/drtv-recipient-tag.html'
        }
    }
])
.directive('cmRecipientsCommaSeperated', [
    'cmUserModel',
    function(cmUserModel){
        return {
            restrict: 'E',
            scope: {
                conversation: '=cmData'
            },
            template: '<span class="is-selectable">{{entries}}</span>',
            controller: function($scope){
                $scope.entries = '';

                function refresh(){
                    if($scope.conversation.recipients.length > 2){
                        /**
                         * Groups
                         */
                        $scope.entries = $scope.conversation.recipients.filter(function(recipient){
                            return (recipient.id != cmUserModel.data.identity.id);
                        }).map(function(recipient){
                            return recipient.getDisplayName();
                        }).join(', ');
                    } else if($scope.conversation.recipients.length == 2){
                        /**
                         * Chat
                         */
                        $scope.entries =  $scope.conversation.recipients.filter(function(recipient){
                            return (recipient.id != cmUserModel.data.identity.id);
                        })[0].getDisplayName();
                    } else {
                        /**
                         * Own
                         */
                        $scope.entries = cmUserModel.data.identity.getDisplayName();
                    }
                }

                refresh();

                $scope.conversation.recipients.on('register deregister update:finished', refresh);
            }
        }
    }
])
.directive('cmRecipients', [
    '$rootScope',
    '$location',
    '$window',
    'cmContactsModel',
    function($rootScope, $location, $window, cmContactsModel){
        return {
            restrict: 'E',
            templateUrl: 'comps/conversations/drtv-recipients.html',
            controller: function ($scope, $element, $attrs) {
                $scope.selected         = {};
                $scope.contacts         = cmContactsModel.contacts;

                function init(conversation){
                    $scope.conversation = conversation;
                    $scope.$watchCollection('conversation.recipients', function(recipients){
                        $scope.selected = {};
                        recipients.forEach(function(recipient){
                            $scope.selected[recipient.id] = true;
                        })
                    })
                }

                $scope.addRecipient = function(identity){
                    $scope.selected[identity.id] = true;
                    $scope.conversation.addRecipient(identity);
                };

                $scope.removeRecipient = function(identity){
                    delete $scope.selected[identity.id];
                    $scope.conversation.removeRecipient(identity);
                };

                $scope.toggleRecipient = function(identity){
                    if(!$scope.conversation.state.is('new'))
                        return false;

                    $scope.selected[identity.id]
                        ?   $scope.removeRecipient(identity)
                        :   $scope.addRecipient(identity);
                };

                $scope.goToContactWithIdentity  = function(identity){
                    var contact = cmContactsModel.findByIdentity(identity);
                    if(typeof contact == 'object'){
                        $rootScope.gotoContact(contact);
                    }
                };

                $scope.goBack = function(){
                    //goto('conversation/'+(conversation.id||'new'))
                    $window.history.back();
                };

                $scope.$watch($attrs.cmData, function(conversation){
                    if(conversation)
                        init(conversation);
                });

            }
        }
    }
])
.directive('cmSearchConversations',[
    'cmConversationFactory',
    'cmFilter',
    'cmLoader',
    '$timeout',
    '$document',
    function (cmConversationFactory, cmFilter, cmLoader, $timeout, $document){
        return {
            restrict: 'E',
            template: '<button class="cm-btn-grey" data-qa="btn-search-archive" ng-click="searchArchive()" cm-reactive><span ng-show="!showLoader"><span class="enabledText">{{::"TALKS.SEARCH.BUTTON.SERVER_SEARCH_ACTIVE"|cmTranslate}}</span><span class="disabledText cm-hide">{{::"TALKS.SEARCH.BUTTON.SERVER_SEARCH_INACTIVE"|cmTranslate}}</span><i class="fa cm-search"></i></span><cm-loader cm-color="ci-color" ng-show="showLoader"></cm-loader></button>',
            link: function(scope, element){

                function toggleButtonText(){
                    if(scope.isDisabled){
                        angular.element($document[0].querySelector('span.disabledText')).removeClass('cm-hide')
                        angular.element($document[0].querySelector('span.enabledText')).addClass('cm-hide')
                    } else {
                        angular.element($document[0].querySelector('span.enabledText')).removeClass('cm-hide')
                        angular.element($document[0].querySelector('span.disabledText')).addClass('cm-hide')
                    }
                }

                scope.setDefault = function(){
                    scope.isDisabled = false;
                    element.removeClass('cm-disabled');
                    toggleButtonText()
                };

                scope.updateElement = function(){
                    if(scope.matches.loaded == scope.matches.qty){
                        scope.isDisabled = true;
                        element.addClass('cm-disabled');
                        toggleButtonText()

                    } else {
                        scope.setDefault();
                    }
                };

                scope.setDefault();
            },
            controller: function($scope){
                var loader = new cmLoader($scope),
                    isLoading = false,
                    limit = 10;

                $scope.timeout = null;

                $scope.matches = {
                    loaded: 0,
                    qty: 0
                };

                $scope.searchArchive = function(){
                    var s = cmFilter.get();

                    if(typeof s == 'string' && s != '' && s.length >= 3 && !isLoading && !$scope.isDisabled){
                        isLoading = true;
                        loader.start();

                        if($scope.timeout != null) $timeout.cancel($scope.timeout);

                        $scope.timeout = $timeout(function(){
                            cmConversationFactory.search(s, limit, $scope.matches.loaded).then(
                                function(data){
                                    if(typeof data.conversations != 'undefined'){
                                        $scope.matches.loaded = $scope.matches.loaded + data.conversations.length;
                                    }

                                    if(typeof data.numberOfMatches == 'number'){
                                        $scope.matches.qty = data.numberOfMatches;
                                    }
                                },
                                function(result){
                                    //console.log('error', result)
                                }
                            ).finally(
                                function(){
                                    loader.stop();
                                    isLoading = false;
                                    $scope.updateElement();
                                }
                            )
                        },500);
                    }
                };

                function clear(){
                    $scope.matches = {
                        loaded: 0,
                        qty: 0
                    };

                    $scope.setDefault();
                }

                cmFilter.onUpdate('wdgt-talks', clear);
                cmFilter.onClear('wdgt-talks', clear);

                $scope.$on('$destroy',function(){
                    clear();
                    cmFilter.removeOnUpdate('wdgt-talks');
                    cmFilter.removeOnClear('wdgt-talks');
                });

            }
        }
    }
])
.directive('cmSecuritySettings', [

    'cmUserModel',
    'cmNotify',
    'cmLogger',
    '$location',
    '$document',
    '$window',
    'cmEnv',
    '$rootScope',

    function(cmUserModel, cmNotify, cmLogger, $location, $document, $window, cmEnv, $rootScope){
        return{
            restrict : 'AE',
            templateUrl : 'comps/conversations/drtv-security-settings.html',
            scope : true,

            link: function(scope){
                scope.showPasswordLocalKeyInfo = false;

                function showPasswordInfo(conversation){
                    if(conversation.isEncrypted() && !conversation.userHasPrivateKey()){
                        scope.showPasswordLocalKeyInfo = true;
                    } else {
                        scope.showPasswordLocalKeyInfo = false;
                    }
                }

                /**
                 * watch the conversation object on changes
                 */
                scope.$watch('conversation', function(conversation){
                    if(conversation){
                        // open the controls for a new conversation and password isnt set in a symetric case || case mixed exists and user isnt in passphraselist
                        showPasswordInfo(conversation);

                        conversation.on('encryption:enabled', function(){
                            showPasswordInfo(conversation);
                        });

                        conversation.on('encryption:disabled', function(){
                            showPasswordInfo(conversation);
                        });
                    }
                });

                // scope.$watch('conversation.password', function(){
                //     if(scope.conversation.state.is('new'))
                //         scope.conversation.securityAspects.refresh()
                // })
            },

            controller: function($scope, $element, $attrs){
                $scope.conversation = $scope.$eval($attrs.cmData)

                $scope.goBack = function(){
                    //goto('conversation/'+(conversation.id||'new'))
                    $window.history.back();
                };

                /**
                 * @name decrypt
                 * @description
                 * try to decrypt the conversation
                 */
                $scope.decrypt = function(){
                    if(     !$scope.conversation.state.is('new')
                        &&  $scope.conversation.isEncrypted()
                        &&  !($scope.conversation.getKeyTransmission() == 'asymmetric' && $scope.conversation.userHasPrivateKey() == false)
                    ) {
                        $scope.conversation.one('decrypt:failed', function () {
                            cmNotify.warn('CONVERSATION.WARN.PASSWORD_WRONG');
                            //$scope.toggleControls('open');
                            //TODO go to settings page??
                        });
                        $scope.conversation.decrypt();
                    }
                };

                /**
                 * @name toggleConversationEncryption
                 * @description
                 * enable or disable encryption for a conversation
                 */
                $scope.toggleConversationEncryption = function(){
                    if($scope.conversation.state.is('new')){
                        if($scope.conversation.isEncrypted() !== false){
                            $scope.conversation.disableEncryption();
                        } else {
                            $scope.conversation.enableEncryption();
                        }
                    }
                };

                /**
                 * @name toggleCaptcha
                 * @description
                 * enable or disable passcaptcha creation
                 */
                $scope.toggleCaptcha = function(){
                    if($scope.conversation.state.is('new') && $scope.conversation.isEncrypted() !== false){
                        if($scope.conversation.options.hasCaptcha !== false){
                            $scope.conversation.disablePassCaptcha();
                        } else {
                            $scope.conversation.enablePassCaptcha();
                        }
                    }
                };

                /**
                 * @name refreshCaptcha
                 * @description
                 * redraw a new passcaptcha
                 */
                $scope.refreshCaptcha = function(){
                    $scope.$broadcast('captcha:refresh');
                };

                $scope.scrollToPasswordArea = function(){
                    // scroll to password
                    var anchor = $document[0].querySelector('#password-area'),
                        body = angular.element($document[0].querySelector($element[0].localName+' .body'));
                        body[0].scrollTop = anchor.offsetTop;
                }
            }
        }
    }
])
.factory('cmConversationContextModel', [
    'cmStateManagement', 'cmObject', 'cmLogger',
    'cmUserModel', 'cmConversationFactory', 'cmConversationModel',
    '$rootScope', '$q',
    function(cmStateManagement, cmObject, cmLogger,
             cmUserModel, cmConversationFactory, cmConversationModel,
             $rootScope, $q) {

        function cmConversationContextModel(data){
            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state = new cmStateManagement();

            this.id = undefined;
            this.model = undefined;

            function init(model){
                //cmLogger.debug('cmConversationContextModel init');

                // check instance of model, if wrong trigger deregister
                self.importData(model);
            }

            this.importData = function(model){
                //cmLogger.debug('cmConversationContextModel.importData');

                this.model  = model || this.model;
                this.id = this.model.id;
            };

            this.delete = function(){
                //cmLogger.debug('cmConversationContextModel.processDelete');

                return (function(){
                        if(self.model.recipients.length > 1){
                            var message = self.model.messages.create({
                                conversation: self.model,
                                id: '#new_message',
                                fromIdentity: cmUserModel.data.identity,
                                text: '$${SYSTEM.CONVERSATION.DELETE}'
                            });

                            return self.model.sendMessage(message, null, true);
                        } else {
                            return $q.when();
                        }
                    }())
                    .then(function(){
                        return cmConversationFactory.deleteConversation(self.model);
                    })
            };

            init(data);
        }

        return cmConversationContextModel;
    }
])

.factory('cmSecurityAspectsConversation',[

    'cmSecurityAspects',
    'cmUserModel',
    'cmIdentityFactory',
    '$q',

    function(cmSecurityAspects, cmUserModel, cmIdentityFactory, $q){
//        var securityAspectsConversation = new cmSecurityAspects()

        function securityAspectsConversation(conversation){
            var self                = new cmSecurityAspects( {languagePrefix: 'SECURITY_ASPECT.CONVERSATION'} )

            self
            .setTarget(conversation)

            self
                .addAspect({
                    id: 'NOT_ENCRYPTED',
                    value: -3,
                    check: function(conversation){
                        return !conversation.isEncrypted();
                    },
                    toggleCheck: function(conversation){
                        return !conversation.isEncrypted();
                    },
                    toggleCall: function(conversation){
                        conversation.enableEncryption();
                    }
                })
                .addAspect({
                    id: 'ENCRYPTED',
                    value: 1,
                    check: function(conversation){
                        return conversation.isEncrypted();
                    }
                })    
                .addAspect({
                    id: 'KEY_TRANSMISSION_SYMMETRIC',
                    dependencies: ['ENCRYPTED'],
                    value: -1,
                    template:       '<div ng-if="isNew">{{aspect.description+"_NEW"|cmTranslate}}</div>'
                                +   '<div ng-if="!isNew">{{aspect.description|cmTranslate}}</div>'
                                +   '{{aspect.description+"_BAD_RECIPIENTS"|cmTranslate}}<div ng-if = "aspect.numberOfBadRecipients > 0">{{aspect.badRecipients.join(", ")}}</div>'
                                +   '<div ng-if = "aspect.privateKeyMissing">{{aspect.description+"_PRIVATE_KEY_MISSING"|cmTranslate}}</div>',
                    check: function(conversation){

                        this.badRecipients          = conversation.getBadRecipients().map(function(recipient){
                                                            return recipient.getDisplayName()
                                                        })
                        this.numberOfBadRecipients  = this.badRecipients.length
                        this.privateKeyMissing      = !conversation.userHasPrivateKey()

                        this.isNew                  = conversation.state.is('new')

                        /**
                         * @TODO
                         * BS mit Andreas absprechen
                         * passwordRequired hat unterschiedleiche Bedeutungen??!
                         */
//                        if(conversation.state.is('new')){
//                            return conversation.passwordRequired()
//                        } else {
//                            return conversation.hasPassword();
//                        }
                        return ['symmetric', 'mixed'].indexOf(conversation.getKeyTransmission()) != -1;
                    }
                })
                .addAspect({
                    id: 'HAS_PASSCAPTCHA',
                    dependencies: ['KEY_TRANSMISSION_SYMMETRIC'],
                    value: -1,
                    check: function(conversation){
                        return conversation.options.hasCaptcha;
                    },
                    toggleCheck: function(conversation){
                        return conversation.options.hasCaptcha
                    },
                    toggleCall: function(conversation){
                        conversation.disablePassCaptcha();
                    }
                }) 
                .addAspect({                    
                    id: 'NO_SYMMETRIC_KEY_TRANSMISSION',
                    dependencies: ['ENCRYPTED'],
                    value: 1,
                    check: function(conversation){
                        return ['symmetric', 'mixed'].indexOf(conversation.getKeyTransmission()) == -1
                    }
                })
                .addAspect({
                    id: 'AUTHENTIC_RECIPIENTS',
                    dependencies: ['ENCRYPTED', 'NO_SYMMETRIC_KEY_TRANSMISSION'],
                    value: 1,
                    check: function(){
                        return  conversation.state.is('new')
                                &&
                                conversation.recipients.reduce(function(so_far, recipient){
                                    return  so_far
                                            .then(function(){
                                                return  cmUserModel.verifyIdentityKeys(recipient, true)
                                            })
                                            .then(function(ttrusted_keys){
                                                return  ttrusted_keys.length == recipient.keys.length
                                                        ?   $q.when(true)
                                                        :   $q.reject()
                                            })
                                }, $q.when())
                                .then(
                                    function(){ return true },
                                    function(){ return false }
                                )
                    }
                })
                .addAspect({
                    id: 'AUTHENTIC_RECIPIENT_LIST',
                    dependencies: ['ENCRYPTED', 'NO_SYMMETRIC_KEY_TRANSMISSION'],
                    value: 1,
                    template:    '<div>{{aspect.description|cmTranslate}}</div><br/>'
                                +'<div ng-repeat ="recipient in aspect.recipients">{{recipient.displayName}} ({{recipient.cameoId}})</div>',
                    check: function(conversation){
                        var self = this
                        
                        return  !conversation.state.is('new')
                                &&
                                conversation.verifyAuthenticity()
                                .then(function(recipientKeyList){
                                    self.recipients =   recipientKeyList.map(function(item){
                                                            return cmIdentityFactory.find(item.identityId)
                                                        })
                                    return  recipientKeyList.reduce(function(so_far, item){
                                                return  so_far
                                                        .then(function(reason){
                                                            var identity = cmIdentityFactory.create(item.identityId)
                                                            return  cmUserModel.verifyIdentityKeys(identity, false, true)                                                                         
                                                        })                                                            
                                                        .then(function(ttrusted_keys){
                                                            return  item.keys.every(function(key){ 
                                                                        return ttrusted_keys.some(function(tt_key){
                                                                            return tt_key.id == key.id
                                                                        })
                                                                    })
                                                                    ?   $q.when(true)
                                                                    :   $q.reject('unauthentic key in recipient key list')
                                                        })   
                                            }, $q.when(false))
                                })
                                .then(
                                    function(){ return true },
                                    function(){ return false }
                                )

                        //temporary solution, AP
                        return  conversation.recipients.length < 3
                            ?   conversation.recipients.reduce(function(so_far, recipient){
                                    return  so_far
                                            .then(function(){
                                                return  cmUserModel.verifyIdentityKeys(recipient, true)
                                            })
                                            .then(function(ttrusted_keys){
                                                return  ttrusted_keys.length == recipient.keys.length
                                                        ?   $q.when(true)
                                                        :   $q.reject()
                                            })

                                }, $q.when())
                                .then(
                                    function(){ return true },
                                    function(){ return false }
                                )
                            :   $q.when(false)
                    }
                });

            

            conversation.on('update:finished encryption:enabled encryption:disabled captcha:enabled captcha:disabled aspects:added decrypt:success', self.scheduleRefresh);
            conversation.recipients.on('register update:finished deregister', self.scheduleRefresh);
            cmUserModel.on('key:stored key:removed cache:updated', self.scheduleRefresh);


            return self;
        }

        return securityAspectsConversation 
    }
])

.filter('cmHideAppOwner', [
    function(){
        return function(arrayOfIdentities) {
            return arrayOfIdentities.filter(function(identity){
                return !('isAppOwner' in identity)
            })
        }
    }
])

.filter('cmLatestMessage', [
    function(){
        return function(conversation){
            return conversation.messages.reduce(function(latest_so_far, message){
                return  parseInt( (message && message.created) || 0) >= parseInt( (latest_so_far && latest_so_far.created) || 0)
                        ?   message
                        :   latest_so_far
            }, null)
        }
    }
])

.filter('cmTagline', [
    '$filter',
    function($filter){
        return function(conversation) {
            var subject;

            if (conversation.subject) {
                subject = conversation.subject
            } else if (conversation.lastMessage && conversation.lastMessage.from && conversation.lastMessage.from.displayName) {
                subject = conversation.lastMessage.from.getDisplayName();
            } else {
                // TODO: show own user in subject???
                subject = (conversation.recipients.map(function (recipient) {
                    return recipient.getDisplayName();
                }).join(', '));
            }

            subject = $filter('cmParse')(subject);

            return subject;
        }
    }
])

.directive('cmConversationMenu', [
    'cmUserModel', 'cmConversationFactory', 'cmModal', 'cmNotify', 'cmUtil',
    '$window', '$rootScope', '$q',
    function (cmUserModel, cmConversationFactory, cmModal, cmNotify, cmUtil,
              $window, $rootScope, $q) {
        return {
            restrict: 'E',
            templateUrl: 'comps/conversations/menu/drtv-conversation-menu.html',
            scope: {
                conversation: '=cmData'
            },

            link: function(scope, element){
                function clickOutside(e){
                    if(e.target != element[0] &&
                        !cmUtil.findParent('cmConversationMenu',e.target)
                    ) {
                        scope.$apply(function(){
                            scope.handleMenu('close');
                        })
                    }
                }

                angular.element($window).on('click',clickOutside);

                scope.$on('$destroy', function(){
                    angular.element($window).off('click',clickOutside);
                });
            },

            controller: function ($scope, $element, $attrs) {
                $scope.goto = $rootScope.goto;

                $scope.menuVisible = false;

                $scope.handleMenu = function(forceClose){
                    $scope.menuVisible = !forceClose && $scope.menuVisible || forceClose ? false : true;
                };

                $scope.delete = function(){
                    cmModal.confirm({
                        title:  'CONVERSATION.MODAL.DELETE.HEADER',
                        text:   'CONVERSATION.MODAL.DELETE.TEXT'
                    })
                    .then(function() {

                        if($scope.conversation.recipients.length > 1){
                            var message = $scope.conversation.messages.create({
                                conversation:$scope.conversation,
                                id:'#new_message',
                                fromIdentity: cmUserModel.data.identity,
                                text:'$${SYSTEM.CONVERSATION.DELETE}'
                            });

                            return $scope.conversation.sendMessage(message, null, true);
                        } else {
                            return $q.when();
                        }
                    })
                    .then(function(){
                        return cmConversationFactory.deleteConversation($scope.conversation);
                    })
                    .then(function(){
                        $rootScope.goTo('/talks');
                    })
                    .catch(function(){
                        cmNotify.warn('SYSTEM.ERROR.MESSAGE');
                    })
                }
            }
        }
    }
])

    .directive('cmModalHandshakeInfo',[
        '$rootScope',
        function ($rootScope){
            return {
                restrict: 'E',
                templateUrl: 'comps/conversations/modal/drtv-handshake-info.html',
                scope: {
                    modalId: "@id",
                    nosePosition: "@nosePosition"
                },
                controller: function($scope){
                    $scope.goTo = $rootScope.goTo;
                }
            }
        }
    ])
/**
 * @ngdoc object
 * @name cmConversationFactory
 * @description
 * Handles Conversation Instances<br />
 * create new instances and check if instances still exists
 *
 * @requires cmConversationsAdapter
 * @requires cmFactory
 * @requires cmStateManagement
 * @requires cmConversationModel
 * @requires $rootScope
 *
 */
.service('cmConversationFactory', [

    '$rootScope',
    'cmUserModel',
    'cmConversationsAdapter',
    'cmFactory',
    'cmStateManagement',
    'cmConversationModel',
    'cmLogger',
    '$q',

    function($rootScope, cmUserModel, cmConversationsAdapter, cmFactory, cmStateManagement, cmConversationModel, cmLogger, $q) {
        var self = cmFactory(cmConversationModel);

        var _quantity   = 0,
            _limit      = 10,
            _offset     = 0;

        self.state = new cmStateManagement(['loading']);

        self.getList = function(limit, offset){
//            cmLogger.debug('cmConversationFactory.getList');
            if(cmUserModel.isGuest() || self.state.is('loading'))
                return false;

            // for spinner show only once
            if(!self.state.is('first-load')) {
                self.state.set('first-load');
                self.state.set('initial-loading');
            }
            self.state.set('loading');

            if(typeof limit === 'undefined'){
                limit = _limit;
            }

            if(typeof offset === 'undefined'){
                offset = _offset;
            }

            cmConversationsAdapter.getConversations(limit, offset).then(
                function (data) {
                    _quantity = data.numberOfConversations;

                    data.conversations.forEach(function (conversation_data) {
                        self.create(conversation_data);
                    });
                }
            ).finally(
                function(){
                    self.state.unset('loading');
                    if(self.state.is('initial-loading')){
                        self.state.unset('initial-loading');
                    }
                }
            )
        };

        self.getLimit = function(){
            return _limit;
        };

        self.search = function(search, limit, offset){
            if(cmUserModel.isGuest() || self.state.is('loading'))
                return false;

            var deferred = $q.defer();

            self.state.set('loading');

            cmConversationsAdapter.searchConversations(search,limit, offset).then(
                function(data) {
                    /**
                     * @todo
                     * _quantity = data.numberOfConversations;
                     */

                    data.conversations.forEach(function (conversation_data) {
                        self.create(conversation_data);
                    });

                    deferred.resolve(data);
                },
                function(){
                    deferred.reject('search errror');
                }
            ).finally(
                function(){
                    self.state.unset('loading');
                }
            );

            return deferred.promise;
        };

        self.deleteConversation = function(conversation){
            var instance = self.find(conversation);

            if(instance instanceof cmConversationModel){
                return  cmConversationsAdapter
                        .deleteConversation(instance.id)
                        .then(
                            function(){
                                self.deregister(conversation);
                                return $q.when();
                            },
                            function(){
                                return $q.reject();
                            }
                        );
            } else {
                return $q.reject('conversation not found');
            }
        };

        /**
         * @ngdoc method
         * @methodOf cmConversationFactory
         *
         * @name getQuantity
         * @description
         * Returns Number of all Conversations
         * Quantity is first set in getList()
         *
         * @returns {Number} quantity Number of all Conversations
         */
        self.getQuantity = function(){
            return _quantity;
        };

        /**
         * EventHandling
         */
        $rootScope.$on('logout', function(){ self.reset('cmConversations') });

        $rootScope.$on('identity:switched', function(){
            cmUserModel.one('update:finished', function(){
                self.reset('cmConversations');
            })
        });

        $rootScope.$on('login', function(){
            cmUserModel.one('update:finished', function(){
                self.reset('cmConversations');
            })
        });

        cmUserModel.on('update:finished', function(){
            self.getList();
        });

        cmConversationsAdapter.on('message:new', function(event,data){
            var instance = self.find(data.conversationId);

            if(instance){
                self
                    .create(data.conversationId)
                    .trigger('message:new', data)
            }
        });

        cmConversationsAdapter.on('conversation:new', function(event,data){
            self.create(data)
        });

        cmConversationsAdapter.on('conversation:update', function(event, data){
            //cmLogger.debug('cmConversationFactory.on:conversation:update');
            var instance = self.create(data, true);

            if(instance){
                if(typeof data.recipients != 'undefined'){
                    data.recipients.forEach(function(recipient){
                        if(typeof recipient.deleted != 'undefined' && recipient.deleted == true && typeof recipient.identityId == 'string'){
                            instance.recipients.deregister(recipient.identityId)
                        }
                    });
                }
            }

        });

        cmConversationsAdapter.on('conversation:deleted', function(event, data){
            //cmLogger.debug('cmConversationFactory.on:conversation:deleted');
            var instance = self.find(data.id);

            if(instance){
                self.deregister(instance);
            }
        });

        /**
         * @TODO CallbackQueue? Fingerprint check! Performance!
         */
        cmConversationsAdapter.on('passphrases:updated', function(event, data){
            //cmLogger.debug('cmConversationFactory.on:passphrase:updated');

            if(typeof data == 'object') {
                if ('keyId' in data && typeof data.keyId == 'string' && data.keyId.length > 0) {
                    var localKeys = cmUserModel.loadLocalKeys();
                    var checkKeyId = false;

                    localKeys.forEach(function (key) {
                        if (key.id == data.keyId) {
                            checkKeyId = true;
                        }
                    });

                    if (checkKeyId) {
                        self.forEach(function (conversation) {
                            conversation.load();
                        });
                    }
                }
            }
        });

        cmConversationsAdapter.on('subscriptionId:changed', function(){
            self.forEach(function (conversation) {
                //conversation.update();
                conversation.loadLatestMessages();
            });
        });

        self.on('notFound', function(event, data){
            self.deregister(data);
        });

        return self;
    }
])
/**
 * @ngdoc object
 * @name cmConversationModel
 *
 * @description
 * Represents a Conversation.
 * # Events
 *  - init:finished
 *  - update:finished
 *  - load:failed
 *  - message:new
 *  - message:added
 *  - save:failed
 *  - save:finished
 * # States
 *  - new
 *  - loading
 *  - decrypted
 */


.factory('cmConversationModel',[

    'cmBoot',
    'cmConversationsAdapter',
    'cmMessageModel',
    'cmIdentityFactory',
    'cmIdentityModel',
    'cmFileFactory',
    'cmCrypt',
    'cmUserModel',
    'cmFactory',
    'cmStateManagement',
    'cmBrowserNotifications',
    'cmNotify',
    'cmObject',
    'cmLogger',
    'cmPassphraseVault',
    'cmSecurityAspectsConversation',
    'cmUtil',
    'cmFilesAdapter',
    'cmSettings',
    'cmKeyStorageService',
    '$q',
    '$rootScope',

    function (cmBoot, cmConversationsAdapter, cmMessageModel, cmIdentityFactory, cmIdentityModel, cmFileFactory,
              cmCrypt, cmUserModel, cmFactory, cmStateManagement, cmBrowserNotifications, cmNotify, cmObject, cmLogger, cmPassphraseVault,
              cmSecurityAspectsConversation, cmUtil, cmFilesAdapter, cmSettings, cmKeyStorageService,
              $q, $rootScope){

        function ConversationModel(data){
            var self                = this,
                passphraseVault     = undefined,
                encryption_disabled = undefined,
                limit               = 10,
                moep                = undefined;


            cmObject.addEventHandlingTo(self);

            this.id                 = undefined;

            this.recipients         = new cmFactory(cmIdentityModel);      //list of cmIdentityModel objects
            this.inactiveRecipients = [];
            this.messages           = new cmFactory(cmMessageModel);       //list of MessageModel objects

            this.timeOfCreation     = 0;          //timestamp of the conversation's creation
            //--> meta
            this.timeOfLastUpdate   = 0;          //timestamp of the conversations's last Update
            this.subject            = '';         //subject
            this.securityAspects    = new cmSecurityAspectsConversation(this);
            this.meta               = {};         //stores meta data, not yet implemented, TODO
            this.password           = undefined;
            this.state              = new cmStateManagement(['new','loading','decrypted','missingTrustedKeysChecked']);
            this.keyTransmission    = '';

            this.lastMessage        = this.messages.new(); //fallback

            this.missingAePassphrases = {};

            //rethink, mabye backend should deliver array of message ids
            this.numberOfMessages   = 0;
            this.unreadMessages     = 0;

            this.options            = {
                'hasCaptcha'    : false,
                'hasPassword'   : false,
                'showKeyInfo'   : false
            };

            /**
             * GUI Variable
             * @type {{level: string, class: string}}
             */

            this.lockStatus = {
                'level': 2,
                'class': 'safer'
            };

            /* maybe REFACTOR TODO */
            this.passCaptcha = undefined;
            this.tmpPassCaptcha = '';


            this.localPWHandler = new cmKeyStorageService('pw');

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name init
             * @description
             * Function to initialize the conversation. Should never be called from the outside.
             *
             * @param {Object} data The conversation data as required by .importData(), see below.
             */
            function init(data){
//                cmLogger.debug('cmConversationModel:init');

                // via id
                if(typeof data == 'string' && data.length > 0){
                    self.id = data;
                    self.load();
                    // via data.id
                } else if(typeof data == 'object' && ('id' in data)){
                    self.id = data.id;
                    if(cmUtil.objLen(data) < 2){
                        self.load();
                    } else {
                        self.importData(data);
                    }
                } else {
                    self.state.set('new');
                    self.enableEncryption(); // have to be there!!! BS klären mit AP 18.06.2014
                    self.addRecipient(cmUserModel.data.identity)
                }

                self.trigger('init:finished');
            }

            this.userHasPrivateKey = function(){
                return  cmUserModel.hasLocalKeys()
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name checkConsistency
             * @description
             * Checks Conversation Settings and User Opinions
             *
             * @param {Boolean} bool Return true or false
             *
             * @todo: what is todo??
             */
            this.checkConsistency = function (){
                if(this.passwordRequired() && !this.password){
                    self.trigger('password:missing');
                    return false
                }

                if((this.recipients.length == 1) && !this.solitary && this.state.is('new')){
                    self.trigger('recipients:missing')
                    return false
                }

                return true;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name importData
             * @description
             * Function to import data as received from the backend.
             *
             * @param {Object} data The conversation data as recieved from the backend.
             */
            this.importData = function(data){
                //cmLogger.debug('cmConversationModel:importData');

                if(typeof data !== 'object'){
                    cmLogger.debug('cmConversationModel:import:failed - no data!');
                    return this;
                }

                //There is no invalid data, importData looks for everything useable in data; if it finds nothing it wont update anything
                this.id                     = data.id                   || this.id;
                this.timeOfCreation         = data.created              || this.timeOfCreation;
                this.timeOfLastUpdate       = data.lastUpdated          || this.timeOfLastUpdate;
                this.subject                = data.subject              || this.subject;
                this.numberOfMessages       = data.numberOfMessages     || this.numberOfMessages;
                this.unreadMessages         = data.unreadMessages       || this.unreadMessages;
                // special if unreadMessages == 0
                if('unreadMessages' in data && typeof data.unreadMessages == 'number' && data.unreadMessages == 0){
                    this.unreadMessages = 0;
                }
                this.missingAePassphrases   = data.missingAePassphrases || this.missingAePassphrases;
                this.keyTransmission        = data.keyTransmission      || this.keyTransmission;

                //Create passphraseVault:
                if(data.sePassphrase || data.aePassphraseList){

                    var recipients = [];

                    if(typeof data.inactiveRecipients != 'undefined'){
                        recipients = data.recipients.concat(data.inactiveRecipients)
                    } else {
                        recipients = data.recipients;
                    }

                    passphraseVault =   cmPassphraseVault.create({
                        sePassphrase:       data.sePassphrase,
                        aePassphraseList:   data.aePassphraseList,
                        signatures:         data.conversationSignatures,
                        recipientKeyList:   recipients
                    })
                }

                /**
                 * Important for none encrypted Conversations
                 */
                if(!this.state.is('new') && this.keyTransmission == 'none')
                    self.disableEncryption();

                // getting locally saved pw for conversation
                if(this.password == undefined)
                    this.password = this.localPWHandler.get(this.id)

                this.initPassCaptcha(data);

                var messages = data.messages || [];
                messages.forEach(
                    function(message_data) {
                        message_data.conversation = self;
                        self.messages.create(message_data).decrypt();
                    }
                );

                var recipients = data.recipients || [];
                recipients.forEach(
                    function(recipient_data){
                        self.addRecipient(cmIdentityFactory.create(recipient_data.identityId));
                    }
                );

                this.inactiveRecipients = data.inactiveRecipients || this.inactiveRecipients;

                if(this.userHasPrivateKey() == false){
                    this.options.showKeyInfo = true;
                }

                /*
                 if(!this.state.is('new') && this.keyTransmission == 'mixed' && this.isUserInPassphraseList() == false){
                 this.options.hasPassword = true;
                 }
                 */

                this.state.unset('new');
                this.trigger('update:finished');

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name exportData
             * @description
             * Function to export conversation data for api call
             *
             * @param {Object} data Object with conversation data
             */
            this.exportData = function(){
                var data = {};

                if(typeof this.subject == 'string' &&  this.subject != '')
                    data.subject = this.subject;

                var passphrase_data =   passphraseVault
                    ?   passphraseVault.exportData()
                    :   { keyTransmission: 'none' }

                data.sePassphrase           =   passphrase_data.sePassphrase        || undefined;
                data.aePassphraseList       =   passphrase_data.aePassphraseList    || undefined;
                data.keyTransmission        =   passphrase_data.keyTransmission
                data.conversationSignatures =   passphrase_data.signatures

                data.recipients             =       passphrase_data.recipientKeyList
                ||  this.recipients.map(function(recipient){
                    return  {
                        identityId:     recipient.id ,
                        keys:          []
                    }
                });

                return data;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name load
             * @description
             * get Conversation Data from API
             *
             * @returns {Object} this Returns ConversationModel
             */
            this.load = function(){
//                cmLogger.debug('cmConversationModel:load');
                if(typeof this.id == 'string'
                    && this.id.length > 0
                    && this.state.is('loading') === false)
                {
                    this.state.set('loading');

                    cmConversationsAdapter.getConversation(this.id, limit, self.messages.length).then(
                        function(conversation_data){
                            self.importData(conversation_data);

                            self.state.unset('loading');
                        },
                        function(response){
                            self.state.unset('loading');
                            self.trigger('load:failed');

                            if(response.status && response.status == 404){
                                self.trigger('notFound',self);
                            }
                        }
                    );
                } else if(this.state.is('loading') === false) {
                    cmLogger.debug('cmConversationModel:load:failed - no Conversation Id');
                    this.trigger('load:failed');
                }

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name save
             * @description
             * send conversation to api
             *
             * @returns {Promise} for async handling
             */
            this.save = function(){

                if(!this.state.is('new'))
                    return $q.reject();

                return  $q.when(
                    this.isEncrypted()
                        ?   cmPassphraseVault.encryptPassphrase({
                        passphrase:         undefined,   // will be generated
                        password:           this.password,
                        identities:         this.recipients,
                        restrict_to_keys:   undefined   // encrypt for all recipient keys
                    })
                        :   undefined
                )
                    .then(function(pv){
                        passphraseVault = pv;
                        return cmConversationsAdapter.newConversation(self.exportData())
                    })
                    .then(
                    function (conversation_data) {
                        self
                            .importData(conversation_data)
                            .savePassCaptcha();

                        if(typeof self.password == 'string' && self.password.length > 0){
                            self.localPWHandler.set(conversation_data.id, self.password);
                        }

                        self.state.unset('new');
                        self.trigger('save:finished');

                        return conversation_data;
                    },

                    function(){
                        self.trigger('save:failed');
                        return $q.reject();
                    }
                )
            };

            this.update = function(conversation_data, fromDrtvInit){
                var offset = 0,
                    clearAllMessages = false;

                // unbind load prev messages but scroll to last message
                if(fromDrtvInit && self.messages.length >= limit){
                    $rootScope.$broadcast('scroll:to');
                    return this;
                }

                if(this.id){
                    if(typeof conversation_data !== 'undefined'){
                        if(this.messages.length < conversation_data.numberOfMessages) {
                            this._updateConversation(limit, self.messages.length, clearAllMessages);
                        }
                    } else {
                        self._updateConversation(limit, self.messages.length, clearAllMessages);
                    }
                }

                // after update scroll to last message
                if(fromDrtvInit) {
                    this.one('update:finished', function() {
                        $rootScope.$broadcast('scroll:to');
                    });
                }

                return this;
            };

            this.loadLatestMessages = function(){
                //cmLogger.debug('cmConversationModel.loadLatestMessages');

                if(typeof this.lastMessage.created == 'number'){
                    cmConversationsAdapter.getConversationMessages(this.id, null, null, this.lastMessage.created).then(
                        function(data){

                            self.state.set('loadedMessages');

                            /**
                             * Message Handling
                             */
                            if(typeof clearMessages !== 'undefined' && clearMessages !== false){
                                self.messages.reset();
                            }

                            self.importData(data);
                        }
                    )
                } else {
                    this.update();
                }

            };

            this.sendMessage = function(message, files, force){
                if(!(message instanceof cmMessageModel)){
                    return $q.reject('message no message-model');
                }

                return  this.getPassphrase()
                    .catch(function(){
                        return  self.isEncrypted()
                            ?   $q.reject('access denied')
                            :   $q.when(null);
                        //Todo: null for 'not encrypted' old convention
                    })
                    .then(
                    function(passphrase) {
                        return self.isEncrypted()
                            ? message
                            .addFiles(files)
                            .getSignatures()
                            .then(function () {
                                return message.encrypt(passphrase)
                            })
                            .then(function () {
                                return message.save()
                            })

                            : message
                            .addFiles(files)
                            .setPublicData(['text', 'fileIds'])
                            .revealSignatures()
                            .getSignatures()
                            .then(function () {
                                return message.save()
                            })
                    },
                    function(){
                        if(typeof force == 'boolean' && force === true){
                            return  message
                                .addFiles(files)
                                .setPublicData(['text', 'fileIds'])
                                .revealSignatures()
                                .getSignatures()
                                .then(function () {
                                    return message.save()
                                })
                        }
                    }
                )
            };

            /**
             * @param {Number} limit
             * @param {Number} offset
             * @param {Boolean} clearMessages
             */
            this._updateConversation = function(limit, offset, clearMessages){
                cmConversationsAdapter.getConversationMessages(this.id, limit, offset).then(
                    function(data){

                        self.state.set('loadedMessages');

                        /**
                         * Message Handling
                         */
                        if(typeof clearMessages !== 'undefined' && clearMessages !== false){
                            self.messages.reset();
                        }

                        self.importData(data);
                    }
                )
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name disableEncryption
             * @description
             * Disables the encryption for the conversation. Works only if the conversation is new (state).
             *
             * @returns {Object} this Returns itself for chaining.
             */
            this.disableEncryption = function(){
//                cmLogger.debug('cmConversationModel:disableEncryption');

                if(this.state.is('new')){
                    encryption_disabled = true;
                    this.password = '';
                    this.trigger('encryption:disabled');
                }

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name enableEncryption
             * @description
             * Enables the encryption for the conversation. Works only if the conversation is new (state) and no proper passphrase is set.
             *
             * @returns {Object} this Returns itself for chaining.
             */
            this.enableEncryption = function(){
//                cmLogger.debug('cmConversationModel:enableEncryption');

                if(this.state.is('new')){
                    encryption_disabled = false;
                    this.trigger('encryption:enabled')
                }

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name isEncrypted
             * @description
             * Returns encryption state of passphrase object which is similar of the encryption state of the conversation
             *
             * @returns {Boolean} bool Returns true if Conversation is encrypted.
             *
             * @todo
             */
            this.isEncrypted = function(){
//                cmLogger.debug('cmConversationModel.isEncrypted');

                return this.state.is('new')
                    ?   !encryption_disabled
                    :   this.keyTransmission != "none";
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name decrypt
             * @description
             * starts decrypting oh messages
             */
            this.decrypt = function () {
                //cmLogger.debug('cmConversationModel.decrypt', + this.subject);

                function run(){
                    self.getPassphrase()
                        .then(function (passphrase) {
                            return $q.all(self.messages.map(function (message) {
                                return message.decrypt(passphrase)
                            }))
                        })
                        .then(
                        function () {
                            self.trigger('decrypt:success');

                            // save password to localstorage
                            if (typeof self.password == 'string' && self.password.length > 0){
                                self.localPWHandler.set(self.id, self.password);
                            }

                            return $q.when()

                        },
                        function (reason) {
                            self.trigger('decrypt:failed');
                            return $q.reject(reason);
                        }
                    );
                }

                if(this.isEncrypted() && this.messages.some(function(message){return !message.state.is('decrypted')})){
                    //cmLogger.debug('conversation has to decrypt!')
                    run();
                }
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name getKeyTransmission
             * @description
             *
             *
             * @returns {String} getKeyTransmissionType
             */
            this.getKeyTransmission = function(){
                //If the conversation is not new:
                if(!this.state.is('new'))
                    return this.keyTransmission


                //Conversation is new, is it encrypted?
                if(!this.isEncrypted())
                    return 'none';

                //Conversation is new and encrypted,
                //is a password required for at least one recipient and if so are there any recipients who wont need a password?
                if(this.passwordRequired())
                    return this.getNiceRecipients() > 0 ? 'mixed' : 'symmetric'

                //Conversation is new, encrypted and there is no need for password:
                return 'asymmetric';
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name getPassphrase
             * @description
             * Function get the passphrase of the conversation, in order to use it for e.g. file encryption before upload.
             *
             * @returns {Promise} Returns a promise to resolve with passphrase
             */
            this.getPassphrase = function(){

                if(!this.isEncrypted())
                    return $q.reject('not encrypted.')

                if(!this.state.is('new') && !passphraseVault)
                    return $q.reject('new but passphrasevault missing.')

                if(!passphraseVault)
                    return $q.reject('passphrase vault missing.')

                return passphraseVault.get(this.password)
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name verifyAuthenticity
             * @description
             * Tries to verify the authenticity of the recipient list an the key transmission type.
             *
             * @returns {Promise} Returns a promise resolved if successful and rejected on failure
             */
            this.verifyAuthenticity = function(){
                return  passphraseVault
                    ?   passphraseVault.verifyAuthenticity()
                    :   $q.reject('cmConversationModel: missing passphraseVault')
            }

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name passwordRequired
             * @description
             * Checks if the conversation requires a password
             *
             * @returns {Boolean} returns true or false
             */
            this.passwordRequired = function(){
//                cmLogger.debug('cmConversationModel:passwordRequired');

                if(this.state.is('new')){
                    return  this.isEncrypted()
                        &&  (
                        this.getBadRecipients().length != 0
                        ||  !this.userHasPrivateKey()
                        || this.hasPassword()
                        )

                } else {
                    return this.hasPassword() && (!this.userHasPrivateKey() || !this.userHasAccess())
                }
            }

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name hasPassword
             * @description
             * Helper Function which checks if Conversation has as Password
             *
             * @returns {Boolean} boolean Returns a Boolean
             */
            this.hasPassword = function(){
//                cmLogger.debug('cmConversationModel:hasPassword');
                if(this.state.is('new')){
                    return (this.options.hasPassword == true)
                } else {
                    return passphraseVault && ['symmetric', 'mixed'].indexOf(passphraseVault.getKeyTransmission()) != -1;
                }
            };

            //TODO:
            this.userHasAccess = function(){
                return passphraseVault.userHasAccess();
            };

            this.enablePassCaptcha = function(){
//                cmLogger.debug('cmConversationModel.enablePassCaptcha');
                this.options.hasCaptcha = true;
                this.trigger('captcha:enabled');

                return this;
            };

            this.disablePassCaptcha = function(){
//                cmLogger.debug('cmConversationModel.disablePassCaptcha');
                if(!this.state.is('new')) return ;

                this.options.hasCaptcha = false;
                this.tmpPassCaptcha = '';
                this.trigger('captcha:disabled');

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name initPassCaptcha
             * @description
             * Initialize PassCaptcha Handling in Conversation
             * creates a cmFile Object
             *
             *
             * @param {Object} conversation_data Data from API Call
             * @returns {ConversationModel} this returns ConversationModel
             */
            this.initPassCaptcha = function(conversation_data){
//                cmLogger.debug('cmConversationModel.initPassCaptcha');
                if(typeof conversation_data.passCaptcha !== 'undefined' && conversation_data.passCaptcha != '' && this.passCaptcha == undefined){
                    /**
                     * set Options
                     * @type {boolean}
                     */
                    this.options.hasCaptcha = true;

                    this.passCaptcha = cmFileFactory.create(conversation_data.passCaptcha);
                    this.passCaptcha
                        .downloadStart(true);
                }

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name savePassCaptcha
             * @description
             *
             * @returns {ConversationModel} this ConversationModel
             */
            this.savePassCaptcha = function(){
                if(this.tmpPassCaptcha != ''){
                    this.passCaptcha = cmFileFactory.create();
                    this.passCaptcha.name = this.passCaptcha.encryptedName = 'captcha';
                    // public passcaptcha
                    this.passCaptcha.setPassphrase(null);

                    this.passCaptcha
                        .importBase64(this.tmpPassCaptcha)
                        .prepareForUpload()
                        .then(function(){
                            self.passCaptcha.uploadChunks();
                        });

                    this.passCaptcha.on('upload:finish', function(){
                        cmConversationsAdapter.updateCaptcha(self.id, self.passCaptcha.id);
                    });
                }

                return this;
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name getBadRecipients
             * @description
             * Function returns a list of all recipients who have no proper key
             *
             * @returns {Array} recipients Filter
             */
            this.getBadRecipients = function(){
                return this.recipients.filter(function(recipient){
                    return recipient.keys.getWeakestKeySize() <= 2000
                })
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name getNiceRecipients
             * @description
             * Function returns a list of all recipients who have a proper key
             *
             * @returns {Array} recipients Filter
             */
            this.getNiceRecipients = function(){
                return  this.recipients.filter(function(recipient){
                    return recipient.keys.getWeakestKeySize() > 2000
                })
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name addRecipient
             * @description
             * Function to add a recipient to a conversation. Will not update the backend.
             *
             * @param {Object} identityModel identityModel
             * @returns {cmConversationModel} this cmConversationModel
             */
            this.addRecipient = function(identityModel){
//                cmLogger.debug('cmConversationModel.addRecipient');
                this.recipients.register(identityModel);

                return this;
            };

            this.hasRecipient = function(identity){
                var check = false;

                this.recipients.forEach(function(recipient){
                    check = check || (identity.id == recipient.id);
                });

                return check;
            };

            this.saveRecipient = function(){
                // @ todo save new recipients to api
            }

            /**
             * @param identity
             * @returns {cmConversationModel.ConversationModel}
             */
            this.removeRecipient = function (recipient) {
//                cmLogger.debug('cmConversationModel.removeRecipient');
                this.recipients.deregister(recipient);

                return this;
            };

            this.checkPreferences = function(){
                if(this.state.is('new')) {
                    /**
                     * set Default
                     * has Captcha will be set at an other method
                     */
                    this.options.hasPassword = false;
                    this.options.showKeyInfo = false;

                    if (this.isEncrypted()) {
                        if (this.state.is('new') && this.userHasPrivateKey() == false) {
                            this.options.hasPassword = true;
                            this.options.showKeyInfo = true;
                        }

                        /**
                         * check recipients
                         */
                        if (this.getBadRecipients().length > 0) {
                            self.options.hasPassword = true;
                        }
                    }

                    /**
                     * last check for captcha preference
                     */
                    if (this.hasPassword() == false) {
                        this.options.hasCaptcha = false;
                    }
                }
            };

            /**
             * @ngdoc method
             * @methodOf cmConversationModel
             *
             * @name updateLockStatus
             * @description
             * update lock status for gui
             *
             * @returns {cmConversationModel} this cmConversationModel
             */
            this.updateLockStatus = function(){
//                cmLogger.debug('cmConversationModel.updateLockStatus');

                var levels =    {
                    'asymmetric'    : 2,
                    'symmetric'     : 1,
                    'mixed'         : 1,
                    'none'          : 0
                };
                var className = '',
                    allRecipientsHasKeys = true;


                if(this.state.is('new')){

                    if(this.isEncrypted() !== false){
                        this.lockStatus.level = levels.mixed;

                        this.recipients.forEach(function(recipient){
                            if(recipient.keys.getWeakestKeySize() == 0){
                                allRecipientsHasKeys = false;
                            }
                        });

                        if(allRecipientsHasKeys !== false && this.hasPassword() !== true){
                            this.lockStatus.level = levels.asymmetric;
                        }
                    } else {
                        this.lockStatus.level = levels.none;
                    }


                } else {
                    this.lockStatus.level = levels[this.keyTransmission];
                }

                switch(this.lockStatus.level){
                    case 0: className = 'unsafe'; break;
                    case 1: className = 'safe'; break;
                    case 2: className = 'safer'; break;
                }

                this.lockStatus.class = 'safetylevel-'+className;

                return this;
            };

            this.setLastMessage = function(){
//                cmLogger.debug('cmConversationModel.setLastMessage!');

                if(this.messages.length > 0){

                    this.lastMessage = this.messages.reduce(function(value, message){
                        return value != undefined ? ( (value.created > message.created) ? value : message) : message;
                    });
                }

                return this;
            };

            this.checkMissingTrustedKeys = function(){
                if(this.state.is('decrypted')){
                    // check ob trusted keys in pasephraselist fehlen
                    // special call ans BE?
                }
            };

            /**
             * Event Handling
             */

            $rootScope.$on('logout', function(){
                self.messages.reset();
                self.recipients.reset();
            });

            $rootScope.$on('identity:switched', function(){
                self.messages.reset();
                self.recipients.reset();
            });

            this.on('update:finished', function(){
//                cmLogger.debug('cmConversationModel:on:update:finished');
                self.setLastMessage();
                self.decrypt();
                self.updateLockStatus();
            });

            this.on('encryption:enabled', function(){
//                cmLogger.debug('cmConversationModel:on:encryption:enabled');
                self.checkPreferences();
                self.updateLockStatus();
            });

            this.on('encryption:disabled', function(){
//                cmLogger.debug('cmConversationModel:on:encryption:disabled');
                self.checkPreferences();
                self.updateLockStatus();
            });

            //Todo: fire event on factory and delegate to conversation or something
            this.on('message:new', function(event, data){
                if(typeof data == 'object'){
                    if('message' in data) {
                        //console.log(self.timeOfLastUpdate,message_data.created)
                        if ('created' in data.message) {
                            self.timeOfLastUpdate = data.message.created;
                        }

                        var message = self.messages.find(data.message);
                        if (message == null) {
                            data.message.conversation = self;
                            self.numberOfMessages++;
                            message = self.messages.create(data.message);
                        } else {
                            message.importData(data.message);
                        }

                        self.decrypt();
                        self.setLastMessage();

                        if(!message.state.is('notified')){
                            message.state.set('notified');

                            cmBrowserNotifications.showNewMessage(message.from, self.id);
                        }


                        self.trigger('message:reInitFiles');
                    }

                    if('unreadMessages' in data){
                        self.unreadMessages = data.unreadMessages;
                    }
                }
            });

            this.recipients.on(['register', 'update:finished', 'deregister'], function(){
                //cmLogger.debug('cmConversationModel:recipients.on');
                self.updateLockStatus();
            });

            this.on('captcha:enabled captcha:disabled', function(){
//                cmLogger.debug('cmConversationModel:on:captcha:enabled');
                self.updateLockStatus();
            });

            this.messages.on('message:saved', function(){
                self.setLastMessage();
            });

            this.messages.on('decrypt:success', function(){
                self.state.set('decrypted');
                self.setLastMessage();

                //self.checkMissingTrustedKeys();
            });

            this.messages.on('last-message:read', function(event, message){
                // TODO: if last my own unread will never set back
                /*
                 * message.from.id != cmUserModel.data.identity.id
                 &&
                 */

                if(message.id == '#new_message')
                    return false;

                if((
                    !message.isEncrypted()
                    || message.state.is('decrypted')
                    || message.state.is('incomplete')
                    )
                    && self.unreadMessages > 0
                    && cmSettings.get('enableUnreadMessages')
                ){
                    self.unreadMessages = 0;
                    cmConversationsAdapter.sendReadStatus(self.id, message.id)
                }
            });

            cmUserModel.on('key:stored key:removed', function(){
                self.checkPreferences();
                self.updateLockStatus();
            });

            // after events!!!
            init(data);
        }

        return ConversationModel;
    }
])
.service('cmConversationsAdapter', [
    'cmApi',
    'cmUserModel',
    'cmObject',
    'cmUtil',
    'cmLogger',
    function (cmApi, cmUserModel, cmObject, cmUtil, cmLogger){
        var adapter = {

            newConversation: function(data) {
                return cmApi.post({
                    path: 	'/conversation',
                    data:	data
                })
            },

            _updateConversation: function(conversation){
                return cmApi.put({
                    path: '/conversation/' + conversation.id,
                    data: conversation
                });
            },

            getConversations: function(limit, offset){
                //cmLogger.debug('getConversations');
                var queryString = cmUtil.handleLimitOffset(limit,offset);

                if(queryString == ''){
                    queryString += '?' + cmUserModel.getLocalKeyIdsForRequest();
                } else {
                    queryString += cmUserModel.getLocalKeyIdsForRequest();
                }

                return cmApi.get({
                    path: '/conversations' + queryString
                })
            },

            getConversation: function(id, limit, offset, timeLimit){
                //cmLogger.debug('getConversation');
                var queryString = cmUtil.handleLimitOffset(limit,offset, timeLimit);

                if(queryString == ''){
                    queryString += '?' + cmUserModel.getLocalKeyIdsForRequest();
                } else {
                    queryString += cmUserModel.getLocalKeyIdsForRequest();
                }

                return cmApi.get({
                    path: '/conversation/'+ id + queryString
                })
            },

            searchConversations: function(search, limit, offset){
                var queryString = cmUtil.handleLimitOffset(limit,offset);

                return cmApi.post({
                    path: '/conversations/search' + queryString,
                    data: {
                        search: search
                    }
                })
            },

            getConversationSummary: function(id){
                //cmLogger.warn('cmConversationAdapter: .getConversationSummary is deprecated; use .getConversation(id, 1, 0) instead')
                //return this.getConversation(id, 1, 0)
                return cmApi.get({
                    path: '/conversation/' + id + '/summary' + '?' +  cmUserModel.getLocalKeyIdsForRequest()
                })
            },

            getConversationMessages: function(id, limit, offset, timeLimit) {
                var queryString = cmUtil.handleLimitOffset(limit,offset,timeLimit);

                if(queryString == ''){
                    queryString += '?' + cmUserModel.getLocalKeyIdsForRequest();
                } else {
                    queryString += cmUserModel.getLocalKeyIdsForRequest();
                }

                return cmApi.get({
                    path: '/conversation/'+ id + '/messages' + queryString
                })
            },


            getPurl: function(id){
                return cmApi.get({
                    path:'/purl/' + id + '?' +  cmUserModel.getLocalKeyIdsForRequest()
                })
            },

            addRecipient: function(id_conversation, id_identity_recipient){
                return	cmApi.post({
                            path:	'/conversation/%1/recipient'.replace(/%1/, id_conversation),
                            data:	{
                                        recipients: [id_identity_recipient]
                                    }
                        })
            },

            removeRecipient: function(id, recipient_id){
                return	cmApi.delete({
                            path:	'/conversation/%1/recipient/%2'.replace(/%1/, id).replace(/%2/, recipient_id)
                        })
            },

            updateSubject: function(id, subject){
                return  cmApi.put({
                            path:    '/conversation/%1'.replace(/%1/, id),
                            data:   {
                                        subject: subject
                                    }
                        })
            },

            updateCaptcha: function(id, idFile){
                return  cmApi.put({
                            path:    '/conversation/'+id,
                            data:   {
                                        passCaptcha: idFile
                                    }
                        })
            },

            sendMessage: function(id, message){
                return	cmApi.post({
                            path:	"/conversation/%1/message".replace(/%1/, id),
                            data: 	message
                        })
            },

            sendReadStatus: function(idConversation, idMessage){
                return	cmApi.post({
                    path:	"/conversation/" + idConversation + "/message/" + idMessage + "/read"
                })
            },

            updateEncryptedPassphraseList: function(id, aePassphraseList){
                return  cmApi.post({
                            path:    "/conversation/%1/aePassphrases".replace(/%1/, id),
                            data:   {aePassphraseList : aePassphraseList}
                        })
            },

            deleteConversation: function(idConversation){
                return  cmApi.delete({
                            path: "/conversation/" + idConversation + "/recipient"
                        })
            }
        };

        cmObject.addEventHandlingTo(adapter);
       
        cmApi.on('conversation:new-message', function(event, data){
            adapter.trigger('message:new', data)
        });

        cmApi.on('conversation:new', function(event, data){
            adapter.trigger('conversation:new', data)
        });

        cmApi.on('conversation:update', function(event, data){
            adapter.trigger('conversation:update', data)
        });

        cmApi.on('conversation:deleted', function(event, data){
            adapter.trigger('conversation:deleted', data)
        });

        cmApi.on('rekeying:finished', function(event, data){
            cmLogger.debug('cmConversationsAdapter.on rekeying:finished');
            adapter.trigger('passphrases:updated', data);
        });

        cmApi.on('subscriptionId:changed', function(){
            //cmLogger.debug('cmConversationsAdapter.on subscriptionId:changed');
            adapter.trigger('subscriptionId:changed');
        });

        return adapter
    }
])

    .factory('cmMessageModel',[
    'cmConversationsAdapter',
    'cmCrypt',
    'cmIdentityFactory',
    'cmFileFactory',
    'cmFilesAdapter',
    'cmUserModel',
    'cmObject',
    'cmStateManagement',
    'cmUtil',
    'cmLogger',
    '$rootScope',
    '$q',
    function (cmConversationsAdapter, cmCrypt, cmIdentityFactory, cmFileFactory,
              cmFilesAdapter, cmUserModel, cmObject, cmStateManagement, cmUtil, cmLogger,
              $rootScope, $q){

        /**
         * @constructor
         * @description
         * Represents a Message.
         * Events
         *  - init:finished
         *  - update:finished
         *  - load:failed
         * Stats
         *  - new
         *  - loading
         *  - decrypted
         *
         *
         * @param {Object} [data] - The conversation data as received from the backend.
         */
        function Message(data){
            // attributes
            var self = this,
                conversation = undefined;

            cmObject.addEventHandlingTo(this);

            this.id = undefined;
            this.created = undefined;
            this.from = undefined;

            // secret data
            this.secret = ['text','fileIds'];
            this.reveal_signatures = false; // encrypt signatures

            // public data
            this.public = [];

            // files
            this.files = [];
            this.fileIds = [];

            this.state = new cmStateManagement(['new','decrypted','loading', 'incomplete', 'sending', 'waitForFiles', 'authentic', 'valid', 'signed', 'unverifiable', 'defective']);

            this.authenticity = {
                                    publicData : null,
                                    secretData : null,
                                    signatures : null,

                                    setPublicData : function(data){
                                        this.publicData = data
                                        return this
                                    },

                                    setSecretData : function(data){
                                        this.secretData = data
                                        return this
                                    },

                                    setSignatures : function(signatures){
                                        this.signatures = signatures
                                        return this
                                    },

                                    getToken : function(){

                                        if(this.publicData == null)
                                            return $q.reject('plain data missing.')

                                        if(typeof this.secretData == null)
                                            return $q.reject('secret data missing.')

                                        var self =  this,
                                            data =  {
                                                        'public': self.publicData || {},
                                                        'secret': self.secretData || {}
                                                    }

                                        return  $q.when(cmCrypt.hashObject(data))
                                    },

                                    newSignatures : function(){
                                        var self = this

                                        return  $q.when()
                                                .then(function(){
                                                    return self.getToken()
                                                })
                                                .then(function(token){
                                                    return cmUserModel.signData(token)
                                                })
                                                .then(function(signatures){
                                                    self.signatures = signatures
                                                    return $q.when(signatures)
                                                })
                                    },

                                    verify : function(identity){
                                        var self = this

                                        if(!identity)
                                            return $q.reject({type: 0, msg:'identity missing'})     //cannot verify

                                        if(this.signatures == null || !this.signatures.length)
                                            return $q.reject({type: 0, msg:'signatures missing'})   //cannot verify

                                        if(identity.keys.length ==0)
                                            return $q.reject({type: 0, msg:'keys missing'})         //cannot verify
                                        
                                        return  this.getToken()
                                                .then(function(token){

                                                    var promises                = [],
                                                        valid_signatures        = [],
                                                        bad_signatures          = []

                                                    self.signatures.forEach(function(signature){
                                                        var key         = identity.keys.find(signature.keyId),
                                                            deferred    = $q.defer()

                                                        if(key){
                                                            promises.push(deferred.promise)

                                                            key.verify(token, signature.content, true)
                                                            .then(
                                                                function(){
                                                                    valid_signatures.push(signature)
                                                                },
                                                                function(){
                                                                    bad_signatures.push(signature)
                                                                }
                                                            )
                                                            .finally(function(){
                                                                deferred.resolve()
                                                            })
                                                        }
                                                    })
                                                    
                                                    return $q.all(promises)
                                                            .then(function(){
                                                                return  valid_signatures.length > 0
                                                                        ?   $q.when(valid_signatures)
                                                                        :   $q.reject(
                                                                                bad_signatures.length > 0 
                                                                                ?   {type:1, msg:'verification failed.', bad_signatures: bad_signatures}
                                                                                :   {type:0, msg:'no matching keys found for signatures.'}
                                                                            )
                                                            })

                                                   
                                                })
                                    }
                                };

            this.state = new cmStateManagement(['new','decrypted','loading', 'incomplete', 'sending', 'waitForFiles','notified']);

            /**
             * Initialize Message Object
             * @param message_data
             * @returns {Message}
             */
            function init(data){
                if(typeof data == 'object' && ('conversation' in data)){
                    conversation = data.conversation;

                    if(cmUtil.objLen(data) > 1){
                        self.importData(data);
                    } else {
                        self.from = cmUserModel.data.identity;
                        self.state.set('new');
                    }
                } else {
                    // fail ??
                    self.state.set('new');
                    self.from = cmUserModel.data.identity;
                }                
            }

            /**
             * reset object
             */
            function reset(){
                //cmLogger.debug('cmMessageModel.reset');
                self.files = [];
                self.fileIds = [];
            }

            /**
             * @name importData
             * @description import data
             */
            this.importData = function(data){
                //cmLogger.debug('cmMessageModel.importData');
                this.id         = data.id || this.id;

                if('fromIdentity' in data){
                    var old_from    = this.from 
                    this.from       = cmIdentityFactory.create(data.fromIdentity);

                    if(old_from != this.from)
                        this.from.on('update:finished', function(){
                            self.authenticity.verify(self.from)
                            .then(this.handleVerificationSuccess,this.handleVerificationFail)
                        })
                }


                this.created    = data.created || this.created;

                this.plainData      = data.plain        || this.plainData       || {}
                this.encryptedData  = data.encrypted    || this.encryptedData

                // compare plain to this
                for(var key in this.plainData){
                    this[key] = this.plainData[key] || this[key];
                }

                this.authenticity.setPublicData(this.plainData)

                this.text       = data.text     || this.text;
                this.fileIds    = data.fileIds  || this.fileIds;

                this.signatures = data.signatures || this.signatures


                this.state.set('incomplete')
                this.initFiles();


                if(this.signatures && ((this.signatures.plain && this.signatures.plain.length > 0) || this.signatures.encrypted)){
                    this.state.set('signed')

                    if(!this.encryptedData && !this.signatures.encrypted){
                        self.authenticity
                        .setPublicData(self.plainData)
                        .setSecretData({})
                        .setSignatures(self.signatures.plain)
                        .verify(self.from)
                        .then(this.handleVerificationSuccess,this.handleVerificationFail)
                    }else{
                        self.when('decrypt:success')
                        .then(function(){
                            return self.authenticity.verify(self.from)
                        })    
                        .then(this.handleVerificationSuccess,this.handleVerificationFail)
                    }
                }

                this.trigger('update:finished');

                this.state.unset('new');

                return this;
            };

            // sets which data should not be encrypted
            this.setPublicData = function(data){
                // data may be a string or an array
                data = typeof data == 'string' ? [data] : data;

                // set keys for all data to secret:
                var all_the_data =  this.secret
                                    .concat(this.public)
                                    .filter(function(elem, pos, arr) {
                                        return arr.indexOf(elem) == pos;
                                    });

                this.secret = all_the_data;
                this.public = [];

                // set keys for selected data to public
                data.forEach(function(key){
                    var secret_pos = self.secret.indexOf(key);
                    if( secret_pos != -1) self.secret.splice(secret_pos, 1);

                    self.public.push(key);
                });

                return this;
            };

            this.handleVerificationSuccess = function(valid_signatures){
                self.state
                .unset('unverifiable')
                .unset('valid')
                .unset('authentic')
                .unset('defective')

                cmUserModel.verifyIdentityKeys(self.from, false, true)
                .then(function(ttrusted_keys){
                    var authentic_signatures    =   valid_signatures.filter(function(signature){
                                                        return ttrusted_keys.some(function(key){
                                                           return key.id == signature.keyId 
                                                        })
                                                    })

                    authentic_signatures.length > 0
                    ?   self.state.set('authentic')
                    :   self.state.set('valid')

                })

            }

            this.handleVerificationFail = function(reason){
                self.state
                .unset('unverifiable')
                .unset('valid')
                .unset('authentic')
                .unset('defective')

                reason.type == 0
                ?   self.state.set('unverifiable')
                :   self.state.set('defective')
            };

            this.revealSignatures = function(){
                this.reveal_signatures = true
                return this
            };

            this.setText = function(text){
                this.text = text;
                return this;
            };

            this.isEncrypted = function(){
                if(!this.state.is('new')) {
                    return (this.encryptedData == undefined) ? false : (this.encryptedData != false)
                }
            };

            this.getPublicData = function(){
                var public_data = {};

                this.public.forEach(function(key){
                    if(self[key]) public_data[key] = self[key]
                });

                return public_data
            };

            this.getSecretData = function(){
                var secret_data = {};

                this.secret.forEach(function(key){
                    if(self[key]) secret_data[key] = self[key]
                });

                return secret_data

            };

            this.getSignatures = function(){
                return  this.authenticity
                        .setPublicData(self.getPublicData())
                        .setSecretData(self.getSecretData())
                        .newSignatures()
                        .then(function(signatures){
                            self.signatures = self.signatures || {}
                            self.signatures.plain = signatures
                            return $q.when(self.signatures.plain)
                        })
            };

            this.verifySignatures = function(){
                return this.authenticity.verify(this.from)
            };

            this.encrypt = function (passphrase) {
                return  $q.when()
                        .then(function(){
                            
                            if(self.signatures && self.signatures.plain && self.signatures.plain.length != 0)
                                self.signatures.encrypted = cmCrypt.encrypt(passphrase, JSON.stringify(self.signatures.plain))

                            return  $q.when(self.signatures.encrypted)
                        })
                        .then(function(){                            
                            var secret_data     = self.getSecretData()
                            self.encryptedData  = cmCrypt.encrypt(passphrase, JSON.stringify(secret_data))

                            return  $q.when(self.encryptedData)
                        })
            };

            this.decrypt = function (passphrase) {
                //cmLogger.debug('cmMessageModel.decrypt');
                if(this.state.is('decrypted') !== true || this.state.is('incomplete')){

                    if(typeof this.encryptedData == 'string' && this.encryptedData.length > 0){
                        /**
                         * @deprecated
                         * Workaround for old Messages in dev and stage
                         */
                        if(this.encryptedData.charAt(0) != '{'){
                            this.encryptedData = cmCrypt.base64Decode(this.encryptedData);
                        }

                        if(this.signatures && this.signatures.encrypted){
                            var signatures = JSON.parse(cmCrypt.decrypt(passphrase,this.signatures.encrypted))
                            this.authenticity.setSignatures(signatures) 
                        }

                        var decrypted_data = JSON.parse(cmCrypt.decrypt(passphrase,this.encryptedData))


                        if(decrypted_data){
                            this.authenticity.setSecretData(decrypted_data)

                            this.importData(decrypted_data);


                            if(!this.hasFiles()){
                                self.state.set('decrypted');
                                self.trigger('decrypt:success');
                            } else {
                                this.allFilesReady().then(function(){
                                    self.state.set('decrypted');
                                    self.trigger('decrypt:success');
                                });
                            }
                        }

                        return !!decrypted_data
                    }
                }

                return true;
            };

            /**
             * send message to backend object
             * @param conversation
             * @returns {*|Promise|!Promise.<RESULT>}
             */
            this.save = function (){
             return $q.when()
                .then(function(){
                    var publicData      = self.getPublicData(),
                        encryptedData   = self.encryptedData;

                    // Check if the message is alright to be send to the backend:
                    var proper_public_data      =       (typeof publicData == 'object')
                                                    &&  Object.keys(publicData).length > 0,
                        proper_encrypted_data   =       (typeof encryptedData == 'string')
                                                    &&  encryptedData.length > 0;

                    if(proper_public_data == false && proper_encrypted_data == false )
                        return $q.reject('Message improper.');
                    
                    // everything is alright:

                    return  self.reveal_signatures !== true
                            ?   $q.when({
                                    plain:      publicData,
                                    encrypted:  encryptedData,
                                    signatures: {
                                                    encrypted:  self.signatures.encrypted
                                                }
                                })
                            :   $q.when({
                                    plain:      publicData,
                                    encrypted:  encryptedData,
                                    signatures: {
                                                    plain:      self.signatures.plain
                                                }
                                })
                })
                .then(function(data){
                    return  cmConversationsAdapter.sendMessage(conversation.id, data)
                })
                // If we got this far everything seems alright; send the message to the backend:
                .then(function(message_data) {
                    //Since this message is our own message,
                    //we already know the original data, thus it actually is decrypted and wont need further decryption.
                    self.state.set('decrypted');
                    self.importData(message_data);
                    self.trigger('message:saved');

                    return $q.when(message_data)
                })
                .catch(function(reason){
                    cmLogger.debug('cmMessage: saving failed:' + reason)
                })
            };

            this.isOwn = function(){
//                return (!this.from || cmUserModel.data.id == this.from.id);
                return (cmUserModel.data.id == this.from.id);
            };

            this.hasFiles = function(){
                return this.files.length > 0;
            };

            this.allFilesReady = function(){
                var defered = $q.defer(),
                    filesReady = [];

                angular.forEach(this.files, function(file){
                    var filePromise = $q.defer();
                    if(file.state.is('onlyFileId')) {
                        filesReady.push(filePromise.promise);
                        file.one('importFile:finish', function(event, file){
                            filePromise.resolve();
                        });
                    }
                });

                $q.all(filesReady)
                .then(function(){
                    defered.resolve();
                });

                return defered.promise;
            };

            /**
             * Handle Upload from new Files
             * @returns {cmMessageModel.Message}
             */
            this.uploadFiles = function(){
                if(this.files.length > 0){
                    self.state.unset('incomplete');
                    self.state.set('uploading');
                    angular.forEach(this.files, function(file){
                        file
                            .setOnCompleteId(self.id)
                            .uploadChunks();
                    });
                }

                return this;
            };

            /**
             * initialize Files from Message Data (fileIds)
             * @returns {Message}
             */
            this.initFiles = function(){
                if(self.state.is('uploading')){
                    this.state.unset('incomplete');
                    return this;
                }

                if(this.fileIds.length > 0){
                    angular.forEach(this.fileIds, function(id){
                        self._addFile(cmFileFactory.create(id));
                    });
                    this.trigger('init:files');
                } else {
                    this.state.unset('incomplete');
                }

                return this;
            };

            /**
             * add cmFile Object to Message Object
             * checks if cmFile Object still added or not
             * @param file
             * @private
             */
            this._addFile = function(file){
                var i = 0,
                    check = false;

                /**
                 * Array of cmFiles Objects
                 */
                if(this.files.length == 0){
                    this.files.push(file);
                } else {

                    while(i < this.files.length){
                        if(this.files[i].id == file.id){
                            check = true;
                            break;
                        }
                        i++;
                    }

                    if(check !== true){
                        this.files.push(file);
                    }
                }

                /**
                 * Array of cmFiles Objects
                 */
                if(this.fileIds.length == 0){
                    this.fileIds.push(file.id);
                } else {
                    if(this.fileIds.indexOf(file.id) == -1){
                        this.fileIds.push(file.id);
                    }
                }

                return this;
            };

            /**
             * add cmFiles to Message Wrapper Function for Arrays
             * @param array of cmFileObjects
             * @returns {cmMessageModel.Message}
             */
            this.addFiles = function(array){
                if(typeof array !== 'undefined' && array != null && array.length > 0){
                    angular.forEach(array, function(file){
                        self._addFile(file);
                    });
                }

                return this;
            };

            this.decryptFiles = function(passphrase){
                angular.forEach(this.files, function(file, index){
                    if(file.state.is('onlyFileId')) {
                        file
                            .setPassphrase(passphrase)
                            .downloadStart();

                        file.one('importFile:incomplete',function(event, file){
                            self.state.set('incomplete');
                            // add to queue
                            self.incompleteFiles.push(file);
                        });

                        file.one('importFile:finish', function(event, file){
                            // clear from queue
                            var index = self.incompleteFiles.indexOf(file);
                            self.incompleteFiles.splice(index,1);
                        });
                    }
                });

                this.allFilesReady().then(function(){
                    self.state.unset('incomplete');
                });

                return this;
            };

            /**
             * Event Handling
             */
            $rootScope.$on('logout', function(){ reset(); });
            $rootScope.$on('identity:switched', function(){ reset(); });

            this.on('message:saved', function(){
                self.uploadFiles();
            });


            cmUserModel.on('update:finished', function(){
                self.authenticity.verify(self.from)
                .then(this.handleVerificationSuccess,this.handleVerificationFail)
            })

            init(data);

            // if files are incomplete wait for message:new backend event to reinit
            this.incompleteFiles = [];
            if(conversation != undefined && ('on' in conversation)) {
                conversation.on('message:reInitFiles', function () {
                    if (self.state.is('incomplete')) {
                        self.incompleteFiles.forEach(function(file) {
                            file.importFile();
                        });
                    }
                });
            }
        }

        return Message;
    }
])
.service('cmPurlModel',[
    'cmObject',
    'cmConversationsAdapter',
    'cmConversationFactory',
    'cmUserModel',
    'cmAuth',
    'cmLogger',
    '$q',
    '$rootScope',
    function(cmObject, cmConversationsAdapter, cmConversationFactory, cmUserModel, cmAuth, cmLogger, $q, $rootScope) {
        var purls = [];

        var purlModel = {
            getPurl: function(id){
                var deferred = $q.defer();

                if(typeof id !== 'undefined'){
                    //var purl = purls.map(function(purl){
                    //    return (purl.id == id);
                    //});
                    //console.log(purl)
                    //
                    //if(typeof purls[id] != 'undefined'){
                    //    deferred.resolve(purls[id].data);
                    //} else {
                        cmConversationsAdapter.getPurl(id).then(
                            function (data) {
                                deferred.resolve(data);
                            },
                            function (response) {
                                deferred.reject(response);
                            }
                        );
                    //}
                } else {
                    deferred.reject();
                }

                return deferred.promise;
            },

            handleConversation: function(conversation_data){
                var conversation = cmConversationFactory.create(conversation_data);

                return conversation.id;
            },

            /**
             * @TODO add Function to cmUserModel to handle Guests and add Identities
             * @param identity
             */
            handleIdentity: function(identity_data){
                var currentIdentity = cmUserModel.getIdentity();

                if(identity_data.userType == 'external'){
                    //cmLogger.debug('cmPurlModel:handleIdentity:externUser');
                    cmUserModel.doLogout(false,'purl-modl handleIdentity');
                    cmUserModel.setIdentity(identity_data);

                    $rootScope.$broadcast('login');
                } else if(identity_data.id != currentIdentity.id){
                    //cmLogger.debug('cmPurlModel:handleIdentity:internUser')
                }

                return this;
            },

            /**
             * @param token
             */
            handleToken: function(token){
                if(typeof token !== 'undefined'){
                    cmUserModel.storeToken(token);
                }

                return this;
            }
        };

        cmObject.addEventHandlingTo(purlModel);

        return purlModel;

        $rootScope.$on('logout', function(){
            purls = [];
        });

        $rootScope.$on('identity:switched', function(){
            purls = [];
        });
    }
])
angular.module('cmCore',['pascalprecht.translate', 'cmConfig', 'cmUi', 'cmContacts', 'cmPhonegap'])
.directive('cmConnectionHandler',[
    'cmModal', 'cmLogger',
    '$rootScope',
    function (cmModal, cmLogger,
              $rootScope) {
        return {
            restrict: 'A',
            link: function (scope, element) {

                var listenedEvents = [
                    'cmConnectionHandler:failed',
                    'cmConnectionHandler:notSecure'
                ];

                function showModal(event, reconnectCallback){
                    // hide spinner and hide app content
                    $rootScope.$broadcast('cmBoot:appSpinner','hide','cmConnectionHandler');
                    element.addClass('ng-hide');
                    // prepare reconnect callback
                    var scope = $rootScope.$new();
                    scope.onFooterClick = function(){
                        reconnectCallback();

                        // TODO: at no routechange the spinner doesn't disappear
                        // $rootScope.$broadcast('cmBoot:appSpinner','show');

                        $rootScope.$broadcast('getBrowserInfo');
                        element.removeClass('ng-hide');
                    };
                    // create and show modal
                    var eventId = (function(){
                        var name = event.name.split(':');
                        return name[1].toUpperCase();
                    })();

                    cmModal.create(
                        {
                            id: 'connection-handler',
                            type: 'alert',
                            'cm-close-btn': false,
                            'cm-close-on-backdrop': false,
                            'cm-footer-label': 'MODAL.CONNECTION_HANDLER.'+eventId+'.FOOTER',
                            'cm-footer-icon': 'cm-change'
                        },
                        '<div class="attention">' +
                            '<i class="fa cm-attention cm-orange"></i> '+
                            '<span ng-bind-html="\'MODAL.CONNECTION_HANDLER.'+eventId+'.TEXT\'|cmParse"></span>' +
                        '</div>',
                        'body',
                        scope
                    );
                    cmModal.open('connection-handler');
                }

                var killWatchers = [];
                listenedEvents.forEach(function(eventName){
                    killWatchers.push($rootScope.$on(
                        eventName,
                        function(event, reconnectCallback){

                            if(typeof reconnectCallback != 'function') {
                                cmLogger.warn('cmConnectionHandler called without callback',event);
                                return false;
                            }

                            showModal(event, reconnectCallback);
                        })
                    );
                });

                scope.$on('$destroy', function(){
                    killWatchers.forEach(function(watcher){
                        watcher();
                    });
                });
            }
        }
    }
])
//This factory provides a generic Factory

.factory('cmFactory',[
    'cmObject',
    'cmLogger',
    function(cmObject, cmLogger) {

        /**
         * generic Factory, has to be setup with a model to create instances from. A model is expected to have .refresh() method, to get data from the backend.
         * @param {function}    model           Constructor function. If instances.id exists dublicates will be prevented. 
         * @param {string}      [uniqueKey]     Key in raw data to check for dublicates with. (i.e. "instances.id")    
         */

        return function cmFactory(model, sameByData, sameByInstance){

            var self        = new Array();

            self.model      = model;

            cmObject.addEventHandlingTo(self);

            sameByData = sameByData || function(instance, data){
                return instance.id && data.id && instance.id == data.id
            };

            sameByInstance = sameByInstance || function(instance_1, instance_2){
                return instance_1.id && instance_1.id == instance_2.id
            };

            /**
             * Function to create an instance of this.model. If an instance with the same id as provided already exist, fetch it instead off creating a new one.
             * @param   {string|object}   args        instance id, data set including an instance id or data set without an id
             * @returns {model}                      allways returns an instance of model. If an id is present in args and an instance with that id already exists, 
             *                                      this instance will be returned – otherwise a new one will be created and if possible populated with data from the backend.
             */
            self.create = function(data, withNewImport){

                if(typeof data == 'string') 
                    data = {id: data}

                var instance = self.find(data);

                if(instance === null){
                    instance = self.new(data)
                    self.register(instance)

                } else if(typeof withNewImport === 'boolean' && withNewImport == true && typeof instance.importData == 'function'){
                    instance.importData(data);
                }


                return instance;

            };

            self.importFromDataArray = function(data_arr){
                data_arr.forEach(function(data){
                    self.create(data)
                })
                return self
            }

            self.exportDataArray = function(){
                return  self.map(function(instance){
                            return instance.exportData()
                        })
            }

            /**
             * Function to find and instance by its id.
             * @param   {string}         id          The id of the instance to find.
             * @returns {model|null}                 returns the first instance to match the id or null if none is found 
             */
            self.find = function(args){
                if(!args)
                    return null;

                if(typeof args == 'string')
                    args = {id: args}

                var matches = [];

                if(args instanceof this.model){
                    matches = self.filter(function(instance){ return sameByInstance(instance, args) })
                }else{
                    matches = self.filter(function(instance){ return sameByData(instance, args) })
                }

                return matches.length ? matches[0] : null       
            };

            /**
             * Function to create a new model instance. 
             * @param   {string|object}   args        instance id, data set including an instance id or data set without an id
             * @return  {cmModel}                    returns a new model instance populated with the provided data
             */
            self.new = function(args){
                var data     = typeof args == 'string' ? {id:args} : args,
                    instance = new self.model(data);

                // TODO: before init:ready in instance factory.echoEventsFrom(self); for observing before triggering
                //  - removed register and added it above in create()

                return instance
            };

            /**
             * Function to store a model instance for later use, retrievable by its id
             * @param {model}           instance    an instance of model
             */
            self.register = function(instance){
                if(
                    self.indexOf(instance) == -1
                    && instance instanceof this.model
                ){
                    self.push(instance);

                    self.echoEventsFrom(instance);

                    instance.deregister = function(){
                        self.deregister(instance)
                    };

                    self.trigger('register', instance);

                    return self.length
                }

                return false
            };

            /**
             * Function to remove a model instance
             * @param {model}           instance    an instance of model
             */
            self.deregister = function(args){
                var instance    = self.find(args),
                    index       = self.indexOf(instance)

                if(
                    index != -1
                    && instance instanceof this.model
                ){
                    self.splice(index, 1);
                    self.trigger('deregister');
                    return true
                }
                return false
            };

            /**
             * Function to remove all instances from the factory.
             * @returns @this    for chaining
             */
            self.reset = function(callFrom){
                //cmLogger.debug('cmFactory.reset -' + (callFrom ? ' Factory: ' + callFrom : '') + ' Elements: ' + self.length);
                while(self.length > 0){
                    self.pop()
                }

                return self;
            };


            /**
             * Event Handling
             */
            self.on('register', function(event, instance){
                if(typeof instance.trigger == 'function'){
                    instance.trigger('init:ready'); // Todo: dieses event sollte die instance eher selber triggern oder?
                }
            });

            return self
        }
    }
])

.factory('cmIdentityModel',[
    'cmAuth', 'cmCrypt', 'cmKey', 'cmKeyFactory', 'cmObject', 'cmLogger', 'cmApi',
    'cmFileFactory', 'cmStateManagement', 'cmUtil', 'cmNotify',
    '$injector',
    function(cmAuth, cmCrypt, cmKey, cmKeyFactory, cmObject, cmLogger, cmApi,
             cmFileFactory, cmStateManagement, cmUtil, cmNotify,
             $injector){

        function Identity(identity_data){

            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state  = new cmStateManagement(['new','decrypted','loading']);

            /**
             * Initialize Identity
             * @param {String|Object} data identity data for model
             * @returns {Message}
             */
            function init(data){
                self.clear();

                if(typeof data == 'string' && data.length > 0){
                    self.id = data;
                    self.load();
                } else if(typeof data == 'object' && ('id' in data)){
                    self.id = data.id;

                    if(cmUtil.objLen(data) < 2){
                        self.load();
                    } else {
                        self.importData(data);
                    }
                } else {
                    self.state.set('new');
                }

                self.trigger('init:finished');
            }

            /**
             * @param identity_data
             */
            this.importData = function(data){
                //cmLogger.debug('cmIdentityModel.importData', data);

                if(typeof data !== 'object'){
                    cmLogger.debug('cmIdentityModel:import:failed - no data!');
                    return this;
                }

                this.id                     = data.id           || this.id;
                this.displayName            = data.displayName  || this.displayName;
                this.userKey                = data.userKey      || this.userKey;
                this.cameoId                = data.cameoId      || this.cameoId;
                this.avatarId               = data.avatar       || this.avatarId;
                // TODO: hack for identity/edit update
                if(typeof data.email != 'string')
                    this.email              = data.email        || this.email;
                else
                    this.email              = {value:data.email};

                if(typeof data.phoneNumber != 'string')
                    this.phoneNumber        = data.phoneNumber  || this.phoneNumber;
                else
                    this.phoneNumber        = {value:data.phoneNumber};

                this.preferredMessageType   = data.preferredMessageType || this.preferredMessageType;
                this.userType               = data.userType             || this.userType;
                this.created                = data.created              || this.created;
                this.lastUpdated            = data.lastUpdated          || this.lastUpdated;
                this.isActive               = data.active               || this.isActive;

                data.publicKeys             = data.publicKeys           || [];

                data.publicKeys.forEach(function (publicKey_data) {
                    // first deleted event from BE
                    if('deleted' in publicKey_data && publicKey_data.deleted){
                        self.keys.deregister(publicKey_data);
                    } else {
                        var key =  self.keys.create(publicKey_data, true);

                        //check if the keyis working properly, if not, get rid of it:
                        if(!key.getPublicKey()){
                            self.keys.deregister(key)
                        }
                    }
                });

                this.state.unset('new');
                this.trigger('update:finished', this);

                return this;
            };

            this.exportData = function(){
                return {
                    id: this.id,
                    displayName: this.displayName,
                    userKey: this.userKey,
                    cameoId: this.cameoId,
                    avatarId: this.avatarId,
                    email: this.email,
                    phoneNumber: this.phoneNumber,
                    preferredMessageType: this.preferredMessageType,
                    userType: this.userType,
                    created: this.created,
                    lastUpdated: this.lastUpdated
                }
            };

            this.load = function(){
                if(typeof this.id == 'string'
                    && this.id.length > 0
                    && this.state.is('loading') === false) {

                    this.state.set('loading');

                    cmAuth.getIdentity(this.id).then(
                        function (import_data) {
                            if (typeof import_data == 'string') {
                                cmLogger.debug('cmAuth.getIdentity() should forward an object, got string instead. ')
                            } else {
                                self.importData(import_data);
                            }
                            self.state.unset('loading');
                        },
                        function(){
                            self.state.unset('loading');
                            self.trigger('load:failed');
                        }
                    );
                } else {
                    cmLogger.debug('cmIdentityModel:load:failed - no identityId');
                    this.trigger('load:failed');
                }

                return this;
            };

            this.update = function(changes){
//                cmLogger.debug('cmIdentityModel.update');
                if(typeof changes == 'object' && cmUtil.objLen(changes) > 0){
                    cmAuth.updateIdentity(changes).then(
                        function(){
                            self.importData(changes);
                        },
                        function(){
                            cmNotify.warn('IDENTITY.NOTIFY.UPDATE.ERROR',{ttl:0})
                        }
                    )
                }

                return this;
            };

            this.clear = function(){
                //cmLogger.debug('cmIdentityModel.clear');

                this.id                     = undefined;
                this.displayName            = undefined;
                this.userKey                = undefined;
                this.cameoId                = undefined;
                this.avatarId               = undefined;
                this.avatar                 = undefined;
                this.email                  = { value: undefined, isVerified: undefined };
                this.phoneNumber            = { value: undefined, isVerified: undefined };
                this.preferredMessageType   = undefined;
                this.keys                   = this.keys ? this.keys.reset() : new cmKeyFactory();
                this.userType               = undefined;
                this.created                = undefined;
                this.lastUpdated            = undefined;
            };

            this.getDisplayName = function(){
                var cameoId = this.cameoId || '',
                    name = '';

                if(this.userType != 'internal'){
                    name = this.displayName || this.email.value || this.phoneNumber.value ||  cameoId.split("@")[0] || this.id;
                } else {
                    name = this.displayName || cameoId.split("@")[0] || this.email.value || this.phoneNumber.value || this.id;
                }

                return name;
            };

            /**
             * get and cached avatar of identity
             *
             */
            this.getAvatar = function(){
                if(this.avatarId){
                    var file = cmFileFactory.create(this.avatarId);
                        file.downloadStart();

                    return file;
                }
                return false;
            };

            this.removeKey = function(key){
                key.removeFromKeyList(self.keys);
                return this;
            };

            this.getWeakestKeySize = function(){
                cmLogger.debug('identityModle:getWeakestKeySize() is deprecated; please use keys.getWeakestKeySize().')
                return this.keys.getWeakestKeySize()
                // return this.keys.reduce(function(size, key){                    
                //     return size == undefined ? key.getSize() : Math.min(size, key.getSize())
                // }, undefined)

            };

            this.hasKeys = function(){
                return (this.keys.length > 0);
            };

            this.getTrustedKeys = function(){
                return $injector.get('cmUserModel').verifyIdentityKeys(this, true).then(
                    function(trusted_keys){
                        return trusted_keys;
                    }
                )
            };

            init(identity_data);
        }

        return Identity;
    }
])
.factory('cmIdentityFactory',[
    '$rootScope',
    'cmFactory',
    'cmIdentityModel',
    function($rootScope, cmFactory, cmIdentityModel){

        var self = new cmFactory(cmIdentityModel);

        self.clear = function(args){
            var id = typeof args == 'object' && 'id' in args
                ?   args.id
                :   args;

            var instance = self.find(id);

            if(instance !== null && typeof instance.clear == 'function'){
                instance.clear();
            }

            return self;
        };

        $rootScope.$on('logout', function(){ self.reset() });

        $rootScope.$on('identity:switched', function(){ self.reset() });

        return self;
    }
])
.factory('cmKeyStorageService',[
    'cmUserModel',
    'cmUtil',
    'cmLogger',
    '$rootScope',
    function(cmUserModel, cmUtil, cmLogger, $rootScope) {
        function userKeyStorage(key){
            var self = this,
                storageKey = undefined;

            function init(key){
                //cmLogger.debug('cmUserKeyStorage.init');

                if(typeof key == 'string' && cmUtil.validateString(key)){
                    storageKey = key;
                } else {
                    throw new Error("cmUserKeyStorage init failed! Key is not a valid string!");
                }
            }

            function reset(){
                storageKey = undefined;
            }

            this.getAll = function(){
                return cmUserModel.storageGet(storageKey) || {};
            };

            this.get = function(key){
                //cmLogger.debug('cmUserKeyStorage.get');

                var list = this.getAll(),
                    value = undefined;

                if(typeof list == 'object' && Object.keys(list).indexOf(key)!= -1){
                    value = list[key];
                }

                return value;

            };

            this.set = function(key, value){
                //cmLogger.debug('cmUserKeyStorage.set');

                var list = this.getAll();

                list[key] = value;

                cmUserModel.storageSave(storageKey, list);
            };

            this.is = function(key){
                //cmLogger.debug('cmUserKeyStorage.is');

                var list = this.getAll(),
                    boolReturn = false;

                if(key != undefined && // key exists
                    cmUtil.checkKeyExists(list, key) && // is in properties
                    list[key])// and is true
                {
                    boolReturn = true;
                }

                return boolReturn;
            };

            $rootScope.$on('logout', function(){ reset() });

            $rootScope.$on('identity:switched', function(){ reset() });

            init(key);
        }

        return userKeyStorage;
    }
])
//Todo: This is not in use, ist it?
//This factory provides a generic Model


.factory('cmModel',[

    'cmObject',

    function(cmObject) {

        /**
         * generic Model
         */

        var cmModel = function(){
            this.state = {}

            cmObject
            .addEventHandlingTo(this)
            .addChainHandlingTo(this)

            this.setState = function(key, value){
                var old_value = this.state[state_name],
                    new_value = value

                this.state[state_name] = new_value
                this.trigger('state-change:'+key, {'old_value': old_value, 'new_value': new_value} )

                return this
            }

            /**
             * Function to update model with data from backend. This function is meant to be overwritten.
             */

            this.refresh = function(){
                return this
            }
        }

        return cmModel
    }

])
/**
 * @ngdoc object
 * @name cmStateManagement
 * @description
 * States Management Object<br />
 * Helper Object to set and unset different stats in objects
 *
 * @requires cmObject
 *
 * @todo check whitelist functionality
 */
.factory('cmStateManagement',[
    'cmObject',
    function(cmObject) {

        function cmStateManagement(whitelist){

            /**
             * @ngdoc property
             * @propertyOf cmStateManagement
             *
             * @name self
             * @description
             * Array to handle states in Methods
             *
             * @type {Array} self New states array
             */
            var self = new Array();

            cmObject.addEventHandlingTo(self);

            /**
             * @ngdoc method
             * @methodOf cmStateManagement
             *
             * @name set
             * @description
             * set a state if not exists
             *
             * @param {String} state Example 'new' or 'loading'
             */
            self.set = function(state){
                if(typeof state == 'string' && state.length > 0){
                    if(self.indexOf(state) == -1){
                        self.push(state);

                        self.trigger('change');
//                        self.trigger('set:' + state);
                    }
                }
                return self
            };

            /**
             * @ngdoc method
             * @methodOf cmStateManagement
             *
             * @name unset
             * @description
             * unset a state, remove from state Array
             *
             * @param {String} state Example 'new' or 'loading'
             */
            self.unset = function(state){
                if(typeof state == 'string' && state.length > 0) {
                    if (self.indexOf(state) != -1) {
                        self.splice(self.indexOf(state), 1);

                        self.trigger('change');
//                        self.trigger('unset:' + state);
                    }
                }
                return self
            };

            /**
             * @ngdoc method
             * @methodOf cmStateManagement
             *
             * @name is
             * @description
             * check if a state is in states array
             * return boolean
             *
             * @param {String} state Example 'new' or 'loading'
             * @returns {Boolean} bool Indicator if state exists in states array
             */
            self.is = function(state){
                if(typeof state == 'string' && state.length > 0) {
                    return self.indexOf(state) != -1;
                }
                return false;
            };

            return self;
        }

        return cmStateManagement;
    }
])

.factory('cmTransferScopeData',[
    'cmUtil',
    '$location', '$rootScope',
    function(cmUtil,
             $location, $rootScope) {

        var keepIdsClear = [],
            scopeData = {},
            noneScopeData = {},
            defaultOptions = {
                id: '',
                scopeVar: '',
                ignoreVar: '',
                isDone: false,
                onSet: function(){},
                onGet: function(scopeData, privateData){}
            };

        // set the formData of outfilled inputs
        function _set($scope, options){
            if(options.isDone)
                return false;

            _clear(options);

            // if in keepClear array ignore set
            if(keepIdsClear.indexOf(options.id) >= 0){
                // remove for next time settable
                keepIdsClear.splice(keepIdsClear.indexOf(options.id), 1);
                return false;
            }

            options.onSet();

            scopeData[options.id] = $scope[options.scopeVar];

            if (options.noneScopeData != undefined) {
                noneScopeData[options.id] = options.noneScopeData;
            }

            // clear data exp.: password
            if (options.ignoreVar != '') {
                delete scopeData[options.id][options.ignoreVar];
            }
        }

        // get only on same route and if formData is full of data
        function _get($scope, options){
            if ((options.id in scopeData) && scopeData[options.id] != null) {
                if(typeof $scope[options.scopeVar] == 'object'){
                    $scope[options.scopeVar] = angular.extend({}, $scope[options.scopeVar], scopeData[options.id]);
                } else {
                    $scope[options.scopeVar] = scopeData[options.id];
                }
                options.onGet(scopeData[options.id], noneScopeData[options.id]);
                _reset(options);
            // when only noneScopeData is full data
            } else if(noneScopeData[options.id] != null){
                options.onGet({}, noneScopeData[options.id]);
                _reset(options);
            }
        }

        // reset persist data
        function _clear(options){
            delete scopeData[options.id];
            scopeData[options.id] = null;
            delete noneScopeData[options.id];
            noneScopeData[options.id] = null;
        }

        function _reset(){
            scopeData = {};
            noneScopeData = {};
        }

        $rootScope.$on('logout', _reset);

        return {
            create: function ($scope, _options_) {
                if ($scope == undefined)
                    return false;

                var options = angular.extend({}, defaultOptions, _options_ || {});
                // init
                var clearEvent = $rootScope.$on('$locationChangeStart', function () {
                    _set($scope, options);
                });

                _get($scope, options);

                $scope.$on('$destroy',function(){
                    clearEvent();
                });

                // return clear function
                return function(){
                    options.isDone = true;
                    clearEvent();
                    _clear(options);
                }
            },
            keepClear: function(data){
                this.clear(data);

                if(keepIdsClear.indexOf(data.id) < 0)
                    keepIdsClear.push(data.id);
            },
            clear: function(data){
                if(typeof data == 'object' && typeof data.id != 'undefined' && data.id != ''){
                    _clear(data);
                }
            },
            reset: function(){
                _reset();
            }
        }
    }]
)

.factory('$navigator', [
    function() {
        return typeof navigator != 'undefined' ? navigator : 'undefined';
    }
])

.factory('cmChunk', [
    'cmFilesAdapter', 'cmLogger', 'cmCrypt', 'cmObject', 'cmUtil',
    '$q',
    function (cmFilesAdapter, cmLogger, cmCrypt, cmObject, cmUtil,
              $q){

        function str2ab_blobreader(str, callback) {

            var blob;
            var BlobBuilder = window.MozBlobBuilder || window.WebKitBlobBuilder || window.BlobBuilder;
            if(typeof str == 'object'){
                blob = str;
            } else if (typeof BlobBuilder !== 'undefined') {
                var bb = cmFilesAdapter.blobBuilderWrap();
                bb.append(str);
                blob = bb.getBlob();
            } else {
                blob = cmFilesAdapter.blobWrap([str], undefined, 'str2ab_blobreader');
            }
            var f = new FileReader();
            f.onload = function(e) {
                callback(e.target.result)
            };
            f.readAsArrayBuffer(blob);
        }

        return function Chunk(file, start, end){

            cmObject.addEventHandlingTo(this);

            var self = this,
                isReady = $q.defer();

            this.raw = undefined;
            this.blob = undefined;
            this.plain = undefined;
            this.encryptedRaw = undefined;

            this.isReady = function(callback){
                isReady.promise.then(function(){
                    if(callback){
                        callback(self);
                    }
                });

                return isReady.promise;
            };

            this.importFileSlice = function (file, start, end){
                var slicer  = file.webkitSlice || file.mozSlice || file.slice,
                    chunk   = slicer.call(file, start, end)

                if (file.webkitSlice) { // android default browser in version 4.0.4 has webkitSlice instead of slice()
                    str2ab_blobreader(chunk, function(buf) { // we cannot send a blob, because body payload will be empty
                        chunk = buf
                    });
                }

                this.blob = chunk;
                this.size = end-start;

                return this
            };

            this.blobToBase64 = function(){
                var self = this,
                    promise = null;

                this.blob
                    ?   cmFilesAdapter.getBlobUrl(this.blob).then(function(objUrl){
                            self.raw = objUrl.src;
                            isReady.resolve();
                        })
                    :   cmLogger.debug('Unable to convert to file; this.blob is empty.');
                return this;
            };

            this.blobToBinaryString = function(){
                var self     = this,
                    reader   = new FileReader(),
                    deferred = $q.defer();

                reader.onload = function(event){
                    self.raw = event.target.result.replace('data:application/octet-stream;base64,', '');
                    deferred.resolve(self.raw)
                };

                this.blob
                    ?   reader.readAsBinaryString(this.blob)
                    :   cmLogger.debug('Unable ro convert to raw; chunk.blob is empty.  Try calling chunk.importFileSlice() first.');

                return deferred.promise;

            };

            this.encrypt = function(passphrase) {
                if(passphrase == null){
                    this.plain = this.raw;
                } else {
                    this.encryptedRaw = cmCrypt.encrypt(passphrase, this.raw);
                }

                return this;
            };

            this.upload = function(id, index){
                if(this.plain){
                    return cmFilesAdapter.addChunk(id, index, this.plain)
                } else if(this.encryptedRaw){
                    return cmFilesAdapter.addChunk(id, index, this.encryptedRaw)
                } else {
                    cmLogger.debug('Unable to upload; chunk.plain or chunk.encryptedRaw is empty. Try calling chunk.encrypt() first.')
                }
            };

            this.download = function(id, index){
                var self = this;

                this.raw = undefined;
                this.blob  = undefined;

                return cmFilesAdapter.getChunk(id, index).then(
                    function(data){
                        return self.encryptedRaw = data
                    }
                )
            };

            /**
             * @param passphrase
             * @returns {Chunk}
             */
            this.decrypt = function(passphrase){
                this.encryptedRaw
                    ?   this.raw = cmCrypt.decrypt(passphrase, this.encryptedRaw) || this.encryptedRaw
                    :   cmLogger.debug('Unable to decrypt; chunk.encryptedRaw is empty. Try calling chunk.download() first.');
                return this;
            };

            this.binaryStringToBlob = function(){
                this.raw
                    ?   this.blob = cmFilesAdapter.binaryToBlob(this.raw)
                    :   cmLogger.debug('Unable to convert to Blob; chunk.raw is empty. Try calling chunk.decrypt() first.');
                return this;
            };
        }
    }
])

.factory('cmFileFactory', [
    'cmFileModel',
    '$rootScope',
    function(cmFileModel, $rootScope){
        var instances = [];

        $rootScope.$on('logout', function(){
            instances = [];
        });

        $rootScope.$on('identity:switched', function(){
            instances = [];
        });

        return {
            create: function(data, explicit){
                var file = null,
                    i = 0;

                if(typeof explicit === 'undefined'){
                    explicit = false;
                }

                if(explicit !== true) {
                    // existing via id
                    if (typeof data == 'string') {
                        while (i < instances.length) {
                            if (typeof instances[i] === 'object' &&
                                instances[i].id == data) {
                                file = instances[i];
                                break;
                            }

                            i++;
                        }
                        //
                    } else if (typeof data == 'object') {
                        while (i < instances.length) {
                            if (typeof instances[i] === 'object' &&
                                instances[i].id == data.id) {
                                file = instances[i];
                                break;
                            }

                            i++;
                        }
                    }
                }
                // create model
                if(file == null){
                    file = new cmFileModel(data);
                    instances.push(file);
                }

                return file;
            },
            remove: function(file){
                var bool = false;

                var index = instances.indexOf(file);

                if(index != -1) {
                    instances.splice(index, 1);
                    bool = true;
                }

                return bool;
            },
            getQty: function(){
                return instances.length;
            }
        }
    }
])

.factory('cmFileModel', [
    'cmFilesAdapter', 'cmFileDownload', 'cmFileTypes', 'cmLogger', 'cmChunk',
    'cmCrypt', 'cmObject', 'cmModal', 'cmEnv', 'cmUtil', 'cmDeviceDownload',
    'cmStateManagement',
    '$q',
    function (cmFilesAdapter, cmFileDownload, cmFileTypes, cmLogger, cmChunk,
              cmCrypt, cmObject, cmModal, cmEnv, cmUtil, cmDeviceDownload,
              cmStateManagement,
              $q){

        function roundToTwo(num) {
            return +(Math.round(num + 'e+2') + 'e-2');
        }

        var FileModel = function(fileData){

            var self = this,
                passphrase = undefined;

            cmObject.addEventHandlingTo(this);

            this.state  = new cmStateManagement(['new','onlyFileId','readyForDownload','cached','crashed','incomplete']);

            this.chunks = [];

            this.name = '';
            this.encryptedName = '';
            this.encryptedSize = 0;
            this.size = 0;

            this.base64 = '';
            this.onCompleteId = undefined;
            this.detectedExtension = undefined;
            this.autoDownload = false;

            this.setPassphrase = function(p){
                passphrase = p;// TODO: || null;
                return this;
            };

            this.isImage = function(){
                return this.type == undefined
                     ? false
                     : this.type.search('^image/') != -1
                       && this.type.search('tiff') == -1;
            };

            this.isEmbed = function(specificMime){
                return this.type == undefined
                     ? false
                     : this.type.search('^('+(specificMime||'image|video|audio')+')') != -1
                       && this.type.search('tiff') == -1;
            };

            // message id for backend event message:new
            this.setOnCompleteId = function(id){
                this.onCompleteId = id;

                return this;
            };

            this.importBase64 = function(base64){
                if(base64){
                    this.type = cmFilesAdapter.getMimeTypeOfBase64(base64);
                    this.blob = cmFilesAdapter.binaryToBlob(cmFilesAdapter.base64ToBinary(base64),this.type);
                    this.chopIntoChunks(128);
                }
                return this;
            };

            // for fileApi of browser -> upload
            this.importBlob = function(blob){
                this.blob = blob;
                this.id   = undefined;

                this.name = blob.name;
                this.type = blob.type;
                this.size = blob.size;

                this.detectedExtension = cmFileTypes.find(this.type, this.name);

                // broken mimetype???
                if (this.detectedExtension == 'unknown') {
                    var obj = cmFileTypes.getMimeTypeViaFilename(this.name);
                    if (obj.detectedExtension != 'unknown') {
                        this.detectedExtension = obj.detectedExtension;
                        this.type = obj.mimeType;
                    }
                }

                return this;
            };

            this.importFile = function(){
                var self = this;

                return cmFilesAdapter.getFile(this.id).then(
                    function(details){
                        self.encryptedName = details.fileName;
                        self.type          = details.fileType;
                        self.size          = details.fileSize;
                        self.chunkIndices  = details.chunks;
                        self.maxChunks     = details.maxChunks;

                        self.decryptName();

                        self.detectedExtension = cmFileTypes.find(self.type, self.name);

                        // is file complete of chunks?
                        if(details.isCompleted) {
                            self.state.unset('incomplete');
                            self.trigger('importFile:finish',self);
                        } else {
                            self.state.set('incomplete');
                            self.trigger('importFile:incomplete',self);
                        }
                    },
                    function(){
                        self.state.unset('onlyFileId');
                        self.state.set('crashed');
                        self.trigger('file:crashed');
                    }
                );
            };

            this.chopIntoChunks = function(chunkSize){
                var self        = this,
                    startByte   = 0,
                    endByte     = 0,
                    index       = 0,
                    promises    = [];

                if(!this.blob) {
                    cmLogger.debug('Unable to chop file into Chunks; cmFile.blob missing.');
                    return null;
                }

                self.chunks   = [];

                while(endByte < this.blob.size) {

                    startByte = index * 1024 * chunkSize;
                    endByte = startByte + 1024 * chunkSize;

                    endByte = (endByte > this.blob.size) ? this.blob.size : endByte;

                    var chunk = new cmChunk();
                    self.chunks.push(chunk);

                    promises.push(
                        chunk
                            .importFileSlice(self.blob, startByte, endByte)
                            .blobToBase64()
                    );

                    index++;
                }

                return $q.all(promises);
            };

            this.encryptName = function(){
                if(this.name){
                    this.encryptedName = (passphrase == null) ? this.name : cmCrypt.encryptWithShortKey(passphrase, this.name);
                } else {
                    cmLogger.debug('Unable to encrypt filename; cmFile.name missing. Try calling cmFile.importFile() first.');
                }

                return this;
            };

            this.decryptName = function() {
                if(!passphrase){
                    this.name = this.encryptedName;
                } else if(this.encryptedName && passphrase){
                    this.name = cmCrypt.decrypt(passphrase, this.encryptedName);
                } else {
                    cmLogger.debug('Unable to decrypt filename; cmFile.encryptedFileName missing. Try calling cmFile.imporByFile) first.');
                }
                return this;
            };

            this._encryptChunk = function(index){
                var chunk = this.chunks[index];

                chunk.encrypt(passphrase);
                this.encryptedSize += chunk.encryptedRaw.length;

                if(index == (this.chunks.length - 1)){
                    this.trigger('encrypt:finish');
                } else {
                    this.trigger('encrypt:chunk', index);
                }
            };

            this.encryptChunks = function() {
                if(this.chunks){
                    this._encryptChunk(0);
                } else {
                    cmLogger.debug('Unable to encrypt chunks; cmFile.chunks missing. Try calling cmFile.chopIntoChunks() first.');
                }

                return this;
            };

            this._decryptChunk = function(index){
                var chunk = this.chunks[index];

                chunk
                    .decrypt(passphrase)

                this.encryptedSize += String(chunk.encryptedRaw).length;
                //this.size += chunk.blob.size;

                if(index == (this.chunkIndices.length - 1)){
                    this.trigger('decrypt:finish');
                } else {
                    this.trigger('decrypt:chunk', index);
                }
            };

            this.decryptChunks = function(){
                if(!this.chunks){
                    cmLogger.debug('Unable to decrypt chunks; cmFile.chunks missing. Try calling cmFile.downloadChunks() first.');
                    return null
                }

                this._decryptChunk(0);

                return this;
            };

            this.decryptStart = function(){
                this.decryptChunks();
            };

            this.reassembleChunks = function(){
                var self = this,
                    binary = '',
                    byteArray = [];

                if(!this.chunks)
                    cmLogger.debug('Unable reassemble chunks; cmFile.chunks missing. Try calling cmFile.downloadChunks() first.');

                this.chunks.forEach(function(chunk){
                    try{
                        binary+= cmFilesAdapter.base64ToBinary(chunk.raw);
                    } catch(e){
                        cmLogger.debug('FileModel Chunk Error',e);
                    }
                });

                this.blob = cmFilesAdapter.binaryToBlob(binary, self.type);

                self.trigger('file:cached', this);

                return this;
            };

            this.prepareForUpload = function(conversationId) {
                var self = this;

                return (
                        self.encryptedName && self.chunks || self.name && self.chunks
                    ?   cmFilesAdapter.prepareFile({
                            conversationId: conversationId,
                            name: self.encryptedName || self.name,
                            size: self.blob.size,//self.encryptedSize,
                            type: self.type,
                            chunks: self.chunks.length
                        })
                        .then(function(id){
                            return self.id = id;
                        })
                    :   cmLogger.debug('Unable to set up file for Download; cmFile.chunks or cmFile.encryptedName missing. Try calling cmFile.chopIntoChunks() and cmFile.encryptName() first.')
                )
            };

            this._uploadChunk = function(index){
                // waiting for chunk sliceing and blob to base64
                this.chunks[index].isReady(function(chunk){
                    chunk
                        .encrypt(passphrase)
                        .upload(self.id, index)
                        .then(function(){
                            self.trigger('progress:chunk', (index/self.chunks.length));

                            if(index == (self.chunks.length - 1)){
                                cmFilesAdapter.setFileComplete(self.id, self.onCompleteId).then(function(){
                                    self.state.set('complete');
                                    self.trigger('upload:finish');
                                });
                            } else {
                                self.trigger('upload:chunk', index);
                            }
                        });
                });
            };

            this.uploadChunks = function() {
                if(!this.id){
                    cmLogger.debug('Unable to upload chunks; cmFile.id missing. Try calling cmFile.prepareForDownload() first.')
                    return null;
                }

                /**
                 * start upload with first chunk in array
                 */
                this.state.set('onUpload');
                this._uploadChunk(0);

                return this;
            };

            this._downloadChunk = function(index){
                var chunk = new cmChunk();

                if(self.chunks == null) {
                    cmLogger.error('_downloadChunk:'+index+' download failed because of self.chunks = null');
                    self.trigger('progress:chunk', 1);
                    self.trigger('download:finish', {'error':true});
                    self.trigger('file:cached');
                    return false;
                }

                self.chunks[index] = chunk;

                chunk
                    .download(self.id, index)
                    .then(
                    function(){
                        if(self.chunks != null){
                            self.trigger('progress:chunk', (index/self.chunks.length));
                        }

                        if(index == (self.chunkIndices.length - 1)){
                            self.trigger('download:finish', index);
                        } else {
                            self.trigger('download:chunk', index);
                        }
                    },
                    function(){
                        self.trigger('progress:chunk', 1);
                        self.trigger('download:finish', {'error':true});
                        self.trigger('file:cached');
                    }
                );
            };

            this.downloadChunks = function(){
                //cmLogger.debug('cmFileModel:downloadChunks '+this.id);
                // only crashed when fileId is missing
                if(!this.id && this.state.is('onlyFileId')){
//                    cmLogger.debug('cmFile.downloadChunks();')
                    return null;
                }

                this.importFile();

                this.on('importFile:finish',function(){
                    self.state.unset('onlyFileId');
                    self.state.set('readyForDownload');
                    self.trigger('file:readyForDownload');
                    // autoDownload 'passcaptcha has always true'
                    if(self.autoDownload){
                        self.startDownloadChunks();
                    }
                });

                return this;
            };

            this.startDownloadChunks = function(){
                if(!self.state.is('onDownload') && !self.state.is('onUpload')){
                    self.state.unset('readyForDownload');
                    self.state.set('onDownload');
                    self._downloadChunk(0);
                }
            };

            this.downloadStart = function(autoDownload){
                //cmLogger.debug('cmFileModel:downloadStart');
                // handle straight autodownload
                this.autoDownload = autoDownload || this.autoDownload;

                if(this.id != '' && this.state.is('onlyFileId')){
                    cmFileDownload.add(this);
                }
            };

            this.downloadStop = function(){
                cmFileDownload.stop(this);
            };

            this.promptSaveAs = function(){
                try {
                    var isFileSaverSupported = !!new Blob;
                } catch (e) {
                    cmLogger.debug('Unable to prompt saveAs; FileSaver is\'nt supported');
                    return false;
                }

                var downloadAttrSupported = ( "download" in document.createElement("a") ),
                    iOSWorkingMimeTypes = ( this.type.match(/(application\/pdf)/g) ? true : false );

                if(cmEnv.isiOS && !downloadAttrSupported && !iOSWorkingMimeTypes){
                    cmModal.create({
                        id:'saveas',
                        type: 'alert'
                    },'<span ng-bind-html="::\'NOTIFICATIONS.TYPES.SAVE_AS.IOS_NOT_SUPPORT\'|cmParse"></span>');
                    cmModal.open('saveas');
                } else {
                    // phonegap download
                    if(cmDeviceDownload.isSupported()) {
                        cmDeviceDownload.saveAs(this);
                    // browser download
                    } else if(this.blob){
                        saveAs(this.blob, this.name != false ? this.name : 'download');
                    } else {
                        cmLogger.debug('Unable to prompt saveAs; cmFile.blob is missing, try cmFile.importByFile().');
                    }
                }
                return this;
            };

            this.hasBlob = function(){
                if(this.blob !== 'undefined'){
                    return true;
                }

                return false;
            };

            /**
             * keep the buffer clean when file is cached
             * @returns {FileModel}
             */
            this.clearBuffer = function(){
                if(this.state.is('cached')) {
                    this.encryptedName = null;
                    this.chunkIndices = null;
                    this.chunks = null;
                    passphrase = undefined;
                }

                return this;
            };

            /**
             *
             * @param fileData
             * @param chunkSize
             * @returns {FileModel}
             */
            this.init = function(fileData, chunkSize){
                var self = this;

                if(typeof fileData !== 'undefined'){
                    // download: existing file via fileId
                    if(typeof fileData == 'string'){
                        this.state.set('onlyFileId');
                        this.id = fileData;

                    // upload init via via base64
                    } else if(typeof fileData == 'object') {
                        this.state.set('new');
                        this.importBlob(fileData);

                        if (!chunkSize) {
                            chunkSize = 128;
                        }

                        self.chopIntoChunks(chunkSize);
                    }
                }

                return this;
            };

            this.init(fileData);

            /**
             * Event Handling
             */
            this.on('download:chunk', function(event, index){
                self._downloadChunk(index + 1);
                self._decryptChunk(index);
            });

            this.on('download:finish', function(event, index){
//                cmLogger.debug('download:finish');
                if(typeof index == 'number') {
                    self._decryptChunk(index);
                    // error on download
                } else if(index.error) {
                    //cmLogger.warn('chunk not found');
                    self.state.set('cached');
                    self.state.unset('onDownload');
                }
            });

            this.on('upload:chunk', function(event, index){
                self._uploadChunk(index + 1);
            });

            this.on('upload:finish', function(){
//                cmLogger.debug('upload:finish');
                self.state.set('cached');
                self.state.unset('onUpload');
            });

            this.on('encrypt:chunk', function(event, index){
//                cmLogger.debug('encrypt:chunk');
                self._encryptChunk(index + 1);
            });

            this.on('decrypt:chunk', function(event, index){
//                cmLogger.debug('decrypt:chunk '+index);
//                self._decryptChunk(index + 1);
//                self._downloadChunk(index + 1);
            });

            this.on('decrypt:finish', function(event, index){
//                cmLogger.debug('decrypt:finish');
                self.reassembleChunks();
            });

            this.on('file:cached', function(){
//                cmLogger.debug('file:cached');
                self.state.set('cached');
                self.state.unset('onDownload');

                self
                    .decryptName()
                    .clearBuffer()

                self.detectedExtension = cmFileTypes.find(self.type, self.name);
            });
        };

        return FileModel;
    }
])

.service('cmFileDownload', [
    'cmLogger',
    '$rootScope',
    function(cmLogger, $rootScope){
        var self = this;

        this.stack = [];
        this.atWork = false;

        function reset(){
            self.atWork = false;
            self.stack = [];
            self.stop();
        }

        $rootScope.$on('logout', function(){
            reset();
        });

        $rootScope.$on('identity:switched', function(){
            reset();
        });

        /**
         * add cmFileObject to Stack
         * @param file
         */
        this.add = function(file){
            if(typeof file == 'object'){
                this.stack.push(file);

                if(this.atWork !== true){
                    this.atWork = true;
                    this.run(this.stack.shift());
                }
            }
        };

        /**
         * work on stack queue, start download process in files
         * @param index
         */
        this.run = function(file){
            if(typeof file == 'object' && file.state.is('onlyFileId')){
                file.downloadChunks();

                file.on('file:readyForDownload file:crashed file:cached importFile:incomplete', function(){
                    self.run(self.stack.shift());
                });
            } else {
                if(this.stack.length == 0) {
                    this.atWork = false;
                } else {
                    this.run(this.stack.shift());
                }
            }
        };

        /**
         * Stops Downloading
         */
        this.stop = function(file){
            var index = this.stack.indexOf(file);
            if(index > -1){
                this.stack.splice(index, 1);
            }
        };

        /**
         * Return Stack Quantity
         * @returns {Array}
         */
        this.getQty = function(){
            return this.stack.length;
        };
    }
])
.service('cmFileTypes',[
    function(){
        /**
         * e: extension
         * m: mimeType
         * @type {*[]}
         */
        var fileMimeTypes = [
            // image
            {e:'jpg,jpeg,jpe',m:'image/jpeg'},
            {e:'gif',m:'image/gif'},
            {e:'bmp',m:'image/bmp'},
            {e:'png',m:'image/png'},
            {e:'tif,tiff',m:'image/tiff'},
            // video
            {e:'mov',m:'video/quicktime'},
            {e:'mpg,mpa,mp2,mpe,mpeg',m:'video/mpeg'},
            {e:'mp4',m:'video/mp4'},
            {e:'flv',m:'video/x-flv'},
            {e:'avi',m:'video/x-msvideo'},
            // audio
            {e:'mp3',m:'audio/mpeg'},
            {e:'mp3',m:'audio/mp3'},
            {e:'wav',m:'audio/x-wav'},
            {e:'wma',m:'audio/x-ms-wma'},
            {e:'aif,aiff,aifc',m:'audio/x-aiff'},
            {e:'ogg',m:'audio/ogg'},
            {e:'3gpp',m:'video/3gpp'},
            {e:'aac',m:'audio/x-aac'},
            // docs
            {e:'pdf',m:'application/pdf'},
            {e:'txt',m:'text/plain'},
            {e:'xls,xlsx',m:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'},
            {e:'xls',m:'application/vnd.ms-excel'},
            {e:'doc',m:'application/msword'},
            {e:'docx,doc',m:'application/vnd.openxmlformats-officedocument.wordprocessingml.document'},
            {e:'pps,ppt',m:'application/vnd.ms-powerpoint'},
            {e:'pptx',m:'application/vnd.openxmlformats-officedocument.presentationml.presentation'},
            // various
            {e:'php',m:'text/php'},
            {e:'css',m:'text/css'},
            {e:'zip',m:'application/zip'},
            {e:'zip',m:'application/x-zip-compressed'},
            {e:'rar',m:'application/x-rar-compressed'},
            {e:'sit',m:'application/x-stuffit'},
            {e:'eps',m:'application/postscript'},
            {e:'xml',m:'application/xml'},
            {e:'html,htm',m:'text/html'},
            {e:'chm',m:'application/vnd.ms-htmlhelp'},
            {e:'ttf',m:'application/x-font-ttf'},
            //{e:'exe',m:'application/octet-stream'},
            {e:'exe',m:'application/x-msdownload'},
            {e:'dmg',m:'application/x-apple-diskimage'},
            {e:'apk',m:'application/vnd.android.package-archive'}
        ],
        unknown = 'unknown';

        return {
            find: function(mime, filename){
                var self = this,
                    detectedExtension = unknown;
                // search for mimetype
                if(mime != undefined) {
                    angular.forEach(fileMimeTypes, function (type) {
                        if (mime != '' && type.m == mime) {
                            detectedExtension = self.getExtension(type.e, filename);
                        }
                    });
                }

                return detectedExtension;
            },

            findMimeType: function(detectedExtension){
                var mimeType = unknown;

                angular.forEach(fileMimeTypes, function (type) {
                    var findMime = type.e.split(',').filter(function(arrayExtension){
                        return arrayExtension == detectedExtension
                    });
                    if(findMime.length == 1)
                        mimeType = type.m;
                });

                return mimeType;
            },

            getMimeTypeViaFilename: function(filename){
                var arr_filename = filename && typeof filename == 'string' ? filename.split('.') : [],
                    extension = arr_filename.length > 1 ? arr_filename[arr_filename.length-1] : '',
                    detectedExtension = unknown,
                    mimeType = unknown;

                if(extension != ''){
                    detectedExtension = this.getExtension(extension, filename);
                    mimeType = this.findMimeType(detectedExtension);
                }

                return {
                    detectedExtension: detectedExtension,
                    mimeType: mimeType
                }
            },

            getExtension: function(extensions, filename){
                var extension = unknown,
                    extensions = extensions && typeof extensions == 'string' ? extensions.split(',') : [],
                    clearFilename = filename && typeof filename == 'string' ? filename.toLowerCase() : undefined;

                // no extensions exists
                if(!extensions || extensions == '')
                    return extension;

                // check filename
                if(clearFilename == undefined // no filename given
                || clearFilename == '' // filen is empty
                || clearFilename.split('.').length == 1 // filename has no extension
                ){
                    extension = extensions[0];
                } else {
                    angular.forEach(extensions, function (inExtension) {
                        if (clearFilename.search(inExtension+'$') != -1) {
                            extension = inExtension;
                        }
                    })
                }

                return extension;
            }
        }
    }
])
.service('cmFilesAdapter', [
    'cmApi', 'cmLogger', 'cmUtil', 'cmDevice',
    '$q',
    function (cmApi, cmLogger, cmUtil, cmDevice,
              $q){
        return {
            prepareFile: function(config){
                return cmApi.post({
                    path: '/file',
                    exp_ok: 'id',
                    headers: {
                        "X-File-Name": config.name,
                        "X-File-Size": config.size,
                        "X-File-Type": config.type,
                        "X-Max-Chunks": config.chunks
                    }
                });
            },

            addChunk: function(fileId, index, chunk) {
                return cmApi.postBinary({
                    path: '/file/'+fileId,
                    data: chunk,
                    headers: {
                        "X-Index": index
                    },
                    transformRequest: function(data){return data}
                });
            },

            setFileComplete: function(fileId, messageId){
                var data = 'null';
                if(messageId != undefined){
                    data = {
                        messageId: messageId
                    }
                }
                return cmApi.post({
                    path: '/file/'+fileId+'/completed',
                    data: data
                });
            },

            getFile: function(fileId){
                return cmApi.get({
                    path: '/file/'+fileId
                });
            },

            getChunk: function(fileId, chunkId){
                return cmApi.getBinary({
                    path: '/file/'+fileId+'/'+chunkId
                });
            },

            blobWrap: function(byteArrays, contentType, method){
                if(byteArrays == undefined || byteArrays == null)
                    return false;

                var blob = undefined;

                try {
                    blob = new Blob([byteArrays[0].buffer], {type: contentType});
                } catch(e){
                    // TypeError old chrome and FF
                    window.BlobBuilder =    window.BlobBuilder ||
                                            window.WebKitBlobBuilder ||
                                            window.MozBlobBuilder ||
                                            window.MSBlobBuilder;

                    // is already a blob!
                    if(byteArrays.toString() == '[object Blob]'){
                        blob = byteArrays;
                    } else if(e.name == 'TypeError' && window.BlobBuilder){
                        var bb = new BlobBuilder();
                        bb.append(byteArrays[0].buffer);
                        blob = bb.getBlob(contentType);
                    } else if(e.name == "InvalidStateError"){
                        // InvalidStateError (tested on FF13 WinXP)
                        blob = new Blob( byteArrays, {type : contentType});
                    } else {
                        cmLogger.debug('We\'re screwed, blob constructor unsupported entirely');
                        console.log(e, byteArrays, 'from method: '+method);
                    }
                }
                return blob;
            },

            blobBuilderWrap: function(){
                if(typeof(BlobBuilder) === 'undefined')
                    return false;

                var blobBuilder = new BlobBuilder();
                return blobBuilder;
            },

            base64ToBinary: function(b64Data){
                if(typeof b64Data != 'string')
                    return '';

                return atob(this.clearBase64(b64Data));
            },

            binaryToBlob: function (binary, contentType){
                if(typeof binary != 'string' || binary == '')
                    return false;

                var byteArrays = [],
                    binary = binary || '',
                    contentType = contentType || '',
                    sliceSize = binary.length;

                for (var offset = 0; offset < binary.length; offset += sliceSize) {
                    var slice = binary.slice(offset, offset + sliceSize);

                    var byteNumbers = new Array(slice.length);
                    for (var i = 0; i < slice.length; i++) {
                        byteNumbers[i] = slice.charCodeAt(i);
                    }

                    var byteArray = new Uint8Array(byteNumbers);

                    byteArrays.push(byteArray);
                }

                var blob = this.blobWrap(byteArrays, contentType, 'binaryToBlob');
                return blob;
            },

            base64ToBlob: function(base64, contentType){
                if(typeof base64 != 'string' || base64 == '')
                    return false;
                // check mimetype from base64
                if(!contentType){
                    var mimeType = this.getMimeTypeOfBase64(base64);
                    if(mimeType != ''){
                        contentType = mimeType;
                    }
                }
                // decode and create blob
                var binary = this.base64ToBinary(base64, contentType),
                    blob = this.binaryToBlob(binary, contentType);
                return blob;
            },

            /**
             * return clear base64 for atob function
             * replace newlines & return
             * replace the "data:;base64," mimetype
             * @param b64Data
             * @returns {String} clearBase64
             */
            //base64Regexp: '^(data:(.{0,100});base64,|data:(.{0,100})base64,)(.*)$',
            base64Regexp: '^(data:(.*?);?base64,)(.*)$',

            clearBase64: function(b64Data){
                if(typeof b64Data != 'string')
                    return '';

                var clearBase64 = b64Data
                .replace(/\r?\n|\r| /g,'')
                .replace(new RegExp(this.base64Regexp,'i'),function(){
                    return arguments[3];// return the cleared base64
                });

                //console.log(clearBase64)

                return clearBase64;
            },

            getMimeTypeOfBase64: function(base64){
                return base64 && typeof base64 == 'string' ? base64.replace(new RegExp(this.base64Regexp,'i'),'$2') : '';
            },

            getBlobUrl: function(blob, useBlobUrl){
                var useFileReader = useBlobUrl ? false : true,
                    revokeFnc = function(){
                        this.src = '';
                        return true;
                    },
                    deferred = $q.defer(),
                    objUrl = {
                        src: '',
                        revoke: revokeFnc
                    };

                // for app android use the localurl
                // TODO: optimize overall useBlobUrl and on Android localURL only at pick file preview
                if(cmDevice.isAndroid() && 'useLocalUri' in blob){
                    deferred.resolve({
                        src: blob.localURL,
                        revoke: revokeFnc
                    });
                } else
                // filereader return base64
                if(useFileReader){
                    var filereader = new FileReader();
                    filereader.onload = function(e){
                        objUrl.src = e.target.result;
                        deferred.resolve(objUrl);
                    };
                    filereader.readAsDataURL(blob);
                // bloburl returns a url to a blob
                } else {
                    var URL = window.URL || window.webkitURL;
                    objUrl = {
                        src: URL.createObjectURL(blob),
                        revoke: function(){
                            URL.revokeObjectURL(this.src);
                            this.src = '';
                            return true;
                        }
                    };
                    deferred.resolve(objUrl);
                }

                return deferred.promise;
            }
        }
    }
])

.factory('cmKeyFactory', [
    'cmKey',
    'cmFactory',
    'cmObject',
    'cmLogger',
    '$rootScope',
    '$q',
    function(cmKey, cmFactory, cmObject, cmLogger, $rootScope, $q){

        function keyFactory(){

            var self =  new cmFactory(cmKey,
                                function sameByData(instance, data){
                                    return      instance.id == data.id
                                            ||  instance.getPublicKey() == data.pubKey
                                },
                                function sameByInstance(instance_1, instance_2){
                                    return      instance_1.id == instance_2.id
                                            ||  instance_1.getPublicKey() ==  instance_2.getPublicKey()
                                }
                            );

            self.encryptPassphrase = function(passphrase, whiteList){
                
                return  $q.all(
                            self
                            .filter(function(key){
                                return  !whiteList || whiteList.indexOf(key.id) != -1
                            })
                            .map(function(key){
                                return  key
                                        .encrypt(passphrase)
                                        .then(function(result){
                                            return  {
                                                        keyId:                 key.id,
                                                        encryptedPassphrase:   result
                                                    }
                                        })
                            })
                         
                        )
            };

            self.getWeakestKeySize = function(){
                return this.reduce(function(size, key){
                    return (size == undefined) ? (key.getSize()||0) : Math.min(size||0, key.getSize()||0)
                }, undefined) || 0
            };

            /**
             * [getTransitivelyTrustedKeys description]
             * @param  {Array} trustedKeys Array of cmKey instances known to be trusted
             * @return {Array}             Array of cmKey instances within a chain of trust connecting them to the initially trusted keys. 
             */
            self.getTransitivelyTrustedKeys = function(initially_trusted_keys, trust_callback, trusted_keys_iteration){
                // cmLogger.debug('cmKeyFactory.getTransitivelyTrustedKeys');

                var trustedKeys = trusted_keys_iteration || initially_trusted_keys || []

                if(!trust_callback){
                    cmLogger.debug('cmKey.getTransitivelyTrustedKeys: trust_callback missing.')
                    return $q.reject()
                }       

                return  $q.all(self.map(function(key){
                            var is_trusted =    trustedKeys.indexOf(key) != -1                           
                                                ?   $q.when(key)
                                                :   trustedKeys.reduce(function(previous_try, trusted_key){
                                                        return  previous_try
                                                                .catch(function(){
                                                                    return  $q.when(trust_callback(trusted_key, key))
                                                                            .then(function(call_back_result){
                                                                                return  call_back_result
                                                                                        ?   $q.when(key)
                                                                                        :   $q.reject('callback return value was falsely.')
                                                                            })
                                                                })
                                                    }, $q.reject('missing trusted keys.'))

                            return  is_trusted
                                    .catch(function(reason){
                                        return $q.when(undefined)
                                    })
                        }))
                        .then(function(list){
                            var extended_key_list = list.filter(function(item){ return !!item})
                            return  trusted_keys_iteration && (extended_key_list.length === trusted_keys_iteration.length)
                                    ?   $q.when(extended_key_list)
                                    :   self.getTransitivelyTrustedKeys(null, trust_callback, extended_key_list)
                        })
            };

            $rootScope.$on('logout', function(){ self.reset() });
            $rootScope.$on('identity:switched', function(){ self.reset() });

            //self.on('fingerprintCheck:failed', function(event, value){
            //    console.log(event)
            //});

            return self
        }

        return keyFactory
    }
])

.service('cmKeyCache',[
    function(){
        var cache = {}

        return {
            storeVerificationResult : function(key, data, signature, result){
                cache.verify                = cache.verify || {}
                cache.verify[key.id]        = cache.verify[key.id] || {}
                cache.verify[key.id][data]  = cache.verify[key.id][data] || {}
                cache.verify[key.id][data][signature] = result
            },

            getVerificationResult : function(key, data, signature){
                return  cache.verify && cache.verify[key.id] && cache.verify[key.id][data]
                        ?   cache.verify[key.id][data][signature]
                        :   null
            }
        }
    }
])
.factory('cmKey', [

    'cmLogger',
    'cmObject',
    'cmWebworkerFactory',
    'cmCryptoHelper',
    'cmKeyCache',
    '$rootScope',
    '$q',

    function(cmLogger, cmObject, cmWebworkerFactory, cmCryptoHelper, cmKeyCache, $rootScope, $q){
        /**
         * @TODO TEsts!!!!!
         * @param args
         * @returns {*}
         */
        function cmKey(data){
            //Wrapper for RSA Keys
            var self        = this,
                crypt       = undefined, // will be JSEncrypt() once a key is set
                verificationCache = {}


            cmObject.addEventHandlingTo(this);

            this.created    = 0
            this.signatures = []
            

            function init(data){
                self.importData(data)
            }

            function reset(){
                self.created    = 0;
                self.signatures = [];
            }


            this.importData = function(data){
                if(!data){
                    cmLogger.debug('cmKey:importData: missing data')
                    return self
                }

                var key =       data.privKey
                            ||  this.getPrivateKey()
                            ||  data.key
                            ||  data.pubKey
                            ||  undefined;

                if(data.name)       this.setName(data.name);
                if(data.id)         this.setId(data.id);
                if(data.created)    this.created = data.created;
                if(data.signatures) Array().push.apply(this.signatures, data.signatures)

                if(key) this.setKey(key);

                return this;
            };

            this.exportData = function(){
                var data        = {},
                    private_key = this.getPrivateKey(),
                    public_key  = this.getPublicKey(),
                    size        = this.getSize();

                if(this.id)         data.id         = this.id;
                if(this.name)       data.name       = this.name;
                if(this.signatures) data.signatures = this.signatures;
                if(this.created)    data.created    = this.created;
                if(public_key)      data.pubKey     = public_key;
                if(private_key)     data.privKey    = private_key;
                if(size)            data.size       = size;

                return data;
            };

            this.setId = function(id){
                this.id = id;
                return this;
            };

            this.setName = function(name){
                this.name = name;
                return this;
            };

            // set either public or private key
            this.setKey = function(key){
                crypt = crypt || new JSEncrypt()
                crypt.setKey(key);
                return this;
            };

            this.getPublicKey = function(){
                var public_key;
                try{
                    public_key = crypt.getPublicKey();
                }catch(e){}

                return public_key;
            };

            /**
             * @todo sinnvoll einsetzen
             */
            this.checkFingerprint = function(){
                var fingerprint = sjcl.codec.base64.fromBits(sjcl.hash.sha256.hash(this.getPublicKey()), true, true);

                if(typeof this.id != 'undefined'){
                    if(this.id != fingerprint){
                        this.trigger('fingerprintCheck:failed');
                    }
                }
            };

            this.getFingerprint = function(){
                return this.id //Todo: rework Fingerprints, was:  sjcl.codec.base64.fromBits(sjcl.hash.sha256.hash(this.getPublicKey()), true, true)
            };

            this.getPrivateKey = function(){
                var private_key;
                try{
                    private_key = crypt.getPrivateKey();
                }catch(e){}

                return private_key;
            };

            this.sign = function(data){
                var promise =   cmCryptoHelper.isAvailable()
                                ?   cmCryptoHelper.rsaSign(self.getPrivateKey(), data)
                                :   cmWebworkerFactory.get({
                                        jobName:    'rsa_sign',
                                        params:     {
                                                        privKey:    self.getPrivateKey(),
                                                        data:       data
                                                    }
                                    })
                                    .then(
                                        function(worker){
                                            return  worker.run()
                                        },
                                        function(reason){
                                            return  $q.when(crypt && crypt.sign(data))
                                                    .then(function(signature){
                                                        return  signature
                                                                ?   $q.when(signature)
                                                                :   $q.reject()
                                                    })
                                        }
                                    )

                return  promise                                  
                        .then(function(signature){
                            cmKeyCache.storeVerificationResult(self, data, signature, true)
                            return $q.when(signature)
                        })
            };

            // returns a promise, resolved on succes and rejected on failure:
            this.verify = function(data, signature, use_cache){
                if( 
                        use_cache
                    &&  cmKeyCache.getVerificationResult(self, data, signature) != null
                   
                ){
                    //console.log('cached!')
                    return  cmKeyCache.getVerificationResult(self, data, signature)
                            ?   $q.when(true)
                            :   $q.reject(false)
                }

                var promise =   cmCryptoHelper.isAvailable()
                                ?   cmCryptoHelper.rsaVerify(self.getPublicKey(), data, signature)
                                :   cmWebworkerFactory.get({
                                        jobName :   'rsa_verify',
                                        params  :   {
                                                        pubKey:     self.getPublicKey(),
                                                        signature:  signature,
                                                        data:       data
                                                    }
                                    })
                                    .then(
                                        function(worker){
                                            return  worker.run()
                                        },
                                        function(reason){
                                            return  $q.when(crypt && crypt.verify(data, signature, function(x){ return x }))
                                                    .then(function(result){
                                                        return  result
                                                                ?   $q.when(result)
                                                                :   $q.reject('webWorker substitute failed, result: '+result)
                                                    })
                                        }
                                    )
                                    .catch(function(reason){
                                        cmKeyCache.storeVerificationResult(self, data, signature, false);
                                        return $q.reject(reason)
                                    })

                return  promise
                        .then(function(result){
                            cmKeyCache.storeVerificationResult(self, data, signature, true);
                            return $q.when(result)
                        })
                        .catch(function(reason){
                            cmLogger.warn('cmKey: verification failed',reason);
                            return $q.reject(reason);
                        })
            }

            this.encrypt = function(secret){

                if(cmCryptoHelper.isAvailable())
                    return cmCryptoHelper.rsaEncrypt(self.getPublicKey(), secret);


                return  cmWebworkerFactory.get({
                            jobName :   'rsa_encrypt',
                            params  :   {
                                            pubKey:     self.getPublicKey(),
                                            secret:     secret
                                        }
                        })
                        .then(
                            function(worker){
                                return  worker.run()
                            },
                            function(reason){
                                return  $q.when(crypt && crypt.encrypt(secret))
                                        .then(function(result){
                                            return  result
                                                    ?   $q.when(result)
                                                    :   $q.reject('webWorker substitute failed, result: '+result)
                                        })
                            }
                        )
                        .catch(function(reason){
                            console.log(crypt.encrypt(secret))
                            cmLogger.warn('keyModel.encrypt() failed:'+ reason)
                            return $q.reject(reason)
                        })
            };

            this.decrypt = function(encrypted_secret){

                if(cmCryptoHelper.isAvailable())
                    return cmCryptoHelper.rsaDecrypt(self.getPrivateKey(), encrypted_secret)


                return  cmWebworkerFactory.get({
                            jobName :   'rsa_decrypt',
                            params  :   {
                                            privKey:            self.getPrivateKey(),
                                            encryptedSecret:    encrypted_secret
                                        }
                        })
                        .then(
                            function(worker){
                                return  worker.run()
                            },
                            function(reason){
                                return  $q.when(crypt && crypt.decrypt(encrypted_secret))
                                        .then(function(result){
                                            return  result
                                                    ?   $q.when(result)
                                                    :   $q.reject('webWorker substitute failed.')
                                        })
                            }
                        )
                        .catch(function(reason){
                            cmLogger.warn('keyModel.decrypt() failed:' +reason)
                            return $q.reject(reason)
                        })

            };

            this.verifyKey = function(key, data, use_cache){
                return      (this.getPublicKey() == key.getPublicKey() 
                        ?   $q.when(key)   //always verifies itself
                        :   key.signatures.reduce(function(previous_try, signature){
                                return  previous_try
                                        .catch(function(){
                                            return  (self.id == signature.keyId)
                                                    ?   self.verify(data, signature.content, use_cache)
                                                    :   $q.reject('keyIds not matching.')
                                        })
                            }, $q.reject('no signatures.'))
                            .then(function(result){
                                return $q.when(result)
                            })
                        )
            };

            this.getSize = function(){
                var size

                try{
                    size = crypt.key.n.bitLength();
                } catch(e){

                }

                //Todo: dirty workaround :)
                if(size == 127 || size == 1023 || size == 2047 || size == 4095)
                    size = size+1;

                return size;
            };

            this.importJSEncrypt = function(jse){
                crypt = jse
                return this
            };

            this.exportJSEncrypt = function(){
                return crypt
            };

            $rootScope.$on('logout', function(){ reset() });
            $rootScope.$on('identity:switched', function(){ reset() });

            init(data)
        }

        return cmKey;
    }
])

.directive('cmDateFormatSelect', [
    'cmSettings',
    'cmUserModel',
    function(cmSettings,cmUserModel){
        return {
            restrict: 'AE',
            scope: true,
            template:   '<select ng-model="myFormat">'+
                            '<option ng-repeat="item in dateFormat" value="{{item.value}}" ng-selected="myFormat == item.value">{{item.name}}</option>'+
                        '</select>',

            link: function(scope, element){
                element.find('select').on('change', function(){
                    cmSettings.set('dateFormat', scope.myFormat);
                })
            },

            controller: function($scope){
                $scope.dateFormat = [
                    {name:"DD.MM.YYYY", value: "dd.MM.yyyy"},
                    {name:"YYYY-MM-DD", value: "yyyy-MM-dd"}
                ];

                function update(){
                    $scope.myFormat = cmSettings.get('dateFormat');
                }

                update();

                cmUserModel.on('update:finished', update)
            }
        }
    }
])

.directive('cmLanguageSelect', [
    'cmLanguage',
    'cmTranslate',
    function(cmLanguage, cmTranslate){
        return {
            restrict: 'A',
            transclude: true,
            scope: true,
            template: '<select ng-model="language">'+
                        '<option ng-repeat="lang_key in languages" value="{{lang_key}}" ng-selected="lang_key == language">{{\'LANG.\'+lang_key.toUpperCase()|cmTranslate}}</option>'+
                      '</select>',

            link: function(scope, element){
                element.find('select').on('change', function(){
                    cmLanguage.switchLanguage(scope.language);
                });
            },

            controller: function($scope){
                $scope.languages = cmLanguage.getSupportedLanguages();
                $scope.language = cmLanguage.getCurrentLanguage();
            }
        }
    }
])
.directive('cmTimeFormatSelect', [
    'cmSettings',
    'cmUserModel',
    function(cmSettings, cmUserModel){
        return {
            restrict: 'AE',
            scope: true,
            template: '<select ng-model="myFormat" ng-options="obj.value as obj.name for obj in timeFormat"></select>',

            link: function(scope, element){
                element.find('select').on('change', function(){
                    cmSettings.set('timeFormat', scope.myFormat);
                });
            },

            controller: function($scope){
                $scope.timeFormat = [
                    {name:"24h", value: "HH:mm"},
                    {name:"12h", value: "h:mm a"}
                ];

                function update(){
                    $scope.myFormat = cmSettings.get('timeFormat');
                }

                update();

                cmUserModel.on('update:finished', update)
            }
        }
    }
])

//Does not work as intended <div cm-translate="LANG.DE"></div> stays empty
.directive('cmTranslate', [
    'translateDirective',
    function(translateDirective){
        return translateDirective[0]
    }
])

.filter('cmTranslate', [
    'translateFilter',
    function(translateFilter){
        return translateFilter;
    }
])

.provider('cmLanguage', [
    '$translateProvider',
    function($translateProvider){

        var supported_languages = [],
            path_to_languages = '',
            cache_lang_files = true;

        this.supportedLanguages = function(languages){
            supported_languages = languages;
            return(this)
        };

        this.pathToLanguages = function(path){
            path_to_languages = path;

            $translateProvider.useStaticFilesLoader({
                prefix: path+'/',
                suffix: '.json' + (cache_lang_files ? '' : '?bust=' + (new Date()).getTime())
            });

            return(this)
        };

        this.useLocalStorage = function(){
            $translateProvider.useLocalStorage();
            return(this)
        };

        this.preferredLanguage = function(lang_key){
            $translateProvider.preferredLanguage(lang_key);
            return(this)
        };

        this.cacheLangFiles = function(bool){
            cache_lang_files = bool;
            return(this)
        };

        this.translations = function(lang_key, data){
            $translateProvider.translations(lang_key, data)
        };

        this.$get = [
            'cmTranslate',
            'cmNotify',
            'cmLogger',
            function(cmTranslate, cmNotify, cmLogger){

                if(supported_languages.length == 0)
                    cmLogger.warn('No supported languages found. Try cmLanguageProvider.setSupportedLanguages().')

                return {
                    getSupportedLanguages: function(){
                        return supported_languages
                    },

                    getPathToLanguage: function(path){
                        return path_to_languages
                    },

                    getLanguageName: function(lang_key){
                        lang_key = lang_key || cmTranslate.use();
                        return cmTranslate('LANG.'+lang_key.toUpperCase())
                    },

                    switchLanguage: function(lang_key){
                        var self = this;

                        return cmTranslate.use(lang_key)
                            .then(
                            function(){
                                self.getLanguageName(lang_key).then(function(language) {
                                    cmTranslate('LANG.SWITCH.SUCCESS', {lang: language}).then(function (text) {
                                        cmNotify.info(text, {ttl: 2000});
                                    });
                                });
                            },
                            function(){
                                self.getLanguageName(lang_key).then(function(language) {
                                    cmTranslate('LANG.SWITCH.ERROR', {lang: language}).then(function (text) {
                                        cmNotify.error(text, {ttl: 2000});
                                    });
                                });
                            }
                        )
                    },

                    getCurrentLanguage:  function(){
                        return cmTranslate.use() || cmTranslate.preferredLanguage()
                    }
                }
            }
        ]
    }
])
// Provides:
// filter 'translate', usage: {{'MESSAGE_ID' | translate}}
// controller 'languageCtrl' for language switch
// Example:
// <div ng-controller="LanguageCtrl">
//		<a href="" ng-click="switchLang('en')">Englisch</a></li>
//		<a href="" ng-click="switchLang('de')">German</li>
// </div>
// language files: /languages/lang-$langKey.json
// language file format:
//		{
//			"MESSAGE_ID": "Text",
//			"NAMESPACE"	: {
//				"MESSAGE_ID": "Hello {{username}}"
//			}
//		}
// language keys: $LANG_$CULTURE, en_US
// last language is stored in local storage (fallback cookie)


.service('cmTranslate', [
    '$translate',
    function($translate){
        return $translate;
    }
])

.directive('cmNotifySignal', [
    'cmNotify',
    function (cmNotify) {
        return {
            restrict: 'E',
            template: '<i class="fa with-response" ng-class="{\'cm-menue-bell cm-orange\': ring, \'cm-menu\': !ring}"></i>',
            scope: true,
            controller: function ($scope) {
                $scope.ring = false;

                function init(){
                    if(cmNotify.isBimmel()){
                        $scope.ring = true;
                    }
                }

                cmNotify.on('bell:ring', function(){
                    if(cmNotify.isBimmel()){
                        $scope.ring = true;
                    }
                });

                cmNotify.on('bell:unring', function(){
                    $scope.ring = false;
                });

                init();
            }
        }
    }
])

.factory('cmNotifyModel', [
    'cmStateManagement', 'cmObject', 'cmModal', 'cmUtil',
    'cmTranslate', 'cmLogger',
    '$timeout', '$rootScope', '$injector',
    function(cmStateManagement, cmObject, cmModal, cmUtil,
             cmTranslate, cmLogger,
             $timeout, $rootScope, $injector){
        function cmNotifyModel(data){
            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state = new cmStateManagement(['new','read','error']);

            this.type = undefined;
            this.label = undefined;
            this.severity = 'none';
            this.icon = undefined;
            this.displayType = undefined;
            this.callbackRoute = undefined;
            this.bell = false;
            this.ttl = -1;
            this.i18n = {};
            this.template = undefined;
            this.templateScope = undefined;

            /**
             * {
                label: undefined,
                severity: 'info',
                icon: 'cm-attention',
                displayType: 'modal',
                ttl: 3000,
                callbackRoute: undefined
            }
             * @param data
             */
            function init(data){
//                cmLogger.debug('cmNotifyModel.init');
                self.state.set('new');

                if(typeof data !== 'undefined'){
                    self.importData(data);
                }
            }

            this.importData = function(data){
//                cmLogger.debug('cmNotifyModel.importData');
//                
                if(typeof data == 'object') { //typeof never equals 'array': || typeof data == 'array'){
                    this.type = data.type || this.type;

                    this.label = data.label || this.label;

                    this.severity = data.severity || this.severity;

                    this.icon = data.icon || this.icon;

                    this.displayType = data.displayType || this.displayType;

                    this.callbackRoute = data.callbackRoute || this.callbackRoute;

                    this.bell = data.bell || this.bell;

                    this.ttl = data.ttl || this.ttl;

                    this.i18n = data.i18n || this.i18n;

                    this.template = data.template || this.template;

                    this.templateScope  = data.templateScope || this.templateScope;
                } else {
                    this.state.set('error');
                }

                self.state.unset('new');
                this.trigger('update:finished');
            };

            this.render = function(){
//                cmLogger.debug('cmNotifyModel.render');
                if(this.bell !== false){
                    $injector.get('cmNotify').ringBimmel(this.type);
                }

                if(this.displayType == 'modal'){
                    this.renderModal();
                }
            };

            this.renderModal = function() {
//                cmLogger.debug('cmNotifyModel.renderModal');
                var modalId = 'modal-notification';

                if (!this.templateScope)
                    this.templateScope = $rootScope.$new();

                angular.extend(this.templateScope, {
                    i18n: this.i18n
                });

                cmModal.create({
                        id: modalId,
                        type: 'alert',
                        'class': 'modal-notification modal-type-'+this.severity,
                        //'nose': 'top-right',
                        'cm-close-btn': true,
                        'cm-footer-label': 'MODAL.LABEL.CLOSE',
                        'cm-footer-icon': 'cm-close'
                    },
                        '<div class="header">'+
                            '<i class="fa '+this.icon+'"></i>' +
                            '{{\'NOTIFICATIONS.MODAL_HEADER.'+this.severity.toUpperCase()+'\'|cmTranslate}}'+
                        '</div>'+
                        '<div class="body">'+
                            '<div ng-bind-html="\''+this.label+'\'|cmParse:{data:i18n}"></div>'+
                            (this.template || '')+
                        '</div>',
                    null,
                    this.templateScope
                );
                cmModal.open(modalId);

                if(this.ttl > 0){
                    this.ttlTimeout = $timeout(function(){
                        cmModal.close(modalId);
                    }, this.ttl);
                }

                cmModal.on('modal:closed', function(){
                    if(self.ttlTimeout){
                        $timeout.cancel(self.ttlTimeout);
                    }

                    self.trigger('notify:remove', this);
                });
            };

            this.on('update:finished', function(){
//                cmLogger.debug('cmNotifyModel.on.update:finished');
                self.render();
            });

            // after events!!!
            this.on('init:ready', function(){
//                cmLogger.debug('cmNotifyModel.on.init:ready');
                init(data);
            });
        }

        return cmNotifyModel;
    }
])

.service('cmNotify', [
    'cmFactory', 'cmNotifyModel',
    '$rootScope',
    function(cmFactory, cmNotifyModel,
             $rootScope){

        var self = new cmFactory(cmNotifyModel),
            notifyTpl = {
                label: undefined,
                severity: 'info',
                icon: 'cm-attention',
                displayType: undefined,
                ttl: 3000,
                bell: false,
                callbackRoute: undefined
            };

        function handleAdapter(args){
            var notify = angular.extend({} ,notifyTpl);

            if(typeof args == 'object'){
                notify = angular.extend(notify, args);  
                self.create(notify);
            }
        }

        self.error = function(label, args){
            var options = {};

            if(typeof label == 'string' && label.length > 0){
                if(typeof args == 'object'){
                    options = angular.extend(options, args);
                }

                options.displayType = 'modal';
                options.label = label;
                options.severity = 'error';
                options.icon = 'cm-reject';

                handleAdapter(options);
            }
        };

        self.info = function(label, args){
            var options = {};

            if(typeof label == 'string' && label.length > 0){
                if(typeof args == 'object'){
                    options = angular.extend(options, args);
                }

                options.severity = 'info';
                options.label = label;
                options.icon = 'cm-info';

                handleAdapter(options);
            }
        };

        self.success = function(label, args){
            var options = {};

            if(typeof label == 'string' && label.length > 0){
                if(typeof args == 'object'){
                    options = angular.extend(options, args);
                }

                options.severity = 'success';
                options.label = label;
                options.icon = 'cm-checker';

                handleAdapter(options);
            }
        };

        self.warn = function(label, args){
            var options = {};

            if(typeof label == 'string' && label.length > 0) {
                if (typeof args == 'object') {
                    options = angular.extend(options, args);
                }

                options.displayType = 'modal';
                options.severity = 'warn';
                options.label = label;
                options.icon = 'cm-attention';

                handleAdapter(options);
            }
        };

        var bimmelJobs = [],
            unringForce = false;

        /**
         * set a new type of notification and ring the bell
         * unset the unringForce
         * communicate via event 'bell:ring' with drtv-notify-signal
         * @param identifier of ring type ex.: markHelp or friendRequest
         */
        self.ringBimmel = function(identifier){
            unringForce = false;

            //if(bimmelJobs.indexOf(identifier) == -1)
                bimmelJobs.push(identifier);

            self.trigger('bell:ring');
        };

        /**
         * check method for the bell if she should ring or not
         * is no identifier given and unringForce == true the method will always return false
         * is unringForce == false and identifier is given will check if some ring type is registered
         * otherwise it will check if the length of regisitred types
         *
         * @param identifier of ring type
         * @returns {boolean} is bell should ring
         */
        self.isBimmel = function(identifier){
            if(!identifier && unringForce)
                return false;

            if(identifier)
                return bimmelJobs.indexOf(identifier) >= 0;
            else
                return bimmelJobs.length > 0;
        };

        /**
         * delete registred ring type out of the bimmel context
         * and communicate via event 'bell:unring' with drtv-notify-signal
         * @param identifier of ring type
         */
        self.unringBimmel = function(identifier){
            if(bimmelJobs.indexOf(identifier) >= 0)
                bimmelJobs.splice(bimmelJobs.indexOf(identifier), 1);

            if(!self.isBimmel())
                self.trigger('bell:unring');
        };

        /**
         * force unring for menu toggle
         */
        self.unringBimmelForce = function(){
            unringForce = true;
            self.trigger('bell:unring');
        };

        /**
         * Event Handling
         */
        $rootScope.$on('logout', function(){ self.reset() });

        $rootScope.$on('identity:switched', function(){ self.reset() });

        self.on('notify:remove', function(event){
            self.deregister(event.source);
        });

        return self;
    }
])
//This Module handels api calls

.provider('cmApi',[

//Service to handle all api calls
    '$injector',
    function($injector){
        var rest_api            = "",
            without_api_url   = false,
            call_stack_disabled = true,
            call_stack_path     = "",
            commit_size         = 10,
            commit_interval     = 2000,
            events_disabled     = true,
            events_path         = "",
            events_interval     = 5000;

        this.setWithoutApiUrl = function(){
            without_api_url = true;
            return this
        }

        this.restApiUrl = function(url){
            rest_api = url;
            return this
        }

        this.useCallStack = function (on){
            call_stack_disabled = !on
            return this
        }

        this.callStackPath = function(path){
            call_stack_path = path
            return this
        }

        this.commitSize = function(size){
            commit_size = size
            return this
        }

        this.commitInterval = function(interval){
            commit_interval = interval
            return this
        }

        this.useEvents = function (on){
            events_disabled = !on
            return this
        }

        this.eventsPath = function(path){
            events_path = path
            return this
        }

        this.eventsInterval = function(interval){
            events_interval = interval
            return this
        }


        this.$get = [
            'cmLogger', 'cmObject', 'cmStateManagement', 'cmDevice',
            '$http', '$httpBackend', '$injector', '$q',
            '$interval', '$cacheFactory', '$rootScope',
            function(cmLogger, cmObject, cmStateManagement, cmDevice,
                     $http, $httpBackend, $injector, $q,
                     $interval, $cacheFactory, $rootScope){
                /***
                 All api calls require a config object:

                 ie.: api.get(config)

                 config works almost like in $http(config)

                 most important keys are:
                 path:	api path to call i.e. '/account/check',
                 will give an error message if passed something different from a path (like 'http://dev.cameo.io/...')
                 in that case your call will most likely fail brutally

                 data:	data to send, any plain object

                 exp_ko: key you expect in response body if your request was granted(see below)
                 exp_ok: key you expect in response body if your request was denied (see below)

                 Authentication and error handling is dealt with automatically.

                 example: (!!check tests in cmApi.spec.js!!)

                 cmApi.get({
                    path:     '/pony',
                    exp_ok:  'pony',
                })''


                 ---> response:  {
                                    "res" : 'OK',
                                    "data": {
                                                "pony" : "my_new_pony"
                                            }
                                }

                 .then(
                 function(pony){         <--- gets called because response.res == 'OK', pony will equal 'my_pony'
                        yay(pony)
                    },

                 function(alternative, res){
                        alternative
                        ? meh(alternative)
                        : error(alternative) //yet error should have already been handled alesewhere
                    }
                 )


                 ---> response:  {
                                    "res" : 'OK',
                                    "data": {
                                                "dog" : "my_new_dog"
                                            }
                                }

                 .then(
                 function(pony){
                        yay(pony)
                    },
                 function(alternative,res){	<--- gets called because response is invalid, "pony" was expected, yet "dog" was delivered
                                                     alternative will be undefined
                                                     res however holds all the response
                        alternative
                        ? meh(alternative)
                        : error(alternative) //yet error should have been handled already elesewhere
                    }
                 )




                 ---> response:	{
                                    "res" : 'KO',
                                    "data": {
                                                "alternative" : "kitty"
                                            }
                                }

                 .then(
                 function(pony){
                        yay(pony)
                    },
                 function(data, res){ <--- gets called because response.res == 'KO', data will be {'alternative': 'kitty'},
                                              because there was no specific key expected for KO.
                                              res however holds all the response
                        alternative
                        ? meh(alternative)
                        : error(alternative) //yet error should have been handled already elesewhere
                    }
                 )




                 ---> response:	{
                                    "res" : 'XXX',
                                    "data": {
                                                "kitty" : "grumpy cat"
                                            }
                                }

                 .then(
                 function(pony){
                        yay(pony)
                    },
                 function(alternative,res){ <--- gets called because response is invalid for neither response.res == 'OK' nor response.res == 'KO',
                                                    alternative will be undefined
                                                    res however holds all the response
                        alternative
                        ? meh(alternative)
                        : error(alternative) //yet error should have been handled already elesewhere
                    }
                 )



                 */

                    //check if the sever's response complies with the api conventions
                function compliesWithApiConventions(body, exp_ok, exp_ko){
                    var valid =    body
                        //response must have a res key that equals 'OK' or 'KO':
                        && (body.res == 'OK' || body.res == 'KO')
                        //if your request was granted and something was expected in return, it must be present:
                        && (body.res == "OK" && exp_ok ? exp_ok in body.data : true)
                        //if your request was denied and something was expected in return, it must be present:
                        && (body.res == "KO" && exp_ko ? exp_ko in body.data : true)

                    if(!valid) cmLogger.error('Api response invalid; '+(exp_ok||exp_ko ? 'expected: ':'') + (exp_ok||'') +', '+(exp_ko||''), body)

                    return(valid)
                }

                function handleSuccess(response, deferred){
                    //$http call was successfull

                    var config  = response.config,
                        body    = response.data

                    compliesWithApiConventions(body, config.exp_ok, config.exp_ko)
                        ?   //response valid, check if OK:
                        //if a certain key was expected, resolve promise resp. reject the promise with the according values
                        //if nothing was expected, just resolve or reject with value of 'data' in the response body if present or all the data
                        //response should now look similar to this:
                        /*
                         "res":  "OK",
                         "data": {
                         "some_key":             "some_value",
                         "some expected_key":    "some_other value"
                         }

                         */
                        body.res =='OK'
                        ? deferred.resolve( config.exp_ok ? body.data[config.exp_ok] : body.data || response)
                        : deferred.reject(  config.exp_ko ? body.data[config.exp_ko] : body.data || response)

                        :   //response invalid, call through:
                        deferred.reject(undefined, response)
                }


                function handleError(response, deferred){
                    cmLogger.error('Api call failed: \n '+response.config.method+' '+JSON.stringify(response, null, 2))
//                    window.location.href='#/server_down' //@ Todo
                    //error messages should come trough backend

                    if('data' in response && 'errorCodes' in response.data)
                        $rootScope.$broadcast('cmValidate:error',response.data.errorCodes);

                    deferred.reject(response)
                }

                function prepareConfig(config, method, token, twoFactorToken){
                    config.apiVersion = without_api_url ? '' : config.apiVersion || $injector.get('cmConfig').defaultApiVersion;
                    config.url      =   config.url ||
                        (
                            rest_api +      // base url API
                            config.apiVersion +  // api version
                            config.path     // path to specific method
                        )

                    config.method   =   method || config.method
                    config.headers  =   angular.extend(token           ? {'Authorization': token} : {}, config.headers || {})   //add authorization token to the header
                    config.headers  =   angular.extend(twoFactorToken  ? {'X-TwoFactorToken': twoFactorToken} : {}, config.headers || {})   //add two factor authorization token to the header
                }


                var api = function(method, config){
                    var deferred = $q.defer(),
                        token    = undefined,
                    //get twoFactorAuth token from cmAuth if present
                        twoFactorToken = $injector.has('cmAuth')
                            ?	$injector.get('cmAuth').getTwoFactorToken()
                            :	undefined;

                    //get authentification token from config if override of from cmAuth if present
                    if('overrideToken' in config && config.overrideToken != ''){
                        token = config.overrideToken;
                        delete config.overrideToken;
                    } else if($injector.has('cmAuth')){
                        token = $injector.get('cmAuth').getToken();
                    }

                    if(rest_api != '' || without_api_url){
                        prepareConfig(config, method, token, twoFactorToken);

                        $http(config).then(
                            function(response){
                                handleSuccess(response, deferred)
                            },
                            function(response){
                                handleError(response, deferred)
                            }
                        );
                    } else {
                        deferred.reject({apiUrlUndefined:true});
                    }

                    return deferred.promise;
                };

                /**
                 * Shortcuts for api()
                 * @param {Object}  config  config object as used by api()
                 * @param {Boolean}         force direct api call not using the callstack
                 */

                api.get = function(config, force){
                    var no_cache = new Date().getTime();

                    // add timestamp to path to disable the caching in ie
                    if(cmDevice.isIE()) {
                        var leadingSymbol = (config.path.indexOf('?') == -1 ? '?' : '&');
                        config.path += leadingSymbol + 'ts=' + no_cache;
                    }

                    return (force || call_stack_disabled)
                        ? api('GET', config)
                        : api.stack('GET', config)
                };
                api.post	= function(config, force){ return (force || call_stack_disabled) ? api('POST',   config) : api.stack('POST',   config) }
                api.delete	= function(config, force){ return (force || call_stack_disabled) ? api('DELETE', config) : api.stack('DELETE', config) }
                api.head	= function(config, force){ return (force || call_stack_disabled) ? api('HEAD',   config) : api.stack('HEAD',   config) }
                api.put		= function(config, force){ return (force || call_stack_disabled) ? api('PUT',    config) : api.stack('PUT',    config) }
                api.jsonp	= function(config, force){ return (force || call_stack_disabled) ? api('JSONP',  config) : api.stack('JSONP',  config) }


                // binary mock
                api.getBinary = function(config){
                    var deferred = $q.defer(),
                        token = $injector.has('cmAuth') ? $injector.get('cmAuth').getToken() : undefined;

                    prepareConfig(config, 'GET', token);
                    // assume binary as blob
//                    config.responseType = 'blob';

                    $http(config).then(
                        function(response){
                            deferred.resolve(response.data)
                        },
                        function(response){
                            deferred.reject(response)
                        }
                    );

                    return deferred.promise
                };

                api.postBinary = function(config){
                    var deferred = $q.defer(),
                        token = $injector.has('cmAuth') ? $injector.get('cmAuth').getToken() : undefined;
                    prepareConfig(config, 'POST', token);

                    $http(config).then(
                        function(response){
                            deferred.resolve(response.data)
                        },
                        function(response){
                            deferred.reject(response)
                        }
                    );

                    return deferred.promise
                };


                //CALL STACK:

                api.call_stack = api.call_stack || []
                api.call_stack_cache = $cacheFactory('call_stack_cache')


                //Puts a requests on the call stack
                api.stack = function(method, config){

                    if(call_stack_disabled){
                        cmLogger.error('unable to call ".stack()", callstack disabled.')
                        return null
                    }


                    prepareConfig(config, method, without_api_url)

                    var deferred = $q.defer()

                    api.call_stack.push({
                        deferred : deferred,
                        config   : config
                    })

                    return deferred.promise
                }


                // Commits all requests on callstack to the API
                api.commit = function(){

                    //dont do anything, if call stack is empty:
                    if(api.call_stack.length == 0) return null

                    var items_to_commit = [],
                        configs         = []

                    //pick items from callstack to commit:
                    api.call_stack.forEach(function(item, index){
                        if(items_to_commit.length < commit_size){
                            items_to_commit.push(item)
                            delete api.call_stack[index]
                        }
                    })

                    //remove undefined elements from call_stack:
                    var index = api.call_stack.length
                    while(index--){ if(!api.call_stack[index]) api.call_stack.splice(index,1) }

                    //prepare request configs:
                    items_to_commit.forEach(function(item, index){ configs.push(item.config) })

                    //post requests to call stack api:
                    api.post({
                        path: call_stack_path,
                        data: { requests: configs },
                        exp_ok : 'responses'
                    }, true)
                        .then(function(responses){

                            responses.forEach(function(request, index){

                                var response =  {
                                        data   : responses[index].body,
                                        status : responses[index].status,
                                        config : items_to_commit[index].config
                                    },

                                    deferred = items_to_commit[index].deferred

                                200 <= response.status && response.status < 300
                                    ?   handleSuccess(response, deferred)
                                    :   handleError(response, deferred)

                            })
                        })

                }

                if(!call_stack_disabled && commit_interval)
                    $interval(function(){ api.commit() }, commit_interval, false)

                //API EVENTS:

                cmObject.addEventHandlingTo(api);
                api.state = new cmStateManagement(['event_call_running']);
                api.subscriptionId = undefined;

                api.resetSubscriptionId = function(){
                    //cmLogger.debug('api.resetSubscriptionId');
                    api.subscriptionId = undefined;
                    window._eventSubscriptionId = undefined;
                };

                api.setSubscriptionId = function(id){
                    api.subscriptionId = id;
                    window._eventSubscriptionId = id;
                };

                api.subscribeToEventStream = function(){
                    //cmLogger.debug('api.subscribeToEventStream');
                    if(!api.state.is('event_call_running')){
                        api.state.set('event_call_running');

                        return api.post({
                            path: events_path,
                            exp_ok: 'id',
                            data:{
                                secret: 'b4plIJMNITRDeJ9vl0JG' //only working on dev
                            }
                        }, true)
                        .then(function(id){
                            api.setSubscriptionId(id);
                        })
                        .finally(function(){
                            api.state.unset('event_call_running');
                        })
                    } else {
                        return $q.reject('event_call_running');
                    }
                };

                api.getEvents = function(force){
                    //cmLogger.debug('api.getEvents');
                    if(!api.state.is('event_call_running')) {
                        if (!api.subscriptionId) {
                            //if no subscriptionId is present, get one and try again later:
                            api.subscribeToEventStream()
                            .then(function(){
                                api.getEvents();
                            });
                            /*
                            ,
                            function(){
                                // test failed...
                                //api.stopListeningToEvents();
                            }
                            */
                        } else {
                            api.state.set('event_call_running');
                            api.get({
                                path: events_path + '/' + api.subscriptionId,
                                exp_ok: 'events'
                            }, force)
                            .then(
                                function (events) {
                                    events.forEach(function (event) {
                                        cmLogger.debug('Backend event: ' + event.name);
                                        api.trigger(event.name, event.data, event);
                                    })
                                },
                                function (response) {
                                    if(typeof response == 'object' && 'subscriptionId' in response){
                                        //cmLogger.debug('cmApi.getEvents() reset invalid subscriptionId.')
                                        api.setSubscriptionId(response.subscriptionId);
                                        api.trigger('subscriptionId:changed');
                                    }
                                }
                            ).finally(function(){
                                api.state.unset('event_call_running');
                            })
                        }
                    }
                };

                api.listenToEvents = function(){
                    // Dont listen to Events twice:
                    api.stopListeningToEvents();
                    // Start listening:
                    if(!events_disabled && events_interval) {
//                        api.getEvents(false)
                        api._events_promise = $interval(function () {
                            api.getEvents(false);
                        }, events_interval, 0, false);
                    }
                };

                api.stopListeningToEvents = function(){
                    if(api._events_promise)
                        $interval.cancel(api._events_promise);
                };

                if(!events_disabled && events_interval){
                    $rootScope.$on('login', function(){
                        api.resetSubscriptionId();
                        api.listenToEvents();
                    });
                    $rootScope.$on('identity:switched', function(){
                        api.resetSubscriptionId();
                        api.listenToEvents();
                    });
                    $rootScope.$on('logout', function(){
                        api.stopListeningToEvents();
                        api.resetSubscriptionId();
                    });
                }

                $rootScope.$on('cmApi:sleep', function(){
                    cmLogger.info('cmApi:sleep > stopListeningToEvents');
                    api.stopListeningToEvents();
                });

                $rootScope.$on('cmApi:wakeup', function(){
                    var token = $injector.has('cmAuth') ? $injector.get('cmAuth').getToken() : undefined;
                    if(token){
                        cmLogger.info('cmApi:wakeup > listenToEvents');
                        api.listenToEvents();
                    }
                });

                /**
                 * @ngdoc method
                 * @methodOf cmAuth
                 *
                 * @name sendBroadcast
                 * @description
                 * post a broadcast event to own devices
                 *
                 * @param {Object} data event data
                 * @returns {Promise} for async handling
                 */
                api.broadcast = function(data, identityId){
                    return api.post({
                        path: '/event/broadcast' + (identityId ? '/identity/' + identityId : ''),
                        data: data
                    });
                };

                return api;
            }
        ]
    }
])

.provider('cmCallbackQueue', [

    function(){

        var queueTime = 250

        this.setQueueTime = function(time){
            queueTime = time
        }

        this.$get = [

            'cmObject',
            'cmStateManagement',
            'cmLogger',
            '$rootScope',
            '$timeout',
            '$q',

            function(cmObject, cmStateManagement, cmLogger, $rootScope, $timeout, $q){
                cmObject.addEventHandlingTo(this);

                var self    = this,
                    queue   = [];

                $rootScope.$on('logout', function(){
                    queue   = [];
                });

                this.state = new cmStateManagement(['working'])

                this.push = function(callbacks, timeout){

                    if(!(callbacks instanceof Array)) 
                        callbacks = [callbacks]

                    var promise = $q.all(
                        callbacks.map(function(callback){
                            var deferred = $q.defer()

                            queue.push({fn: callback, deferred: deferred})

                            return deferred.promise
                        })
                    )

                    if(!self.state.is('working')){
                        self.state.set('working')
                        $timeout(self.advance, timeout || 0)
                    }

                    return promise
                }

                this.advance = function(){
                    var callback = queue.shift()
                
                    if(callback && callback.fn && callback.deferred){
                        try{                            
                            callback.deferred.resolve(callback.fn())  
                        } catch(e) {
                            cmLogger.error('cmCallbackQueue cought an error: \n'+e)
                            callback.deferred.reject(e)
                        }
                    }
                    
                    if(queue.length != 0){
                        $timeout(self.advance, queueTime)
                    } else {
                        self.state.unset('working')
                    }



                }

                return this
            }
        ]
    }
])

.provider('cmLogger', [
    '$logProvider',
    function($logProvider){
        var debug_enabled = true;

        this.debugEnabled = function(flag){
            $logProvider.debugEnabled(flag);
            debug_enabled = flag;
        };

        this.$get = [
            '$log',
            function($log){
            /**
            * Format date as a string
            */
            function getTimestampAsString() {
                var d = (new Date()+'').split(' ');
                return [d[3], d[1], d[2], d[4]].join(' ');
            }

            function prefix(type, msg) {
                return getTimestampAsString() + " [cmLogger-"+type.toUpperCase()+"]> "  + msg;
            }

            function log_object(obj) {
                console.groupCollapsed();
                console.dir(obj);
                console.groupEnd();
            }

            return {
                universal: function(type, loggerMessage, object) {
                    $log[type](prefix(type, loggerMessage))
                    if(object) log_object(object)
                },

                 /**
                 * simple info log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                info: function(loggerMessage, object){ this.universal('info', loggerMessage, object) },
                /**
                 * simple warn log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                warn: function(loggerMessage, object){ this.universal('warn', loggerMessage, object) },
                /**
                 * simple error log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                error: function(loggerMessage, object){ this.universal('error', loggerMessage, object) },
                /**
                 * simple debug log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                debug: function(loggerMessage, object){
                    if(!debug_enabled) return(undefined)
                    this.universal('debug', loggerMessage, object)
                }
            }
        }];
    }
])
.provider('cmRoutes', [
    'cmConfigProvider',
    '$injector',
    function(cmConfigProvider,
             $injector){

        function ucfirst(str) {
            //  discuss at: http://phpjs.org/functions/ucfirst/
            // original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // bugfixed by: Onno Marsman
            // improved by: Brett Zamir (http://brett-zamir.me)
            //   example 1: ucfirst('kevin van zonneveld');
            //   returns 1: 'Kevin van zonneveld'

            str += '';
            var f = str.charAt(0)
                .toUpperCase();
            return f + str.substr(1);
        }

        /**
         * create routes
         * @param settings
         *
         * full control:
         'login': {
            route:['/login'], // multiple possible
            hasCtrl: true,
            isOtherwise: true
        }
         * creates route '/login'
         * and template 'routes/login/login.html'
         * and controller 'routes/login/login-ctrl.html'
         *
         * short control:
         'terms': {}
         * creates route '/terms'
         * and template 'routes/terms/terms.html'
         *
         */

        function createRoutes(settings){
            angular.forEach(settings,function(_settings_, routeKey) {
                var routes = [],
                    routeParams = {
                        templateUrl: '',
                        controller: '',
                        css: '',
                        guests: false,
                        resolve: {},
                        isDefault: false
                    };
                // create params for route
                if (angular.isDefined(_settings_['templateUrl'])) {
                    routeParams.templateUrl = _settings_['templateUrl'];
                } else {
                    if(routeKey.indexOf('-') != -1){
                        var arr  = routeKey.split('-'),
                            ctrlRoute = '',
                            i = 0;

                        while(i < arr.length){
                            ctrlRoute += '/'+arr[i];
                            i++;
                        }

                        routeParams.templateUrl = 'routes' + ctrlRoute + '/' + routeKey + '.html';
                    } else {
                        routeParams.templateUrl = 'routes/' + routeKey + '/' + routeKey + '.html';
                    }
                }
                // check if route has/need controller
                if (angular.isDefined(_settings_['hasCtrl']) && _settings_.hasCtrl === true){

                    if(routeKey.indexOf('-') != -1){
                        var arr  = routeKey.split('-'),
                            ctrlRoute = '',
                            i = 0;

                        while(i < arr.length){
                            ctrlRoute += ucfirst(arr[i]);
                            i++;
                        }

                        routeParams.controller = ctrlRoute+'Ctrl';
                        // root ctrl
                    } else {
                        routeParams.controller = ucfirst(routeKey)+'Ctrl';
                    }
                }

                if (angular.isDefined(_settings_['css']))
                    routeParams.css = _settings_['css'];

                if (angular.isDefined(_settings_['guests']))
                    routeParams.guests = _settings_['guests'];

                // route resolver
                routeParams.resolve.i18n = function(cmBoot){
                    return cmBoot.isReady.i18n();
                };

                routeParams.resolve.font = function(cmBoot){
                    return cmBoot.isReady.font();
                };

                routeParams.resolve.keyboard = function(cmBoot){
                    return cmBoot.isReady.keyboard();
                };

                if (angular.isDefined(_settings_['waitForFirstBoot']) && _settings_['waitForFirstBoot'] == true){
                    routeParams.resolve.firstBoot = function(cmBoot) {
                        return cmBoot.isReady.firstBoot();
                    }
                }

                if (angular.isDefined(_settings_['waitForUserModel']) && _settings_['waitForUserModel'] == true){
                    routeParams.resolve.userModel = function(cmBoot) {
                        return cmBoot.isReady.userModel();
                    }
                }

                if (angular.isDefined(_settings_['waitForPurl']) && _settings_['waitForPurl'] == true){
                    routeParams.resolve.resolveData = function(cmBoot, $route) {
                        return cmBoot.isReady.purl($route.current.params.purlId);
                    }
                }

                if (angular.isDefined(_settings_['reloadOnSearch'])){
                    routeParams.reloadOnSearch = _settings_['reloadOnSearch'];
                }
                if(angular.isDefined(_settings_['isDefault'])){
                    routeParams.isDefault = _settings_['isDefault'];
                }

                // create route as defined or take simple route
                if(angular.isDefined(_settings_['routes']))
                    routes = _settings_.routes;
                else
                    routes.push('/'+routeKey);

                // add route to provider
                angular.forEach(routes,function(route){
                    $injector.get('$routeProvider').
                        when(route, routeParams);
                });
                // check otherwise
                if(angular.isDefined(_settings_['isDefault'])){
                    $injector.get('$routeProvider').otherwise({
                        redirectTo: '/'+routeKey
                    });
                }
            });
        }

        this.create = function(){
            createRoutes(cmConfigProvider.get('routes'));
        };

        this.$get = [
            'cmConfig',
            function(cmConfig){

            return {
                create: function() {
                    createRoutes(cmConfig.routes);
                }
            }
        }];
    }
])

.provider('cmWebworkerFactory',[

    function(){

        var default_global_limit    = 2,
            default_mobile_limit    = 2,
            default_app_limit       = 2,
            default_desktop_limit   = 5,
            limit                   = default_global_limit

        this.setGlobalDefaultLimit = function(l){
            default_global_limit = l || default_global_limit
            return this
        };

        this.setMobileDefaultLimit = function(l){
            default_mobile_limit = l || default_mobile_limit
            return this
        };

        this.setDesktopDefaultLimit = function(l){
            default_desktop_limit = l || default_desktop_limit
            return this
        };

        this.setAppDefaultLimit = function(l){
            default_desktop_limit = l || default_desktop_limit;
            return this
        };


        this.$get = [

            '$q',
            'cmFactory', 'cmObject', 'cmLogger', 'cmDevice',

            // this is not an angular factory but an anglar service, that uses the generic Factory Service oO
            function cmWebworkerFactory($q, cmFactory, cmObject, cmLogger, cmDevice){

                function cmWebworker(data){
                    var instance    =   this,
                        worker      =   undefined,
                        deferred    =   undefined,
                        onMessage   =   undefined

                    instance.params     =   data.params
                    instance.jobName    =   data.jobName

                    cmObject.addEventHandlingTo(instance)

                    this.run = function(timeout){

                        //if the worker is already running, return its promise
                        if(deferred)
                            return deferred.promise

                        instance.trigger("run", instance)

                        //console.warn('running WebWorker "'+data.jobName)

                        worker      = new Worker('webworker/'+data.jobName+'.js')
                        deferred    = $q.defer()

                        if(timeout)
                            $timeout(function(){ 
                                deferred.reject('timeout');
                                instance.cancel()
                            }, timeout);


                        onMessage   =   function(event){
                                            if(event.data.msg == 'finished'){
                                                deferred.resolve(event.data.result);
                                                instance.terminate()
                                            }

                                            if(['canceled', 'failed', 'error'].indexOf(event.data.msg) != -1){
                                                deferred.reject(event.data);
                                                instance.terminate()
                                            }

                                            if(event.data.msg == 'notify')
                                                deferred.notify(event.data)
                                        }

                        worker.addEventListener('message', onMessage)
                        worker.postMessage({
                            cmd:        'start',
                            params:     data.params
                        })


                        return deferred.promise
                    };

                    this.cancel = function(){                
                        worker.postMessage({cmd: 'cancel'})
                        return  deferred.promise
                                .catch(function(reason){
                                    return  data.msg == 'canceled'
                                            ?   $q.when('canceled')
                                            :   $q.reject(reason)
                                })
                    };

                    this.terminate = function(){
                        worker.removeEventListener('message', onMessage)
                        worker.terminate()
                        instance.trigger('done')

                    }

                    return instance
                }

                var self =  cmFactory(cmWebworker,
                                //sameByData:
                                function(instance, data){
                                    return      instance.jobName == data.jobName
                                            &&  JSON.stringify(instance.params) == JSON.stringify(data.params)
                                }, 
                                //sameByInstance:
                                function(instance1, instance2){
                                    return      instance1.jobName == instance2.jobName
                                            &&  JSON.stringify(instance1.params) == JSON.stringify(instance2.params)
                                }
                            )


                self.get = function(data){
                    if(!window.Worker)
                        return $q.reject('Browser does not support webWorkers.')

                    var worker      =   self.create(data),
                        promise     =   worker
                                        .when('available')
                                        .then(function(){
                                            //console.log('Worker available:', data.jobName)
                                            return $q.when(worker)
                                        })

                    //console.warn('new WebWorker "'+data.jobName+'" Number of queued webworkers: '+ self.length)


                    worker.on('done', function(event){
                        self.trigger('worker:done', worker)
                    })

                    worker.on('run', function(event, worker){

                    })

                    self.advance()

                    return  promise

                }

                self.advance = function() {
                    if (cmDevice.isApp())
                        limit = default_app_limit;
                    else if(cmDevice.isMobile('cmWebworkerFactory'))
                        limit = default_mobile_limit;
                    else if(cmDevice.isDesktop('cmWebworkerFactory'))
                        limit = default_desktop_limit;

                    for(var i = 0; i < limit; i++){
                        self[i] && self[i].trigger('available')
                    }

                    return this
                }

                self.on('worker:done', function(event, worker){
                    self.deregister(worker)
                    //console.info('Worker done; number of queued webworkers: ' + self.length)
                    self.advance()
                })

                return self
            }
        ]
    }

])
/**
 * @ngdoc service
 * @name cmAuth
 * @description
 * beschreibung cmAuth
 *
 * @requires cmApi
 * @requires localStorage TODO: implement ServiceLocalStorage
 */


    .service('cmAuth', [
    'cmApi','LocalStorageAdapter', 'cmObject', 'cmUtil', 'cmLogger', 'cmCrypt' ,'$rootScope',
    function(cmApi, LocalStorageAdapter, cmObject, cmUtil, cmLogger, cmCrypt, $rootScope){
        var _TOKEN_ = undefined;
        var auth = {
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name requestToken
             * @description
             * Ask the api for a new authentication token
             *
             * @param {String} login Loginname of user
             * @param {String} pass Password of user
             * @returns {Promise} for async handling
             */
            requestToken: function(login, pass){
                var auth = cmCrypt.base64Encode(login + ":" + pass);

                return cmApi.get({
                    path: '/token',
                    headers: { 'Authorization': 'Basic '+auth } ,
                    exp_ok: 'token'
                }, true)
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name removeToken
             * @description
             * Remove token from LocalStorage
             * Reset validate Token
             *
             * @returns {Boolean} for removing succeed
             */
            removeToken: function(where){
                cmLogger.debug('cmAuth.removeToken');

                /* reset validate Token */
                _TOKEN_ = undefined;
                if(_TOKEN_ != undefined){
                    cmLogger.warn('cmAuth.removeToken - validate Token not removed')
                }

                /* remove Token from LocalStorage */
                LocalStorageAdapter.remove('token');
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name storeToken
             * @description
             * Store the token in localstorage
             *
             * @param {String} token From Api given token
             * @param {Boolean} froce Force storeToken
             * @returns {Boolean} for setting succeed
             */
            storeToken: function(token, force){
                //cmLogger.debug('cmAuth.storeToken');

                if(typeof force != 'undefined' && force == true){
                    _TOKEN_ = token;
                    return LocalStorageAdapter.save('token', token);
                } else {
                    if(_TOKEN_ == undefined || _TOKEN_ == token){
                        _TOKEN_ = token;

                        var bool;
                        try {
                            bool = LocalStorageAdapter.save('token', token);
                        } catch(e){
                            cmLogger.warn('cmAuth.storeToken - Local Storage Error')
                        }

                        //return localStorage.setItem('token', token)/
                        return bool;
                    } else if(_TOKEN_ != token) {
                        cmLogger.debug('cmAuth.storeToken - Error - validateToken is different')
                    }
                }
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name getToken
             * @description
             * Retrieve the token from localstorage
             *
             * @returns {String} Token
             */
            getToken: function(){
                //cmLogger.debug('cmAuth.getToken')

                var token;

                try {
                    token = LocalStorageAdapter.get('token');

                    if(token !== undefined && token !== 'undefined' && token !== null && token.length > 0){
                        if(_TOKEN_ != undefined && _TOKEN_ != token){
                            $rootScope.$broadcast('logout',{where: 'cmAuth getToken failure'});
                            cmLogger.debug('cmAuth.getToken - Error - validateToken is different');

                            return false;
                        }
                    } else {
                        if(_TOKEN_ != undefined){
                            this.storeToken(_TOKEN_);
                            token = _TOKEN_;
                        }
                    }
                } catch (e){
                    cmLogger.warn('cmAuth.getToken - Local Storage Error')
                }

                return token;
            },

            getIdentityToken: function(identityId){
                return cmApi.get({
                    path: '/identity/'+identityId+'/token'
                })
            },

            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name createUser
             * @description
             * Create a user in database. Used by registration.
             *
             * @param {Object} data Compared object with userdata
             * @returns {Promise} for async handling
             */
            createUser: function(data){
                return cmApi.post({
                    path: '/account',
                    data: data
                })
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name checkAccountName
             * @description
             * Check in registration if the Username still not exists.
             *
             * @param {String} name Given username to check
             * @param {String} reservationSecret From api given token for Username
             * @returns {Promise} for async handling
             */
            checkAccountName: function(name){
                var apiCall = {
                    path: '/account/check',
                    data: {
                        loginName: name
                    }
                };

                return cmApi.post(apiCall);
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name checkPhoneNumber
             * @description
             * Check if the given phonenumber is a valid one.
             *
             * @param {String} number Given phonenumber for validation
             * @returns {Promise} for async handling
             */
            checkPhoneNumber: function(number){
                return cmApi.post({
                    path: '/services/checkPhoneNumber',
                    data: { phoneNumber:number },
                    exp_ok: 'phoneNumber'
                })
            },

            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name checkMixed
             * @description
             * Check if the given string is either a valid phone number or a valid e-mail address
             *
             * @param {String} string to validate
             * @returns {Promise} for async handling
             */

            checkMixed: function(mixed) {
                return cmApi.post({
                    path: '/services/checkMixed',
                    data: { mixed:mixed }
                })
            },

            getAccount: function(){
                return cmApi.get({
                    path: '/account'
                })
            },

            putAccount: function(data){
                var apiCall = {
                    path: '/account',
                    data: data
                };

                return cmApi.put(apiCall)
            },

            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name getIdentity
             * @description
             * Get an identity from api
             *
             * @param {String} id Identity id for cmIdentityModel
             * @returns {Promise} async handling
             */
            getIdentity: function(id){
                return cmApi.get({
                    path: '/identity'+ (id ? '/'+id : '')
                })
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name updateIdentity
             * @description
             * Update own Identity
             *
             * @param {Object} data Identity Parameter
             * @returns {Promise} async handling
             */
            updateIdentity: function(data){
                return cmApi.put({
                    path: '/identity',
                    data: data
                })
            },

            addIdentity: function(data){
                return cmApi.post({
                    path: '/identity',
                    data: data
                })
            },

            initialIdentity: function(data){
                var apiCall = {
                    path: '/identity/initial',
                    data: data
                };

                return cmApi.post(apiCall)
            },

            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name savePublicKey
             * @description
             * saved a identity public key
             *
             * @param {Object} data Object with name, key & keySize
             * @returns {Promise} for async handling
             */
            savePublicKey: function(data){
                return cmApi.post({
                    path: '/publicKey',
                    data: {
                        name: data.name,
                        key: data.key,
                        keySize: parseInt(data.keySize)
                    }
                })
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name removePublicKey
             * @description
             * removed a identity public key
             *
             * @param {String} keyId id of public key
             * @returns {Promise} for async handling
             */
            removePublicKey: function(keyId){
                return cmApi.delete({
                    path: '/publicKey/'+keyId
                })
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name savePublicKeySignature
             * @description
             * save a signature to a public key
             *
             * @param {String} keyId id of local key
             * @param {String} signKeyId id of signed key
             * @param {String} signature signature
             * @returns {Promise} for async handling
             */
            savePublicKeySignature: function(localKeyId, signKeyId, signature){
                return cmApi.post({
                    path: '/publicKey/' + signKeyId + '/signature',
                    data: {
                        keyId: localKeyId,
                        content: signature
                    }
                });
            },

            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name getBulkPassphrases
             * @description
             * get aePassphraseList for reKeying
             *
             * @param {String} keyId id of local key
             * @param {String} newKeyId id of new public key
             * @param {Integer} limit maximum answers in list
             * @returns {Promise} for async handling
             */
            getBulkPassphrases: function(keyId, newKeyId, limit){
                var queryString = cmUtil.handleLimitOffset(limit);

                if(queryString == ''){
                    queryString += '?newKeyId=' + newKeyId;
                } else {
                    queryString += '&newKeyId=' + newKeyId;
                }

                return cmApi.get({
                    path: '/publicKey/'+ keyId +'/aePassphrases' + queryString
                });
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name saveBulkPassphrases
             * @description
             * post new aePassphraseList for conversation
             *
             * @param {String} keyId id of public key
             * @param {Object} data new asymmetric encrypted passphrases
             * @returns {Promise} for async handling
             */
            saveBulkPassphrases: function(keyId, data){
                return cmApi.post({
                    path: '/publicKey/'+ keyId +'/aePassphrases',
                    data: data
                });
            },

            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name requestTwoFactorKey
             * @description
             * Two factor authentication
             *
             * @returns {Promise} for async handling
             */
            requestTwoFactorKey: function() {
                return cmApi.get({
                    path: '/twoFactorAuth'
                }, true)
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name requestTwoFactorToken
             * @description
             * Ask the api for a new authentication token
             *
             * @param {String} key Token for authentication
             * @returns {Promise} for async handling
             */
            requestTwoFactorToken: function(key){
                return cmApi.post({
                    path: '/twoFactorAuth/confirm',
                    data: { key: key },
                    exp_ok: "token"
                }, true)
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name removeTwoFactorToken
             * @description
             * Delete two factor token from localstorage
             *
             * @returns {Boolean} for removing succeed
             */
            removeTwoFactorToken: function(){
                return LocalStorageAdapter.remove('twoFactorToken');
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name storeTwoFactorToken
             * @description
             * Store the token in localstorage
             *
             * @param {String} twoFactorToken Token to store
             * @returns {Boolean} for setting succeed
             */
            storeTwoFactorToken: function(twoFactorToken){
                return LocalStorageAdapter.save('twoFactorToken', twoFactorToken);
            },
            /**
             * @ngdoc method
             * @methodOf cmAuth
             *
             * @name getTwoFactorToken
             * @description
             * Retrieve thr token from localstorage
             *
             * @returns {String} twoFactorToken
             */
            getTwoFactorToken: function(){
                return LocalStorageAdapter.get('twoFactorToken');
            },

            sendPasswordLost: function(data){
                return cmApi.post({
                    path: '/resetPassword',
                    data: data
                });
            },

            checkResetPassword: function(resetId){
                return cmApi.get({
                    path: '/resetPassword/'+resetId
                });
            },

            resetPassword: function(data, resetId){
                return cmApi.post({
                    path: '/resetPassword/'+resetId,
                    data: data
                });
            },

            sendVerification: function(type){
                var data = {};

                switch(type){
                    case 'phoneNumber':
                        data.verifyPhoneNumber = true;
                    break;
                    case 'email':
                        data.verifyEmail = true;
                    break;
                }

                cmApi.post({
                    path: '/verify',
                    data: data
                })
            },

            confirmVerification: function(secret){
                return cmApi.post({
                    path: '/verify/'+secret
                });
            }
        };

        cmObject.addEventHandlingTo(auth);

        cmApi.on('identity:update', function (event, data){
            //cmLogger.debug('cmAuth.on:identity:update')
            auth.trigger('identity:updated', data);
        });

        cmApi.on('identity:new', function (event, data){
            //cmLogger.debug('cmAuth.on:identity:new')
            auth.trigger('identity:new', data);
        });

        cmApi.on('conversation:new-aePassphrase', function(event, data){
            //cmLogger.debug('cmAuth.on:conversation:new-aePassphrase');
            auth.trigger('conversation:update', data);
        });

        cmApi.on('account:update', function (event, data){
            //cmLogger.debug('cmAuth.on:account:update')
            auth.trigger('account:update', data);
        });

        return auth;
    }
])
/**
 * @ngdoc service
 * @name cmAuthenticationRequest
 * @description
 * Handels authentication requests
 *
 * @requires cmApi
 * @requires cmObject
 * @requires cmLogger
 * @requires cmCrypt
 * @requires cmUserModel
 * @requires cmIdentityFactory
 * @requires cmModal
 * @requires cmCallbackQueue
 * @requires $rootScope
 * @requires $q
 */


.service('cmAuthenticationRequest', [
    'cmApi', 'cmObject', 'cmLogger', 'cmCrypt', 'cmUserModel', 'cmReKeying',
    'cmContactsModel', 'cmIdentityFactory', 'cmModal', 'cmCallbackQueue',
    '$rootScope', '$q',
    function(cmApi, cmObject, cmLogger, cmCrypt, cmUserModel, cmReKeying,
             cmContactsModel, cmIdentityFactory, cmModal, cmCallbackQueue,
             $rootScope, $q){

        var self = {
            /**
             * @ngdoc method
             * @methodOf cmAuthenticationRequest
             *
             * @name generateTransactionSecrete
             * @description
             * Generates a transaction seceret valid for a limited time
             */

            generateTransactionSecret: function(ttl){
                this.transactionSecret = {
                    content:    cmCrypt.generatePassword(8),
                    expires:    new Date().getTime() + (ttl || 60000)
                }
            },

            /**
             * @ngdoc method
             * @methodOf cmAuthenticationRequest
             *
             * @name getTransactionSecret
             * @description
             * Retrieves the transaction secret or null if expired
             *
             *  @returns {String} transaction secret or null if expired
             */
            
            getTransactionSecret: function(){
                return  this.transactionSecret && (new Date().getTime() < this.transactionSecret.expires)
                        ?   this.transactionSecret.content
                        :   null
            },

            /**
             * @ngdoc method
             * @methodOf cmAuthenticationRequest
             *
             * @name getTTL
             * @description
             * Retrieves time to the expireation of the transaction secret
             *
             *  @returns {Number} Time to expiration of transaction secret in milliseconds or 0, whatever ist greater
             */
            getTTL: function(){
                return (
                    this.transactionSecret
                    &&  Math.max(0, this.transactionSecret.expires - (new Date().getTime()))
                ) || 0
            },

            /**
             * @ngdoc method
             * @methodOf cmAuthenticationRequest
             *
             * @name send
             * @description
             * Sends an Authentication Request to all devices of an identity
             *
             * @param {Number} toIdentityId id to sending
             * @param {String} secret for handshake
             * @param {Number} toKeyId id of key to sending
             * @param {Number} fromKeyId id it was send
             *
             * @returns {Promise} for async handling
             */
            send: function(toIdentityId, secret, toKeyId, fromKeyId){
                var fromIdentity    =   cmUserModel.data.identity,
                    fromKey         =   cmUserModel.loadLocalKeys().find(fromKeyId) || cmUserModel.loadLocalKeys()[0],
                    salt            =   cmCrypt.generatePassword(32);

                return  cmCallbackQueue
                        .push(function(){
                            return  cmCrypt.hashObject({
                                        transactionSecret:  secret,
                                        cameoId:            fromIdentity.cameoId,
                                        salt:               salt
                                    })
                        },100)  // Leave the browser a tiny bit of time to breathe
                        .then(function(result){
                            return  cmCallbackQueue.push(function(){

                                        // if succesful result[0] contains hashed data returned by cmCrypt.hashObject
                                        return fromKey.sign(result[0])   

                                    }, 100); // Leave the browser a tiny bit of time to breathe
                        })
                        .then(function(result){
                            // if succesful result[0] contains the signature returned by fromKey.sign
                            return cmApi.broadcast({
                                    name:   'authenticationRequest:start',
                                    data:   {
                                                fromKeyId:      fromKey.id,
                                                fromIdentityId: fromIdentity.id,
                                                toKeyId:        toKeyId, // may be undefined
                                                salt:           salt,
                                                signature:      result[0]
                                            }
                                }, toIdentityId)

                        })
            },

            /**
             * @ngdoc method
             * @methodOf cmAuthenticationRequest
             *
             * @name  cancel
             * @description
             * Cancels an Authentication Request on all devices of an identity
             *
             * @param {String} [signature]  The signature sent with the authenticationRequest that should be canceled
             * @returns {Promise}           Promise that will be resolved after the event is posted to the backend.
             */

            cancel: function(toIdentityId){
                if(typeof toIdentityId != 'string'){
                    cmLogger.debug('cmAuthenticationRequest: cancel() toIdentityId must be string.')
                    return false
                }
                
                self.trigger('canceled');
                delete this.transactionSecret;

                return  cmApi.broadcast({
                            name:   'authenticationRequest:cancel',
                            data:   {}
                        }, toIdentityId);
            },


            /**
             * @ngdoc method
             * @methodOf cmAuthenticationRequest
             *
             * @name verify
             * @description
             * Verifies an Authentication Request
             *
             * @param {Object} request response from server
             * @param {String} secret for verfication
             *
             * @returns {Boolean} wether or not the request is valid
             */
            verify: function(request, secret){

                var fromIdentity    =   cmIdentityFactory.find(request.fromIdentityId),
                    hashed_data     =   cmCrypt.hashObject({
                                            transactionSecret:  secret,
                                            cameoId:            fromIdentity.cameoId,
                                            salt:               request.salt
                                        }),
                    fromKey         =   fromIdentity.keys.find(request.fromKeyId);


                return  fromKey.verify(hashed_data, request.signature)
                        .then(
                            function(result){
                                self.trigger('verification:successful', {
                                        identity:           fromIdentity,
                                        key:                fromKey,
                                        transactionSecret:  secret
                                });
                                return $q.when(result);
                            },
                            function(reason){
                                self.trigger('verification:failed');
                                return $q.reject(reason);
                            }
                        )
            }
        };

        cmObject.addEventHandlingTo(self);


        /**
         * Listen to Api events. When a start event occurs, check wether it is relevant for the current user.
         * If so trigger a local event in cmAuthenticationRequest.
         */

        cmApi.on('authenticationRequest:start', function(event, request){

            var local_keys = cmUserModel.loadLocalKeys();

            // If there are no local keys, there's nothing to authenticate with:
            if(local_keys.length == 0 ){
                cmLogger.debug('cmAuthenticationRequest: received request, but no local keys present.');
                return false; // do not remove event binding
            }


            // There is no need to authenticate local keys:
            if(local_keys.find(request.fromKeyId)){
                cmLogger.debug('cmAuthenticationRequest: received request, but key to be signed is local.');
                return false; // do not remove event binding
            }
            

            // If a certain key was expected to sign, but that key is not present on this device, dont prompt the user:
            if(request.toKeyId && !local_keys.find(request.toKeyId)){
                cmLogger.debug('cmAuthenticationRequest: received request, but requested private key to sign with is not present.');
                return false; // do not remove event binding
            }


            var fromIdentity = cmIdentityFactory.find(event.fromIdentityId)

            if(!fromIdentity){
                cmLogger.debug('cmAuthenticationRequest: received request, but sender is unknown.');

                return false; // do not remove event binding
            }

            if(cmUserModel.data.identity.id != event.fromIdentityId && cmContactsModel.findByIdentityId(event.fromIdentityId) == undefined){
                cmLogger.debug('cmAuthenticationRequest: received request, sender not accepted.');

                return false; // do not remove event binding
            }


            //If we dont know the key to sign:
            if(!fromIdentity.keys.find(request.fromKeyId)){
                cmLogger.debug('cmAuthenticationRequest: received request, key to be signed not at the proper identity.');
                return false; // do not remove event binding
            }

            self.trigger('started', request);
        });


        /**
         * Listen to Api events. When a cancel event occurs, force sender into data object and trigger local event.
         * It is important to know the sender so that 3rd party identities cannot cancel your events. 
         */
        cmApi.on('authenticationRequest:cancel', function(event, data){
            data = data || {};
            data.fromIdentityId = event.fromIdentityId;
            self.trigger('canceled', data);
        });

        /**
         * Listen to events on cmAuthenticationRequest.
         */

        self.on('started', function(event, request){

            //Prevent other authentication requests to interfere with an ongoing process:
            var modal = cmModal.instances['incoming-authentication-request'];

            if(modal && modal.isActive()){
                // If request comes from the same origin as the ongoing request then update:
                if(modal.request.fromIdentityId == request.fromIdentityId)
                    modal.request = request;
                
                return false; // do not remove event binding
            }


            // Close other authentication request related modals:
            cmModal.close('authentication-request-successful');
            cmModal.close('authentication-request-canceled');


            var transactionSecret = self.getTransactionSecret();


            // If we already know the transaction secret, there is no need to prompt the user:
            if(transactionSecret){
                cmCallbackQueue.push(function(){
                    self.verify(request, transactionSecret)
                });
                return false; // do not remove event binding
            }


            /** Use a modal from here on **/


            // new scope for a modal to open below
            var modal_scope   =   $rootScope.$new(),
                is3rdParty    =   request.fromIdentityId != cmUserModel.data.identity.id,
                fromIdentity  =   cmIdentityFactory.find(request.fromIdentityId),
                fromKey       =   fromIdentity.keys.find(request.fromKeyId);

            modal_scope.error   =   {};
            modal_scope.request =   request;     //stored for later use, if another authentication request with the same origin occurs

            modal_scope.verify  =   function(secret){
                var scope = this;

                if(scope.isIdle())
                    return false;

                scope.startLoader();

                scope.error.emptyInput    = !secret;
                scope.error.wrongSecret   = !scope.error.emptyInput && !self.verify(scope.request, secret)

                $q.reject()
                .catch(function(){
                    return scope.error.emptyInput
                    ?   $q.reject('empty input.')
                    :   self.verify(scope.request, secret)
                })
                .catch(function(error){
                    scope.error.wrongSecret = true;
                    return $q.reject('verification failed.')
                })
                .then(function(res){
                    // Modal is no longer needed:
                    scope.stopLoader();
                    cmModal.close('incoming-authentication-request');

                    // Double check and make sure that only the key gets signed that was actually verified above:
                    // Also: We need variables, because scope gets destroyed once the modal is closed.
                    var fromIdentity    =   cmIdentityFactory.find(scope.request.fromIdentityId),
                        fromKey         =   fromIdentity.keys.find(scope.request.fromKeyId),
                        is3rdParty      =   fromIdentity != cmUserModel.data.identity,
                        toKey           =   (
                                                    scope.request.toKeyId
                                                &&  cmUserModel.loadLocalKeys().find(scope.request.toKeyId)
                                            )
                                            ||  cmUserModel.loadLocalKeys()[0]


                    return      fromIdentity    == scope.fromIdentity
                            &&  fromKey         == scope.fromKey

                            ?   cmUserModel.signPublicKey(fromKey, fromKey.id, fromIdentity)
                                .then(function(){
                                    return  $q.when({
                                                fromIdentity:   fromIdentity,
                                                fromKey:        fromKey,
                                                toKey:          toKey,
                                                secret:         secret
                                            })
                                })
                            :   $q.reject('double check failed.')

                })
                .then(function(data){

                    if(is3rdParty === false){
                        cmReKeying.process(data.toKey.id);
                    } else {
                       // do nothing
                    }

                    //Send a request in return:
                    self.send(
                        data.fromIdentity.id,    //Sender of the initial requests
                        data.secret,             //The secret we successfully used during the last attempt
                        data.fromKey.id          //The key that originally requested to be signed
                    )
                }, function(){
                    scope.stopLoader();
                })
            };

            cmModal.create({
                id:             'incoming-authentication-request',
                type:           'plain',
                'class':        'no-padding',
                'cm-close-btn': false,
                'cm-title':     is3rdParty
                                ?   'IDENTITY.KEYS.TRUST.ENTER_TRANSACTION_SECRET.HEADER'
                                :   'IDENTITY.KEYS.AUTHENTICATION.ENTER_TRANSACTION_SECRET.HEADER'
            },'<cm-incoming-authentication-request></cm-incoming-authentication-request>', null, modal_scope);

            cmModal.open('incoming-authentication-request');

            /**
             * Listen to local events. Wait for a cancel event to close the Modal.
             */


            self.one('canceled', function(event, data){
                var modal = cmModal.instances['incoming-authentication-request'];

                // If some other authentication request is meant to be canceled:
                if(modal && data && (modal.request.fromIdentityId != data.fromIdentityId)){
                    cmLogger.debug('cmAuthenticationRequest, received cancel event, but with different origin or inactive modal.')
                    return false;    // dont remove the event binding
                }

                // Only show the cancelation modal if a authentication modal was actually present:
                if(modal && modal.isActive()){
                    cmModal.close('incoming-authentication-request');

                    cmModal.create({
                        id:             'authentication-request-canceled',
                        type:           'alert',
                        'cm-close-btn': false
                    },  is3rdParty
                        ?   '{{"IDENTITY.KEYS.TRUST.MODAL.CANCELED"|cmTranslate}}'
                        :   '{{"IDENTITY.KEYS.AUTHENTICATION.MODAL.CANCELED"|cmTranslate}}');

                    cmModal.open('authentication-request-canceled', null, 2000);

                    return true;    //remove the event binding
                }

                return false;
                
            });

        });

        return self;
    }
])
// TODO: doku and tests

.service('cmBoot', [
    'cmObject', 'cmLogger', 'cmKeyboard',
    '$q', '$rootScope', '$document', '$injector',
    function(cmObject, cmLogger, cmKeyboard,
             $q, $rootScope, $document, $injector) {
        var promises = {};

        function reset(){
            //promises = {};
            delete promises.userModel;
        }

        $rootScope.$on('logout', function(){
            reset();
        });

        $rootScope.$on('identity:switched', function(){
            reset();
        });

        $rootScope.$on('cmBoot:appSpinner', function(event, action, where){
            angular.element($document[0].querySelector('.app-spinner'))
                .toggleClass('cm-hide',action == 'hide'?true:false);
        });

        $rootScope.$on('$routeChangeSuccess',function(){
            var currentRoute = $injector.get('$route').current.$$route;
            if(currentRoute)
                $rootScope.$broadcast('cmBoot:appSpinner','hide','routeSuccess');
        });

        var self = {
            init: {
                userModel: function(){
                    if(!('userModel' in promises)){
                        promises.userModel = $q.defer();

                        self.on('userModel:ready',function(){
                            promises.userModel.resolve();
                        });
                    }
                }
            },

            isReady: {
                font: function(){
                    if(!('font' in promises)){
                        promises.font = $q.defer();

                        // add cm-rhino-bubble-glyph as unicode glyph
                        FontLoader.referenceText += "\uf044";

                        var fontLoader = new FontLoader(['CameoFont'], {
                            fontsLoaded: function(error) {
                                if (error !== null && error.notLoadedFontFamilies.length > 0) {
                                    cmLogger.error('cmBoot: '+error.message+' '+error.notLoadedFontFamilies);
                                }
                                promises.font.resolve();
                            },
                            fontLoaded: function(fontFamily) {
                                promises.font.resolve();
                            }
                        }, 3000);
                        fontLoader.loadFonts();
                    }

                    return promises.font.promise;
                },
                i18n: function(){
                    if(!('i18n' in promises)){
                        promises.i18n = $q.defer();

                        $rootScope.$on('$translateLoadingSuccess', function(){
                            promises.i18n.resolve();
                        });
                    }

                    return promises.i18n.promise;
                },
                keyboard: function(){
                    if(cmKeyboard.existsPlugin() && cmKeyboard.isVisible()){
                        var defer = $q.defer();

                        cmKeyboard.close();

                        cmKeyboard.one('hidden', function(){
                            defer.resolve();
                        });
                        return defer.promise;
                    } else {
                        return $q.when();
                    }
                },
                firstBoot: function(){
                    promises.firstBoot = $q.when();
                    // propably waiting for account, browserinfo etc.

                    //$timeout(function(){
                    //    console.log('firstboot ready')
                    //    promises.firstBoot.resolve();
                    //},2000);

                    return promises.firstBoot.promise;
                },
                userModel: function(){
                    self.init.userModel();

                    return promises.userModel.promise;
                },
                purl: function(idPurl){
                    return $injector.get('cmPurlModel').getPurl(idPurl).catch(function(r){return $q.when(r)});
                }
            },

            ready: {
                userModel: function(){
                    //cmLogger.debug('usermodel ready')

                    self.init.userModel();

                    self.trigger('userModel:ready');
                },
                account: function(){
                    //cmLogger.debug('account ready')
                },
                browserInfo: function(){
                    //cmLogger.debug('browserinfo ready')
                }
            }
        };

        cmObject.addEventHandlingTo(self);

        return self;
    }
])
.service('cmBrowserNotifications', [
    'cmConfig',
    'cmSettings',
    'cmApi',
    'cmDevice',
    'cmVisibility',
    'cmLogger',
    'cmUserModel',
    'cmIdentityModel',
    '$rootScope',
    '$window',
    '$filter',
    '$timeout',
    function(cmConfig, cmSettings, cmApi, cmDevice, cmVisibility, cmLogger, cmUserModel, cmIdentityModel, $rootScope, $window, $filter, $timeout){
        var self = this,
            tabVisibility = true;

        /**
         * Service initialize
         */
        function init(){
            //cmLogger.debug('cmBrowserNotifications.init');
            cmVisibility.add('cmBrowserNotifications', checkBrowserVisibility)
        }

        /**
         * Callback for cmVisibility Server
         * @param isHidden {boolean}
         */
        function checkBrowserVisibility(isHidden){
            //cmLogger.debug('cmBrowserNotifications.checkBrowserVisibility');
            tabVisibility = !isHidden;
        }

        /**
         * Callback for Notification Clicks
         */
        function callbackOnClick(){
            //cmLogger.debug('cmBrowserNotifications.callbackOnClick');

            try {
                $window.focus();
            } catch (e) {
                // doesn't matter
            }
        }

        /**
         * Close Notification
         * @param notification {object}
         */
        function close(notification){
            //cmLogger.debug('cmBrowserNotifications.close');

            notification.close();
        }

        /**
         * check if Notification API exists in Browser
         * @returns {boolean}
         */
        this.checkBrowser = function(){
            //cmLogger.debug('cmBrowserNotifications.checkBrowser');

            if(!cmDevice.isApp() && "Notification" in $window) {
                return true;
            }

            return false;
        };

        /**
         * check Notification Permission
         * @returns {boolean}
         */
        this.checkPermission = function(){
            //cmLogger.debug('cmBrowserNotifications.checkPermission');

            if(Notification.permission === "granted"){
                return true;
            }

            return false;
        };

        /**
         * start Permission Request
         */
        this.askPermission = function(notify){
            //cmLogger.debug('cmBrowserNotifications.askPermission');

            if(this.checkBrowser() && !this.checkPermission()){
                Notification.requestPermission(function (permission) {
                    if (permission === "granted") {
                        cmSettings.set('browserNotifications', true);

                        self.show(notify);
                    } else if(permission !== 'granted'){
                        cmSettings.set('browserNotifications', false);
                    }
                });
            }
        };

        /**
         * initialize a new notification
         * @param notify {object}
         */
        this.show = function(notify){
            //cmLogger.debug('cmBrowserNotifications.show');

            if(this.checkBrowser() && this.checkPermission() && cmSettings.get('browserNotifications') && typeof notify == 'object'){

                var title = $filter('cmTranslate')('CAMEO.NAME') + ' - ' + notify.title;

                var options = {
                    body: notify.body,
                    icon: $window.location.origin + $window.location.pathname + cmConfig.static.appIcon
                };

                var notification = new Notification(title, options);

                if(typeof notify.callbackOnClick == 'function'){
                    notification.onclick = notify.callbackOnClick;
                } else {
                    notification.onclick = callbackOnClick;
                }

                $timeout(function(){
                    close(notification);
                }, cmConfig.browserNotificationTimeout)

           } else if(cmSettings.get('browserNotifications')) {
                this.askPermission(notify);
                cmLogger.debug('cmBrowserNotifications.send:nope!')
            }
        };

        /**
         * Adapter Function for Friend Request Notifications
         * show Notification only if Tab/Browser are inactive
         *
         * @param identity {object} cmIdentityModel
         */
        this.showFriendRequest = function(identity){
            //cmLogger.debug('cmBrowserNotifications.showFriendRequest');
            if(identity instanceof cmIdentityModel && cmUserModel.data.identity.id != identity.id){
                if(!tabVisibility){
                    this.show({
                        title: $filter('cmTranslate')('SYSTEM.EVENTS.FRIEND_REQUEST.TITLE'),
                        body: $filter('cmTranslate')('SYSTEM.EVENTS.FRIEND_REQUEST.MSG', {sender: identity.getDisplayName()}),
                        callbackOnClick: function(){
                            try {
                                $rootScope.goTo('/contact/request/list');

                                $window.focus();
                            } catch (e) {
                                // doesn't matter
                            }
                        }
                    });
                }
            }
        };

        /**
         * Adapter Function for new Message Notifications
         * show Notification only if Tab/Browser is active and Route is not current Conversation or if Tab/Browser is inactive
         *
         * @param identity {object} cmIdentityModel
         * @param conversationId {string}
         */
        this.showNewMessage = function(identity, conversationId){
            //cmLogger.debug('cmBrowserNotifications.showNewMessage');

            if(identity instanceof cmIdentityModel && cmUserModel.data.identity.id != identity.id){

                if(typeof conversationId == 'string' && (!$rootScope.checkConversationRoute(conversationId) || !tabVisibility)){
                    this.show({
                        title: $filter('cmTranslate')('SYSTEM.EVENTS.NEW_MESSAGE.TITLE'),
                        body: $filter('cmTranslate')('SYSTEM.EVENTS.NEW_MESSAGE.MSG',{sender: identity.getDisplayName()}),
                        callbackOnClick: function(){
                            try{
                                if(!$rootScope.checkConversationRoute(conversationId) && !$rootScope.checkPurlRoute()){
                                    $rootScope.goTo('/conversation/' + conversationId);
                                }

                                $window.focus();
                            } catch(e){
                                // doesn't matter
                            }
                        }
                    });
                }
            }
        };

        init();
    }
])

.service('cmCrypt',[
    'cmUtil', 'cmLogger', 'cmKey', 'cmWebworkerFactory', 'cmCryptoHelper',
    '$q', '$interval', '$rootScope',
    function (cmUtil, cmLogger, cmKey, cmWebworker, cmCryptoHelper,
              $q, $interval, $rootScope) {
        // private vars
        var async = {
            interval: null,
            promise: null,
            crypt: null
        };

        var keygenWorker

        return {

            randomString: function (length, smallAlphabet) {
                var alphabet = smallAlphabet ? "abcdefghijklmnopqrstuvwxyz0123456789" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                var randomInts;

                // First we're going to try to use the browsers RNG
                if (window.crypto && window.crypto.getRandomValues) {
                    randomInts = new Int32Array(length);
                    window.crypto.getRandomValues(randomInts);
                }
                // Of course IE calls it msCrypto instead of being standard
                else if (window.msCrypto && window.msCrypto.getRandomValues) {
                    randomInts = new Int32Array(length);
                    window.msCrypto.getRandomValues(randomInts);
                }
                // So, no built-in functionality - bummer. If the user has wiggled the mouse enough,
                // sjcl might help us out here
                else if (sjcl.random.isReady()) {
                    randomInts = sjcl.random.randomWords(length);
                }
                // Last resort - we'll use isaac.js to get a random number. It's seeded from Math.random(),
                // so this isn't ideal, but it'll still greatly increase the space of guesses needed to crack the password.
                else {
                    cmLogger.warn("Random Number Generator: not enough entropy, using weak seed")
                    randomInts = [];
                    for (var i = 0; i < length; i++) {
                        randomInts.push(isaac.rand());
                    }
                }

                var randomWord = ""
                // use random ints to select char from alphabet
                for (var i = 0; i < length; i++) {
                    var index = Math.abs(randomInts[i]) % alphabet.length
                    randomWord += alphabet[index]
                }
                return randomWord;
            },

            /**
             * this method calculates a secure hash
             * @param secretString String that should be hashed
             */

            hash: function (secretString) {
                if (typeof secretString != 'string' || secretString.length == 0)
                    throw "cmCrypt.hash(): invalid argument."

                return sjcl.codec.base64.fromBits(sjcl.hash.sha256.hash(secretString))
            },
            /**
             * [hashObject description]
             * @param  {[type]} obj         [description]
             * @param  {[type]} hash_method [description]
             * @return {[type]}             [description]
             */
            hashObject: function(obj, sortHelper){
                var visited = []

                function sortByIdentifier(arr, identifier) {
                    return arr.sort(function(a, b) {
                        var x = a[identifier].toLowerCase();
                        var y = b[identifier].toLowerCase();
                        return x < y ? -1 : x > y ? 1 : 0;
                    });
                }

                function objectToArray(obj, name){

                    if(visited.indexOf(obj) != -1)
                        throw "Error: cmCrypt.hashObject() unable to hash cyclic Objects."


                    if(typeof obj == "string") return obj;
                    if(typeof obj == "number") return obj.toString();

                    if(["[object Object]", "[object Array]"].indexOf(Object.prototype.toString.call(obj)) == -1)
                        throw "Error: cmCrypt.hashObject() unable to hash Objects with values like " + Object.prototype.toString.call(obj);

                    var keys;

                    if(typeof name == 'string' && sortHelper && cmUtil.objLen(sortHelper) > 0 && cmUtil.isArray(obj)){
                        Object.keys(sortHelper).map(function(arrayKey){
                            if(arrayKey == name){
                                keys = Object.keys(sortByIdentifier(obj,sortHelper[arrayKey]));
                            }
                        })
                    }

                    if(!keys){
                        keys = Object.keys(obj).sort();
                    }

                    visited.push(obj);

                    var values = keys.map(function(key){ return objectToArray(obj[key], key) });

                    return [keys, values];
                }

                return this.hash(JSON.stringify(objectToArray(obj)))
            },

            /**
             * this methods encodes a string base64
             * @param string
             * @returns {*}
             */
            base64Encode: function(string){
                return _Base64.encode(string);
            },

            /**
             * this method decodes a string base64
             * @param string
             * @returns {*}
             */
            base64Decode: function (string) {
                return _Base64.decode(string);
            },

            /**
             * this method encrypts strings
             * @param secretKey a secret key with max len of 10 chars
             * @param secretString a string that should be enrypted
             * @returns base64 encoded encrypted string
             */
            encryptWithShortKey: function (secretKey, secretString) {
                var parameters = { cipher: "aes", ks: 256, iter: 4096 };

                if (typeof secretKey != 'string' || secretKey.length < 3) { //Todo! key sollte länger sein
                    cmLogger.warn('cmCrypt.encryptWithShortKey(): unable to encrypt, invalid key. ' + secretKey)
                    return "";
                }


                if (null == secretString)
                    return "";

                var encryptedSecretString = sjcl.json.encrypt(String(secretKey), String(secretString), parameters);

                return encryptedSecretString;
            },

            /**
             * this method encrypts strings
             * @param secretKey a secret key with min len of 60 chars
             * @param secretString a string that should be encrypted
             * @returns base64 encoded encrypted string
             */
            encrypt: function (secretKey, secretString) {
                var parameters = {cipher: "aes", ks: 256, iter: 500 };

                if(typeof secretKey != 'string' || secretKey.length < 1){ //Todo: längere Keys verlangen
                    cmLogger.warn('cmCrypt.encrypt(): unable to encrypt, invalid key.'+secretKey)
                    return "";
                }

                if (null == secretString)
                    return "";

                if (secretKey.length < 60) {
                    cmLogger.debug("cmCrypt.encrypt(): key too short.")
                    return "";
                }


                var encryptedSecretString = sjcl.json.encrypt(String(secretKey), String(secretString), parameters);

                return encryptedSecretString;
            },
            /**
             * this method decrypts uuencoded strings
             * @param secretKey a secret key
             * @param secretString a base64 encoded string that should be decrypted
             * @returns decrypted string or false if unable to decrypt
             */
            decrypt: function (secretKey, secretString) {

                if (secretString != '' && typeof secretString == 'object') {
                    secretString = JSON.stringify(secretString)
                }

                if (typeof secretKey != 'string' || secretKey.length < 1) {
                    return false;
                }

                if (null == secretString)
                    return false;

                var decryptedString;

                try {
                    decryptedString = sjcl.decrypt(secretKey, secretString)
                } catch (e) {
                    //                    cmLogger.warn('Unable to decrypt.', e)
                    //                    console.warn(e)
                }

                return decryptedString || false
            },

            /**
             * return the bit size of possible keygeneration
             * @returns {string[]}
             */
            getKeySizes: function () {
                return ['2048', '4096'];
            },

            /**
             * start async process
             * @param keylen
             * @param $scopeState
             * @returns {Promise.promise|*|webdriver.promise.Deferred.promise}
             */
            generateAsyncKeypair: function(keySize){
                if (keySize == undefined ||
                    typeof keySize != 'number') {
                    return false;
                }

                var self = this;

                async.promise = $q.defer();
                // start keygen over plugin crypto helper
                if(cmCryptoHelper.isAvailable()) {
                    cmCryptoHelper.getPrivateKey(keySize)
                        .then(function (privKey) {
                            var key = (new cmKey()).setKey(privKey);
                            async.promise.resolve({
                                timeElapsed: 0,
                                key: key
                            });
                        });
                    // start keygen over webworker
                } else {
                    cmWebworker.get({
                        jobName :   'rsa_keygen',
                        params  :   { keySize: keySize }
                    })
                        .then(
                        function(worker){
                            keygenWorker = worker

                            worker.run()
                                .then(
                                function(result){
                                    var key = (new cmKey()).setKey(result.privKey);

                                    async.promise.resolve({
                                        timeElapsed:    result.timeElapsed,
                                        key:            key
                                    })
                                },
                                function(reason){
                                    console.log('Webworker "keygen" failed', reason)
                                    async.promise.reject(reason);
                                }
                            )
                        },
                        function(){
                            var time = -((new Date()).getTime()),
                                counts = 0;

                            // init vars
                            async.crypt = new JSEncrypt({default_key_size: keySize})

                            // start keypair generation
                            async.crypt.getKey(function () {

                                // only resolve if keypair exists
                                if (async.crypt.getPrivateKey() == undefined)
                                    return false;

                                self.cancelGeneration(true);
                                if (async.promise != null) {
                                    async.promise.resolve({
                                        timeElapsed:    (time + ((new Date()).getTime())),
                                        counts:         counts,
                                        key:            async.crypt
                                    });
                                    // !!! important for unit test, don't remove !!!
                                    $rootScope.$apply();
                                }
                            })
                        }
                    )
                }

                return async.promise.promise;
            },

            generateSyncKeypair: function(keySize){
                if (keySize == undefined ||
                    typeof keySize != 'number') {
                    return false;
                }
                var crypt = new JSEncrypt({default_key_size: keySize});
                crypt.getKey();
                return crypt.getPrivateKey();
            },
            /**
             * cancel key generation process / simple clearInterval
             * if interval is pending
             * @returns {boolean}
             */
            cancelGeneration: function(withoutReject){
                if(cmWebworker.available){
                    return keygenWorker.cancel()
                } else if(async.crypt != null){
                    // clear promise and library vars if param withReject is true
                    if(withoutReject == undefined) {
                        async.crypt.cancelAsync();
                        async.promise.reject();
                    }
                    return $q.when(true);
                }
                return $q.when(false);
            },

            generatePassword: function (length) {
                return this.randomString(length || 10, true)
            },

            generatePassphrase: function () {
                return this.randomString(60, false)
            },

            //Todo check if te follwoing is still needed

            // /**
            //  * generateTransactionSecret
            //  * @returns {String} transactionSecret
            //  */
            // generateTransactionSecret: function () {
            //     return this.generatePassword(6);
            // },

            // /**
            //  * signAuthenticationRequest
            //  * @param _settings_
            //  * @returns {String} rsaSha256Signature of newPrivKey
            //  */
            // signAuthenticationRequest: function (_settings_) {
            //     var defaultSettings = {
            //             identityId: 0,
            //             transactionSecret: '',
            //             fromKey: undefined,
            //             toKey: undefined
            //         },
            //         dataForHandshake = {
            //             signature: '',
            //             encryptedTransactionSecret: '',
            //             fromKeyId: 0,
            //             fromKeyFingerprint: '',
            //             toKeyId: 0,
            //             toKeyFingerprint: ''
            //         },
            //         settings = angular.extend({}, defaultSettings, _settings_);

            //     if (!(settings.fromKey instanceof cmKey)) {
            //         cmLogger.error('sign fromKey isn\'t a cmKey');
            //         return null;
            //     }
            //     if (!(settings.toKey instanceof cmKey)) {
            //         cmLogger.error('sign toKey isn\'t a cmKey');
            //         return null;
            //     }

            //     dataForHandshake.fromKeyId = settings.fromKey.id;
            //     dataForHandshake.fromKeyFingerprint = settings.fromKey.getFingerprint();

            //     dataForHandshake.toKeyId = settings.toKey.id;
            //     dataForHandshake.toKeyFingerprint = settings.toKey.getFingerprint();

            //     dataForHandshake.encryptedTransactionSecret = settings.toKey.encrypt(settings.transactionSecret);

            //     var signData = {
            //         identityId: settings.identityId,
            //         encryptedTransactionSecret: dataForHandshake.encryptedTransactionSecret
            //     };


            //     dataForHandshake.signature = settings.fromKey.sign(this.hashObject(signData));

            //     return dataForHandshake;
            // },

            // /**
            //  * verifyAuthenticationRequest
            //  * @param _settings_
            //  * @returns {Boolean} is verification valid of newPubKey
            //  */
            // verifyAuthenticationRequest: function (_settings_) {
            //     var defaultSettings = {
            //             identityId: '',
            //             fromKey: undefined,
            //             encryptedTransactionSecret: '',
            //             signature: ''
            //         },
            //         settings = angular.extend({}, defaultSettings, _settings_);

            //     if (!(settings.fromKey instanceof cmKey)) {
            //         cmLogger.error('sign fromKey isn\'t a cmKey');
            //         return false;
            //     }

            //     var verifyData = {
            //         identityId: settings.identityId,
            //         encryptedTransactionSecret: settings.encryptedTransactionSecret
            //     };

            //     return settings.fromKey.verify(this.hashObject(verifyData), settings.signature);
            // },

            // isTransactionSecretValid: function (_settings_) {
            //     var defaultSettings = {
            //             userInput: '', //
            //             toKey: undefined,
            //             encryptedTransactionSecret: ''
            //         },
            //         settings = angular.extend({}, defaultSettings, _settings_);

            //     return settings.toKey.decrypt(settings.encryptedTransactionSecret) == settings.userInput;
            // }
        }
    }
])

.service('cmErrorCodes', [
    function(){

        var self = {
            toI18n: function(errorCode, data){
                var i18n = {};
                switch(errorCode){
                    case 'FILE.UPLOAD.QUOTA.EXCEEDED':
                        i18n = {
                            totalQuota: data.error.totalQuota,
                            quotaLeft: data.error.quotaLeft,
                            fileSize: data.error.fileSize
                        };
                    break;
                    case 'FILE.UPLOAD.FILESIZE.EXCEEDED':
                        i18n = {
                            fileSize: data.headers['X-File-Size'],
                            fileName: data.headers['X-File-Name'],
                            maxFileSize: data.error.maxFileSize
                        };
                    break;
                }
            return i18n;
            }
        };

        return self;
    }
])

.service('cmError', [
    '$rootScope',
    '$window',
    '$injector',
    function($rootScope, $window, $injector){
        var self = {
            showOnPage: function(error){
                $rootScope.errorThrown = error;
                $rootScope.goto('/error');
            }
        };

        $window.onerror = function(msg, url, line, col, error) {
            self.showOnPage({
                jserror: msg,
                location: $injector.get('$location').$$path,
                script: url,
                at: line+':'+col,
                error: error
            });
            //window.location.href = window.location.pathname + '#/error';
            return false;
        };

        return self;
    }
])
.factory('$exceptionHandler', [
    'cmLogger',
    '$injector',
    function (cmLogger,
              $injector) {
        return function (exception, cause) {

            var stack = undefined;

            try{
                stack = (exception.stack+'');

                var error = {
                    location:   $injector.get('$location').$$path,
                    exception:  exception,
                    msg:        exception.message,
                    stack:      stack.replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, ' \n'),
                    cause:      cause
                };

                cmLogger.error(JSON.stringify(error,null,2));

                if(typeof exception == 'object' && 'message' in exception && exception.message.indexOf('defined') >= 0){
                    $injector.get('cmError').showOnPage(error);
                }

            } catch(e){
                cmLogger.error('stack permission denied:' +e);
            }
            //throw exception;
        };
    }
])
/*
 var event = document.createEvent('HTMLEvents')
 event.initEvent('backbutton', true, true)
 document.dispatchEvent(event)

 http://stackoverflow.com/questions/15813850/detect-history-back-using-angular
*/


.service('cmHistory', [
    '$window', '$rootScope', '$location',
    function($window, $rootScope, $location){
        var self = {
            stack: [],
            add: function(url){
                this.stack.push(url);
            },
            removeLast: function(){
                this.stack.pop();
            },
            reset: function(){
                this.stack = [];
            },
            comesFrom: function(url){
                return this.stack.length > 1 && this.stack[this.stack.length - 2] == url;
            },
            isEmpty: function(){
                return this.stack.length == 0
                    || $rootScope.actualLocation == '/talks'
                    || $rootScope.actualLocation == '/login';
            },
            getPrev: function(){
                return !this.isEmpty()
                    ? this.stack[this.stack.length - 1]
                    : '';
            },
            goBack: function(){
                $rootScope.goBack();
            }
        };

        // detect back button event of browser
        $rootScope.$on('$locationChangeSuccess', function() {
            $rootScope.actualLocation = $location.path();
        });

        $rootScope.$watch(
            function(){return $location.path()},
            function (newLocation) {
                if($rootScope.actualLocation === newLocation) {
                    self.removeLast();
                }
            }
        );

        // detect route change
        $rootScope.$on('$routeChangeSuccess', function(){
            var current = $location.$$path;

            // clear history in some cases
            if(current.indexOf('/login') != -1) {
                self.reset();
                // push new route
            } else if(current !== self.getPrev()) {
                self.add($location.$$path);
            }
        });

        return self;
    }
])
.service('cmJob', [
    '$rootScope',
    '$window',
    '$location',
    'cmTranslate',
    'cmModal',
    'cmLogger',
    function($rootScope, $window, $location, cmTranslate, cmModal, cmLogger){

        var jobIsActive = false,
            jobi18n = '',
            jobFunctionUnbind = null,
            pendingUrl = {path:'',replace:false};

        function resetPendingUrl(){
            cmLogger.debug('cmJob.resetPendingUrl');
            pendingUrl = {path:'',replace:false}
        }

        return {
            isActive: function(){
                //cmLogger.debug('cmJob.isActive');
                return jobIsActive;
            },
            start: function(message, cancelCallback){
//                cmLogger.debug('cmJob.start '+message);
                jobIsActive = true;

                cmTranslate(message||'JOB.IN_PROGRESS').then(function(_jobi18n_){
                    jobi18n = _jobi18n_;
                });

                $window.onbeforeunload = function () {
                    return jobi18n;
                };

                jobFunctionUnbind = $rootScope.$on('$locationChangeStart', function(event, next) {
                    event.preventDefault();

                    cmModal.confirm({
                        text:   message,
                        cancel: 'NO',
                        okay:   'YES'
                    })
                    .then(function(){
                        if(typeof cancelCallback == 'function'){
                            cancelCallback();
                        }

                        stop();

                        if(pendingUrl.path != ''){
                            $rootScope.goTo(pendingUrl.path, pendingUrl.replace);
                        } else {
                            $rootScope.goBack();
                        }
                    });
                });
            },
            stop: function(){
//                cmLogger.debug('cmJob.stop');
                jobIsActive = false;

                $window.onbeforeunload = null;

                if(jobFunctionUnbind)
                    jobFunctionUnbind();
            },
            setPendingUrl: function(path, replace){
                //cmLogger.debug('cmJob.setPendingUrl ' + path);

                if(typeof path == 'string' && path.length > 0){
                    pendingUrl.path = path;

                    if(replace){
                        pendingUrl.replace = replace;
                    }

                    $rootScope.$broadcast('$locationChangeStart');
                }
            }
        }
    }
])
/**
 * @ngdoc object
 * @name LocalStorageAdapter
 * @description
 */
.service('LocalStorageAdapter', [
'$window',
'cmLogger',
function($window, cmLogger){
    return {
        /**
         * check usability in browser
         * @returns {boolean}
         */
        check: function(){
            try {
                return 'localStorage' in $window && $window['localStorage'] !== null;
            } catch(e){
                cmLogger.warn('LocalStorage Check - ' + e)
                return false;
            }
        },
        /**
         * returns a value from a key
         * @param key
         * @returns {*}
         */
        get: function (key) {
            try {
                return $window.localStorage.getItem(key);
            } catch (e){
                cmLogger.warn('LocalStorage get - ' + e)
                return "";
            }
        },
        /**
         * http://stackoverflow.com/questions/8419354/get-html5-localstorage-keys
         * returns an array of all keys
         * @returns {*}
         */
        getAllKeys: function(){
            try {
                return Object.keys($window.localStorage);
            } catch (e) {
                cmLogger.warn('LocalStorage getAllKeys - ' + e)
                return false;
            }
        },
        /**
         * set/update keys
         * @param key
         * @param data
         * @returns {boolean}
         */
        save: function (key, data) {
            try {
                $window.localStorage.setItem(key, data);
                return true;
            } catch (e){
                cmLogger.warn('LocalStorage save - ' + e)
                return false;
            }
        },
        /**
         * remove key
         * @param key
         * @returns {boolean}
         */
        remove: function (key) {
            try {
                $window.localStorage.removeItem(key);
                return true;
            } catch (e){
                cmLogger.warn('LocalStorage remove - ' + e)
                return false;
            }
        },
        /**
         * remove all keys
         * @returns {boolean}
         */
        clearAll : function () {
            try {
                $window.localStorage.clear();
                return true;
            } catch (e){
                cmLogger.warn('LocalStorage clearAll - ' + e)
                return false;
            }
        }
    }
}]).
/**
 * @ngdoc object
 * @name LocalStorageService
 * @description
 *
 * @requires LocalStorageAdapter
 * @requires cmCrypt
 * @requires $rootScope
 */
factory('LocalStorageService',['LocalStorageAdapter', 'cmCrypt', 'cmLogger', '$rootScope', function(LocalStorageAdapter, cmCrypt, cmLogger, $rootScope){
    var LocalStorageService = function(){
        var self = this,
            useable = false,
            useableCheck = false,
            cryptKey = "",
            storageKey = "CAMEO_LOCAL_STORAGE_IDENTITY",
            storageValue = {};

        function getStorageValue(){

            var value = LocalStorageAdapter.get(storageKey);
            if(value == null){
                return {}
            } else {
                return JSON.parse(cmCrypt.decrypt(cryptKey,cmCrypt.base64Decode(value)));
            }
        }

        function saveStorageValue(value){
            try {
                LocalStorageAdapter.save(storageKey, cmCrypt.base64Encode(cmCrypt.encryptWithShortKey(cryptKey,JSON.stringify(value))));
                return true;
            } catch(e){
                //
            }

            return false;
        }

        /**
         * init
         */
        this.init = function(data){
            if(this.check()){
                cryptKey = cmCrypt.hash(data.id + data.key);
                storageKey = cmCrypt.hash(data.id);
                //
                //this.instanceId = data.id;
                //this.instanceKey = data.key;
            }
        };
        /**
         * adapter function for check local storage
         * @returns {boolean}
         */
        this.check = function(){
            if(useableCheck !== true){
                useable = LocalStorageAdapter.check();
                useableCheck = true;
            }

            return useable;
        };
        /**
         * get key
         * @param key
         * @returns {*}
         */
        this.get = function (key) {
            if(this.check() !== false){
                storageValue = getStorageValue();
                if(storageValue[key] != undefined){
                    return storageValue[key];
                }
            }

            return undefined;
        };
        /**
         * get all keys from identity storage
         * @returns {*}
         */
        this.getAllKeys = function(){
            if(this.check() !== false){
                var keys = [];
                storageValue = getStorageValue();

                for(var k in storageValue){
                    keys.push(k);
                }

                return keys;
            }

            return [];
        },
        /**
         *  set and update key in identity storage
         *  @returns {boolean}
         */
        this.save = function (key, data) {
            if(this.check() !== false){
                storageValue = getStorageValue();
                if(storageValue == null){
                    storageValue = {};
                }
                storageValue[key] = data;

                saveStorageValue(storageValue);
                return true;
            }

            return false;
        };
        /**
         * remove on key from identity storage
         * @param key
         * @returns {boolean}
         */
        this.remove = function (key) {
            if(this.check() !== false){
                storageValue = getStorageValue();
                if(storageValue[key] != undefined){
                    try {
                        delete(storageValue[key]);
                        saveStorageValue(storageValue);
                        return true;
                    } catch (e){
                        //
                    }
                }
            }

            return false;
        };
        /**
         * remove all from identity storage
         * @returns {boolean}
         */
        this.clearAll = function () {
            if(this.check() !== false){
                storageValue = {};
                LocalStorageAdapter.remove(storageKey);
                return true;
            }

            return false;
        };

        this.reset = function(){
            cmLogger.debug('LocalStorageService.reset');

            self.storageValue = {};
            self.cryptKey = "";
        }
    };

    return LocalStorageService;
}]).
/**
 * @ngdoc object
 * @name cmLocalStorage
 * @description
 *
 * @requires LocalStorageService
 * @requires $rootScope
 */
factory('cmLocalStorage',['LocalStorageService','cmLogger','$rootScope', function(LocalStorageService, cmLogger, $rootScope){
    var instanceMock = [{id:'',instance:{}}];
    var instances = [];

    function resetInstances(){
        cmLogger.debug('cmLocalStorage resetInstances');
        var i = 0;
        while(i < instances.length){
            instances[i].instance.reset();
            instances[i] = null;

            i++;
        }

        instances = null;
        instances = [];
    }

    $rootScope.$on('logout', resetInstances);

    $rootScope.$on('identity:switched', resetInstances);

    return {
        /**
         * returns instances of LocalStorageService
         * @param id
         * @returns {*}
         */
        create: function(id, key){
            if(typeof id !== 'undefined' && id != '' && typeof key !== 'undefined' && key != ''){
                var storage = null;

                for(var i = 0; i < instances.length; i++){
                    if(typeof instances[i] === 'object' &&
                        instances[i].id == id){

                        storage = instances[i].instance;
                        break;
                    }
                }

                if(storage === null){
                    storage = new LocalStorageService();
                    storage.init({id:id,key:key});

                    instances.push({id:id,instance:storage});
                }

                return storage;
            }

            return null;
        },
        getQty: function(){
          return instances.length;
        }
    }

}])
//This service provides extra funcionality for core objects

/**
 * @ngdoc service
 * @name cmObject
 * @description
 *  
 */

.service('cmObject', [

    'cmLogger',
    'cmUtil',
    '$q',
    '$timeout',

    function(cmLogger, cmUtil, $q, $timeout){
        var self = this

        /**
         * @ngdoc method
         * @methodOf cmObject
         * @name addEventHandlingTo
         * @description
         * Function to add basic event handling to any object, to bubbling up or down provided
         * @param {Object} obj any object to extend with event ahndlung capabilities
         */

        this.addEventHandlingTo = function(obj){
            obj._callbacks = {}
            obj._receptors = []


            /**
             * Function to call a callback bound to an event. This function is not meant to me called from outside the object.
             * @param  {Function} cb    callback function
             * @param  {Object}   event event data to be passed to the callback function
             * @param  {Object}   data  extra data to be passed to the callback function
             * @return {boolean}  returns if the callback should be called on the next occurance of event or not         
             */
            
            function _call(cb, event, data){
                var cb_result    = cb.fn.apply(obj, [event, data]),     //call the callback on the base object
                    limit_set    = typeof cb.limit == "number",         //check if the number of calls should be limited
                    cb_complete  = limit_set                            //check if the call should count as successful (and thus recude the number number of future calls)
                                   ?    cb_result == true || cb_result == undefined //if there is no return value treat the call as successful (default)
                                   :    cb_result == true               //if there is no limit set, the number of calls is unlimited anyway
                    
                 
                if(limit_set && cb_complete) cb.limit-- //reduce number of future calls of callback for event

                var call_again   = limit_set            
                                   ?    cb.limit > 0
                                   :    !cb_complete

                return call_again
            }


            /**
             * Function to trigger callback bound to an event
             * @param  {string} event_name Name of the event to trigger
             * @param  {Object} data       Data to be passsed to the callback function
             * @return {Object}            returns the base object for chaining
             */
            
            obj.trigger = function(event_name, data, event_data){
                var event = {
                                target :    obj,  
                                source :    obj ,
                                name :      event_name
                            }

                angular.extend(event, event_data)

                obj._callbacks[event_name] = obj._callbacks[event_name] || []   //create the according callback array, if neccessary

                //if(obj._callbacks[event_name].length == 0)
                    //cmLogger.debug('Event "'+event_name+'" triggered, but no callbacks registered.')

                obj._callbacks[event_name].forEach(function(callback_obj, index){
                    // call callback function and delete if need be, see ._call()
                    if(!_call(callback_obj, event, data)){
                        delete obj._callbacks[event_name][index]
                    }
                })

                // Remove undefined entries:
                obj._callbacks[event_name] = obj._callbacks[event_name].filter(function(item){ return item != undefined})

                obj._receptors.forEach(function(receptor){
                    receptor.trigger(event_name, data, {source : event.source} )
                })

                return obj
            }

            /**
             * Function to bind a call back to event(s).
             * @param  {String}   event_names Names of the events to bind to. Multiple event names should be separated by ' '.
             * @param  {Function} callback    Function to call, when the event is triggered. Should return wether the call was successfull or not.
             * @param  {number}   [limit]     Number of times the callback should be (succsessfully) called. If not provided, there is no limit to the number of calls.
             * @return {Object}               returns the object for chaining.
             */
            
            obj.on = function(event_names, callback, limit){
                var event_names = event_names instanceof Array ? event_names : event_names.split(' ') 

                event_names.forEach(function(event_name){
                    obj._callbacks[event_name] = obj._callbacks[event_name] || [] //create according callback array, if neccessary
                    obj._callbacks[event_name].push({       // add callback object with callback function an limit for number of calls
                        'fn' : callback,
                        'limit': limit || false
                    })
                })

                return obj
            }

            /**
             * Function to remove binding of a callback function to an event.
             * @param  {String}   event_names Names of the events to bind to. Multiple event names should be separated by ' '.
             * @param  {Function} callback    Funcation that has been bound to an event.
             * @return {Object}               returns the object for chaining.
             */
            obj.off = function(event_names, callback){
                var event_names = event_names instanceof Array ? event_names : event_names.split(' ') 
                
                event_names.forEach(function(event_name){
                    if(!callback) obj._callbacks[event_name] = []

                    obj._callbacks[event_name] = obj._callbacks[event_name] || []

                    if(event_name in obj._callbacks) {
                        obj._callbacks[event_name].forEach(function (callback_obj, index) {
                            if (callback_obj.fn == callback) delete obj._callbacks[event_name][index]
                        })
                    }
                })

                return obj
            }

            /**
             * Function to bind a call back to event(s). Unbind after triggered once.
             * @param  {String}   event_names Names of the events to bind to. Multiple event names should be separated by ' '.
             * @param  {Function} callback    Function to call, when the event is triggered. Should return wether the call was successfull or not.
             * @param  {number}   [limit]     Number of times the callback should be (succsessfully) called. If not provided, there is no limit to the number of calls.
             * @return {Object}               returns the object for chaining.
             */
            obj.one = function(event_names, callback){
                obj.on(event_names, callback, 1)
                return obj
            }

            /**
             * Function to convert an event to a promise
             * @param  {String} event_names     Names of the events to listen to. Multiple event names should be separated by ' '.
             * @return {promise}                Promise to be resolved when the event triggers for the first time
             */
            obj.when = function(event_names_to_resolve, event_names_to_reject, timeout){
                if(event_names_to_reject && isNaN(event_names_to_reject)){
                    obj.one(event_names_to_reject, function(event, data){
                        deferred.reject( {event: event, data: data} )
                        return true
                    })
                } else {
                    timeout = timeout || event_names_to_reject
                }

                var deferred = $q.defer()

                obj.one(event_names_to_resolve, function(event, data){
                    deferred.resolve( {event: event, data: data} )
                    return true
                })

                if(typeof timeout == 'number'){
                    $timeout(function(){
                        deferred.reject('timeout')
                    }, timeout)
                }

                return deferred.promise
            }

            /**
             * @methodOf 
             * @name  brodcastEventsTo
             *
             * @description
             * Function to brodacast event from on event to another.
             * 
             * @param  {object} receptor    Any object with event handling.
             * @returns {*}     this        Returns itself for chaining.         
             */
            obj.broadcastEventsTo = function(receptor){
                if(receptor && typeof receptor.trigger == 'function'){
                    this._receptors.push(receptor)
                } else {
                    //cmLogger.debug('cmObject: EventHandling: unable to add receptor.', obj)
                }

                return obj
            }

            /**
             * @name echoEventsFrom
             * @description 
             * Retriggers every event of source object on itself.
             *
             * @param   {*}          source Source object.
             * @returns {*}  this    Returns itself for chaining.
             */
            obj.echoEventsFrom = function(source){
                if(source && typeof source.broadcastEventsTo == 'function'){
                    source.broadcastEventsTo(obj)
                } else {
                    //cmLogger.debug('cmObject: EventHandling: unable to echo Events.', obj)
                }
            }


            return this 
        }

        this.addChainHandlingTo = function(obj){
            obj._chains = {}

            function Chain(obj){
                var deferred     = $q.defer(),
                    self         = this,
                    last_promise = deferred.promise


                angular.forEach(obj, function(value, key){                    
                    if(typeof obj[key] != 'function')  return null

                    self[key] = function(){
                        var args = Array.prototype.slice.call(arguments, 0)

                        last_promise = last_promise.then(function(result){                                
                            return obj[key].apply(obj, args.length > 0 ? args : [result])                                 
                        })

                        return self
                    }
                })

                self.then = function(){                    
                    last_promise = last_promise.then.apply(last_promise, Array.prototype.slice.call(arguments, 0))
                    return self
                }

                deferred.resolve()

                return self
            }


            obj.$chain = function(name){
                name  = name || 'default'

                obj._chains[name] = obj._chains[name] || new Chain(obj)
                
                return obj._chains[name]
            }

            return this 
        }
        
    }
])
/**
 * @ngdoc object
 * @name cmPassphraseVault
 * @description
 * Handle Passphrase Conversation
 *
 * @requires cmUserModel
 * @requires cmCrypt
 * @requires cmIdentityFactory
 * @requires cmKeyFactory
 * @requires cmLogger
 * @requires $q
 */

.service('cmPassphraseVault',[
    'cmUserModel', 'cmCrypt', 'cmIdentityFactory', 'cmKeyFactory','cmLogger',
    '$q',
    function(cmUserModel, cmCrypt, cmIdentityFactory, cmKeyFactory, cmLogger,
             $q){
        var self = this

        /** utility functions **/

        /**
         * @ngdoc method
         * @methodOf cmPassphraseVault
         *
         * @name couldBeAPassword
         * @description
         * private function to check minimal requirements for a password.
         *
         * @param {String} pw Anything to be checked wether it could be a password.
         * @returns {Boolean} result Wheter the suggested password seems okay or not
         */
        function couldBeAPassword(pw){
            return ((typeof pw == "string") && pw.length >= 1); //Todo, require better passwords.
        }



        /**
         * @ngdoc method
         * @methodOf cmPassphraseVault
         *
         * @name couldBeAPassphrase
         * @description  private function to check minimal requirements for a passphrase.
         *
         * @param {String} pp Anything to be checked wether it could be a passphrase.
         * @return {Boolean} Wheater the suggested passphrase seems okay or not
         */
        function couldBeAPassphrase(pp){
            return ((typeof pp == "string") && (pp.length >= 60))
        }


        function getKeyTransmission(sePassphrase, aePassphraseList){

            if(sePassphrase && aePassphraseList.length > 0)
                return 'mixed';

            if(sePassphrase)
                return 'symmetric';

            if(aePassphraseList.length > 0 )
                return 'asymmetric';

            return 'none';
        };


        /**
         * Constructor PassphraseVault
         */
        function PassphraseVault(data){


            var sePassphrase            = data.sePassphrase,
                aePassphraseList        = data.aePassphraseList || [],
                recipientKeyList        = data.recipientKeyList || [],
                signatures              = data.signatures       || [],
                self                    = this,

                cache_passphrase        = true,
                cached_passphrase       = undefined


            /**
             * @ngdoc method
             * @methodOf cmPassphraseVault
             *
             * @name getKeyTransmission
             * @description
             * return encryption type
             *
             * @returns {String} encryption type - 'none' || 'symmetric' || 'asymmetric' || 'mixed'
             */
            this.getKeyTransmission = function(){
                return getKeyTransmission(sePassphrase, aePassphraseList)
            };

            /**
             * @ngdoc mehtod
             * @methodOf cmPassphraseVault
             *
             * @name get
             *
             * @param {String} [password] A password to decrypt with
             * @return {promise} Resolves with passphrase if successfull
             */

            this.get = function(password){



                //@Todo disable caching if not neccessary
                if(cache_passphrase && couldBeAPassphrase(cached_passphrase))
                    return  $q.when(cached_passphrase)


                return  $q.reject('unknown.')
                    //try symmetric decryption first:,
                    .catch(function(){
                        //check if a valid password has been passed to the function
                        //and a symmetrically encrypted passphrase is present:
                        return  couldBeAPassword(password) && sePassphrase
                            ?   cmCrypt.decrypt(password, cmCrypt.base64Decode(sePassphrase))
                            :   $q.reject('password invalid.')
                    })
                    //try asymmetrical decryption if neccessary:
                    .catch(function(reason){
                        return  aePassphraseList // could be an empty array
                            .reduce(function(previous_try, item) {
                                return  previous_try
                                    //if decryption has been successfull already there will be nothing to catch:
                                    .catch(function(){
                                        return cmUserModel.decryptPassphrase(item.encryptedPassphrase, item.keyId)
                                    })
                            }, $q.reject(reason))
                    })
                    //finally check if decryption resolved with a proper passphrase,
                    //if so resolve with passphrase,
                    //if not reject
                    .then(
                    function(new_passphrase){
                        if(couldBeAPassphrase(new_passphrase))
                            cached_passphrase = new_passphrase

                        return  couldBeAPassphrase(new_passphrase)
                            ?   $q.when(new_passphrase)
                            :   $q.reject('decrypted passphrase invalid.')
                    },
                    function(reason){
                        return $q.reject(reason)
                    }
                )
            }

            /**
             * @ngdoc method
             * @methodOf cmPassphraseVault
             *
             * @name userHasAccess
             * @description
             * checks if local user has keys in passphraselist
             *
             * @returns {Boolean} boolean Returns a Boolean
             */
            this.userHasAccess = function(){
                var localKeys = cmUserModel.loadLocalKeys()

                return  localKeys.some(function(key){
                    return aePassphraseList.some(function(item){
                        return item.keyId == key.id
                    })
                })
            }

            /**
             * @ngdoc method
             * @methodOf cmPassphraseVault
             *
             * @name verifyAuthenticity
             * @description
             * Verifies a authentication of vault data
             *
             * @returns {Promise} Returns a promise resolved on success and rejected on failure
             */
            this.verifyAuthenticity = function(){

                if(!signatures || signatures.length == 0)
                    return $q.reject('missing signature')

                // the original signee ought to be among the original recipients, so get them first:
                recipientKeyList
                    .map(function(item){
                        return cmIdentityFactory.find(item.identityId)
                    })
                    .forEach(function(recipient){
                        if(!recipient) return null

                        //add matching key/identity to signature object for later use
                        signatures.forEach(function(signature){
                            var key = recipient.keys.find(signature.keyId)

                            if(key){
                                signature.identity  = recipient
                                signature.key       = key
                            }
                        })
                    })

                return  this.get()
                    .then(function(passphrase){
                        return  {
                            passphrase              : passphrase,
                            keyTransmission         : self.getKeyTransmission(),
                            recipientKeyList        : recipientKeyList
                        }
                    })
                    .then(function(data){
                        var sortHelper = {'recipientKeyList':'identityId'};

                        return  cmCrypt.hashObject(data, sortHelper) || $q.reject('cmPassphraseVault.verifyAuthenticity: cmCrypt.hashObject() failed.')
                    })
                    .then(function(token){
                        var valid_signatures= [],
                            bad_signatures  = []

                        return  $q.all(signatures.map(function(signature){
                            var key = signature.key

                            return  key
                                ?   key.verify(token, signature.content)
                                .then(
                                function(result){
                                    valid_signatures.push(signature)
                                },
                                function(reason){
                                    //console.log('phv fail reason)', reason)
                                    bad_signatures.push(signature)
                                }
                            )
                                .finally(function(){
                                    return $q.when()
                                })
                                :   $q.when()
                        }))
                            .then(function(){
                                return  valid_signatures.length > 0
                                    ?   $q.when(valid_signatures)
                                    :   $q.reject(
                                    bad_signatures.length > 0
                                        ?   {type:1, msg:'verification failed.', bad_signatures: bad_signatures}
                                        :   {type:0, msg:'no matching keys/identities found for signatures.'}
                                )
                            })
                    })
                    .then(function(valid_signatures){
                        return  valid_signatures.reduce(function(last_try, signature){
                            return  last_try
                                .catch(function(){
                                    return  cmUserModel.verifyIdentityKeys(signature.identity, false, true)
                                        .then(function(ttrusted_keys){
                                            return  ttrusted_keys.indexOf(signature.key) != -1
                                                ?   $q.when()
                                                :   $q.reject('no authenticated key found for signature.')

                                        })
                                })
                        },$q.reject('cmPassphraseVault: .verifyAuthenticity(): signatures invalid'))

                    })
                    .then(function(){
                        return $q.when(recipientKeyList)
                    })
            }

            /**
             * @ngdoc method
             * @methodOf cmPassphraseVault
             *
             * @name exportData
             *
             * @return {Object} returns encryption data ready to be submitted to the API.
             */
            this.exportData = function(){
                return  {
                    sePassphrase            : sePassphrase,
                    aePassphraseList        : aePassphraseList,
                    keyTransmission         : getKeyTransmission(sePassphrase, aePassphraseList),
                    recipientKeyList        : recipientKeyList,
                    signatures              : signatures
                }
            }
        };

        /**
         * @ngdoc method
         * @methodOf cmPassphraseVault
         *
         * @name create
         *
         * @discription
         * Creates a new PassphraseVault
         *
         * @returns {Object} PassphraseVault
         */
        this.create = function(data){
            data = data || {}
            data.sePassphrase       = data.sePassphrase       || null,
                data.aePassphraseList   = data.aePassphraseList   || [],
                data.recipientKeyList   = data.recipientKeyList   || [],
                data.signatures         = data.signatures         || []

            return new PassphraseVault(data)
        };

        /**
         * @ngdoc method
         * @methodOf cmPassphraseVault
         *
         * @name encryptPassphrase
         *
         * @description
         * Creates a new PassphraseVault
         *
         * @param {Object} config
         * config =    {
     *                  passphrase:         config.passphrase       || cmCrypt.generatePassphrase(),
     *                  password:           config.password         || null,
     *                  identities:         config.identities       || [],
     *              }
         *
         * @returns {Object} PassphraseVault
         */
        this.encryptPassphrase = function(config){
            config =    {
                passphrase:         config.passphrase       || cmCrypt.generatePassphrase(),
                password:           config.password         || null,
                identities:         config.identities       || [],
                restrict_to_keys:   config.restrict_to_keys || undefined
            };

            return $q.all({
                // symmetrical encryption
                sym:    couldBeAPassword(config.password) && couldBeAPassphrase(config.passphrase)
                    ?   cmCrypt.base64Encode(cmCrypt.encryptWithShortKey(config.password, config.passphrase))
                    :   $q.when(undefined)
                ,
                // asymmetrically encrypt
                asym:   couldBeAPassphrase(config.passphrase)
                    ?   $q.all(
                    config.identities.map(function(identity){
                        var deferred = $q.defer();

                        // TODO: for own untrustedkey a exception?

                        identity.getTrustedKeys().then(
                            function(keys){
                                var m = [];
                                keys.forEach(function(key){
                                    m.push(key.id);
                                });
                                return m;
                            }
                        ).then(function(trustedKeys) {
                                var whitelist = undefined;
                                // when identity has trusted keys do a whitelist for this keys
                                if(trustedKeys.length > 0){
                                    whitelist = trustedKeys;
                                }

                                deferred.resolve(identity.keys.encryptPassphrase(config.passphrase, whitelist));
                            });

                        return deferred.promise;
                    })
                )
                    .then(function(results){
                        return Array.prototype.concat.apply([], results)
                    })
                    :   $q.when([])
            })
                // get list of all recipients an their keys used to encrypt the passphrase
                .then(function(result){

                    result.recipientKeyList = config.identities.map(function(identity){
                        return  {
                            identityId: identity.id,
                            keys:       result.asym.filter(function(item){
                                return identity.keys.find(item.keyId) != null
                            })
                                .map(function(item){
                                    return {id : item.keyId}
                                })
                        }
                    });

                    var double_check =  result.asym.length == result.recipientKeyList.reduce(function(number_of_keys, item){
                            return number_of_keys + item.keys.length
                        },0);

                    return  double_check
                        ?   result
                        :   $q.reject('cmPassphraseVault.encryptPassphrase(): double check failed.')
                })
                // get signatures
                .then(function(result){
                    var sortHelper = {'recipientKeyList':'identityId'};

                    return  cmUserModel.signData(cmCrypt.hashObject({
                        passphrase              : config.passphrase,
                        keyTransmission         : getKeyTransmission(result.sym, result.asym),
                        recipientKeyList        : result.recipientKeyList
                    },sortHelper))
                        .then(function(signatures){
                            result.signatures = signatures;
                            return $q.when(result)
                        });
                })
                // finsih and return results
                .then(
                function(result){
                    return  self.create({
                        sePassphrase:       result.sym,
                        aePassphraseList:   result.asym,
                        recipientKeyList:   result.recipientKeyList,
                        signatures:         result.signatures
                    });

                },
                function(reason){
                    cmLogger.debug('cmPassphraseVault: encryption failed.');
                    return $q.reject(reason)
                }
            )
        };

        /**
         * @TODO mit AP klären, BS!!!
         * @returns {*|number}
         */
        this.getWeakestKeySize = function(){
            return  conversation.recipients.reduce(function(size, recipient){
//                            return size != undefined ? Math.min(recipient.getWeakestKeySize(), size) : recipient.getWeakestKeySize()
                    return size != undefined ? Math.min(recipient.getWeakestKeySize(), size.getWeakestKeySize()) : recipient.getWeakestKeySize()
                }) || 0
        }
    }
])

    .service('cmReKeying', [
        'cmUserModel', 'cmApi', 'cmAuth', 'cmObject', 'cmStateManagement', 'cmUtil', 'cmLogger', 'cmKey', 'cmModal',
        '$rootScope', '$q',
        function(cmUserModel, cmApi, cmAuth, cmObject, cmStateManagement, cmUtil, cmLogger, cmKey, cmModal,
                 $rootScope, $q)
        {
            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state = new cmStateManagement(['rekeying']);

            this.process = function(localKeyId){
                if(!this.state.is('rekeying')){
                    this.state.set('rekeying');

                    if(typeof localKeyId == 'string' && cmUtil.validateString(localKeyId)){
                        var localKey    = cmUserModel.loadLocalKeys().find(localKeyId);

                        if(localKey instanceof cmKey){

                            cmUserModel.data.identity.getTrustedKeys().then(
                                function(trusted_keys){

                                    if(trusted_keys.length > 0){
                                        self.showModal()
                                    }

                                    var rekeying_processes = [];

                                trusted_keys.forEach(function(key){
                                    if(key.id != localKey.id){

                                        rekeying_processes.push( cmAuth.getBulkPassphrases(localKey.id, key.id).then(
                                            function(list){
                                                if(list.length == 0){
                                                    return $q.when();
                                                }

                                                //re and encrypt passphrasees one by one, dont try to de and encrypt them all simultaniuosly:
                                                return list.reduce(function(previous_run, item){
                                                    return  previous_run
                                                            .then(function(list_so_far){
                                                                return  cmUserModel.decryptPassphrase(item.aePassphrase, localKey.id)
                                                                        .then(function(passphrase){
                                                                            return key.encrypt(passphrase)
                                                                        })
                                                                        .then(function(encrypted_passphrase){
                                                                            return  list_so_far.concat([{
                                                                                conversationId: item.conversationId,
                                                                                aePassphrase:   encrypted_passphrase
                                                                            }])
                                                                        })

                                                            })
                                                }, $q.when([]))
                                                .then(
                                                    function(newList){
                                                        return  cmAuth.saveBulkPassphrases(key.id, newList)
                                                    }
                                                )
                                                .then(
                                                    function(){
                                                        return  cmApi.broadcast({
                                                            name: 'rekeying:finished',
                                                            data:{
                                                                keyId: key.id
                                                            }
                                                        });
                                                    },
                                                    function(){
                                                        cmLogger.debug('cmUserModel.bulkReKeying - Request Error - saveBulkPassphrases');
                                                        return $q.when();
                                                    }
                                                )
                                                .catch(
                                                    function(){
                                                        return $q.when();
                                                    }
                                                )
                                            },
                                            function(){
                                                cmLogger.debug('cmUserModel.bulkReKeying - Request Error - getBulkPassphrases');
                                                return $q.when();
                                            }
                                        ))
                                    }
                                });

                                $q.all(rekeying_processes).finally(
                                    function(){
                                        self.trigger('bulkrekeying:finished');
                                        self.state.unset('rekeying');
                                    }
                                );
                            }
                        );
                    }
                } else {
                    cmLogger.debug('cmUserModel.bulkReKeying - Parameter Error - getBulkPassphrases');
                    this.trigger('bulkrekeying:aborted');
                    this.state.unset('rekeying');
                    }
                }
            };

            this.showModal = function(){
                var modal_scope = $rootScope.$new(),
                    modal_id = 'bulk-re-keying';

                modal_scope.working = true;

                cmModal.create({
                    id: modal_id,
                    type: 'plain',
                    class: 'no-padding',
                    'cm-title': 'DRTV.BULK_REKEYING.HEADER',
                    'cm-close-btn': false,
                    'cm-close-on-backdrop': false
                },'<cm-re-keying-modal></cm-rekeying-modal>', null, modal_scope);

                cmModal.open(modal_id);

                this.one('bulkrekeying:finished', function(){
                    var modal = cmModal.instances[modal_id];

                    if(modal && modal.isActive()){
                        cmModal.close(modal_id)
                    }
                });
            }
        }
    ])

.service('cmRootService', [
    'cmLogger', 'cmJob', 'cmModal', 'cmConfig', 'cmTransferScopeData',
    '$rootScope', '$window', '$location', '$route',
    function(cmLogger, cmJob, cmModal, cmConfig, cmTransferScopeData,
             $rootScope, $window, $location, $route){

        $rootScope.getCurrentUrl = function(){
            return $location.$$path;
        };

        $rootScope.goBack = function(){
            $window.history.back();
        };

        /**
         * @param path {string}
         * @param replace {boolean}
         */
        $rootScope.goTo = function(path, replace){
            //cmLogger.debug('cmRootService.goTo ' + path);
            path = path[0] == '/' ? path : '/'+path;
            if(cmJob.isActive() !== false){
                cmJob.setPendingUrl(path, replace);
            } else {
                $location.path(path);

                //Todo: find different solution:
                if(replace){
                    $location.replace();
                }
            }
        };

        /**
         * alias
         * @type {Function|$rootScope.goTo}
         */
        $rootScope.goto = $rootScope.goTo;

        $rootScope.gotoRegistration = function(){
            this.goTo('/registration');
        };

        $rootScope.createNewContact = function(){
            cmLogger.debug('cmRootService.createNewContact');

            $rootScope.goTo('/contact/create');
        };

        $rootScope.createNewConversation = function(){
            //cmLogger.debug('cmRootService.createNewConversation');

            $rootScope.pendingConversation = null;
            $rootScope.pendingRecipients = [];

            cmTransferScopeData.keepClear({id:'conversation-new'});

            $rootScope.goTo('/conversation/new');

            $route.reload();
        };

        $rootScope.startConversationWithContact = function($event, contact){
            $event.stopPropagation();
            $event.preventDefault();

            if(contact.contactType != 'pending'){
                $rootScope.pendingConversation = null;
                $rootScope.pendingRecipients = [];

                if (contact.identity) {
                    $rootScope.pendingRecipients = [contact.identity]
                } else {
                    cmLogger.error('Unable to find identity on contact. ' + contact)
                }
                $rootScope.goTo('/conversation/new');
            }
        };

        $rootScope.createNewIdentity = function(){
            $rootScope.goTo('/settings/identity/create');
        };

        $rootScope.gotoContactList = function(){
            $rootScope.goTo('/contact/list')
        };

        $rootScope.gotoContact = function (contact) {
            if(contact.contactType != 'pending') {
                $rootScope.goTo('/contact/edit/' + contact.id);
            }
        };

        $rootScope.gotoPurl = function(purlId, subpath){
            $rootScope.goTo('/purl/'+purlId+'/'+subpath)
        };

        $rootScope.gotoConversation = function(conversationId, subpath){
            $rootScope.goTo('/conversation/'+(conversationId || 'new')+ (subpath ? '/'+subpath : ''))
        };

        $rootScope.goToApp = function(params){
            window.location = cmConfig.static.appProtocol + '://?'+params;
        };

        $rootScope.openExternalLink = function(url){
            $window.open(url, '_system', 'location=yes');
        };

        /**
         * modal for login
         */
        $rootScope.showLogin = function () {
            cmModal.create({
                id: 'login',
                'class': 'with-title no-padding theme-b',
                'cm-close-btn': false,
                'cm-close-on-backdrop': false
            },'<div cm-login-modal></div>');
            cmModal.open('login');

            $rootScope.$on('cmLogin:success', function(){
                // TODO: schould that happen?
                location.reload();
            });
        };

        /**
         * modal for fast registration
         */
        $rootScope.openFastRegister = function(){
            cmModal.create({
                    id: 'fast-registration',
                    'class': 'webreader',
                    type: 'alert',
                    //nose: 'bottom-left',
                    'cm-close-btn': false,
                    'cm-footer-label': 'MODAL.WEBREADER.LATER',
                    'cm-footer-icon': 'cm-close'
                },
                '<div class="attention">' +
                '<i class="fa cm-attention"></i> {{\'MODAL.WEBREADER.NOTICE\'|cmTranslate}}' +
                '</div>'+
                '<a href="#/registration" class="classic-link" data-qa="btn-register-modal">' +
                '<i class="fa cm-key"></i> {{\'MODAL.WEBREADER.REGISTRATION\'|cmTranslate}}' +
                '</a>'
            );
            cmModal.open('fast-registration')
        };

        /**
         * checks if a conversation route is open
         * return {boolean}
         */
        $rootScope.checkConversationRoute = function(conversationId){
            if(typeof conversationId == 'string' && $location.$$path.indexOf('conversation/' + conversationId) != -1){
                return true;
            } else if(typeof conversationId == 'undefined' && $location.$$path.indexOf('conversation') != -1){
                return true;
            }

            return false;
        };

        /**
         * checks if a purl route is open
         * return {boolean}
         */
        $rootScope.checkPurlRoute = function(purlId){
            if(typeof purlId == 'string' && $location.$$path.indexOf('purl/' + purlId) != -1){
                return true;
            } else if(typeof purlId == 'undefined' && $location.$$path.indexOf('purl') != -1){
                return true;
            }

            return false;
        };

        $rootScope.$on('logout',function(){
            $rootScope.pendingConversation = null;
            $rootScope.pendingRecipients = [];
        });

        $rootScope.$on('identity:switched',function(){
            $rootScope.pendingConversation = null;
            $rootScope.pendingRecipients = [];
        });
    }
])
/**
 * @ngdoc service
 * @name cmSettings
 * @description
 * @todo combine with service-key-storage
 */
.service('cmSettings', [
    'cmUserModel', 'cmUtil', 'cmLogger', 'cmObject',
    '$rootScope',
    function(cmUserModel, cmUtil, cmLogger, cmObject,
             $rootScope) {

        var self = this,
            localStorageKey = 'appSettings',
            defaultProperties = {
                convertSmileysToEmojis: true,
                sendOnReturn: false,
                skipKeyInfo: false,
                dateFormat: 'dd.MM.yyyy',
                timeFormat: 'HH:mm',
                pushNotifications: true,
                browserNotifications: true,
                enableUnreadMessages: true
            };

        cmObject.addEventHandlingTo(this);

        this.properties = {};

        function init(){
//            cmLogger.debug('cmSettings.init');
            self.properties = angular.extend({}, defaultProperties, (cmUserModel.storageGet(localStorageKey) || {}));
            self.trigger('update:finished');
        }

        /**
         * @name get
         * @description
         * get the value of an key out of the localstorage
         */
        this.get = function(key){
            // get key
            if(key != undefined){
                var settings = {};

                if(cmUtil.checkKeyExists(this.properties, key)){
                    settings = this.properties[key];
                }

                return settings;
            }
        };

        /**
         * @name is
         * @description
         * check if exists and is true
         */
        this.is = function(key){
            var boolReturn = false;
            if(key != undefined && // key exists
               cmUtil.checkKeyExists(this.properties, key) && // is in properties
               this.properties[key]){// and is true
                boolReturn = true;
            }
            return boolReturn;
        };

        /**
         * @name set
         * @description
         * updates the key in localstorage
         */
        this.set = function(key, value){
            this.properties[key] = value;

            if(cmUserModel.storageSave(localStorageKey, this.properties)){
                cmUserModel.saveAppSettings();
                return true;
            }

            return false;
        };

        $rootScope.$on('logout', function(){
//            cmLogger.debug('cmSettings.on.logout');
            self.properties = {};
        });

        $rootScope.$on('identity:switched', function(){
            self.properties = {};
        });

        cmUserModel.on('update:finished', function(){
            init();
        });
    }
])
/**
 * @ngdoc object
 * @name cmSystemCheck
 * @description
 */

.service('cmSystemCheck', [
    'cmUserModel', 'cmObject', 'cmApi', 'cmVersion', 'cmLanguage',
    'LocalStorageAdapter', 'cmLogger', 'cmDevice', 'cmBoot',
    '$rootScope', '$q',
    function(cmUserModel, cmObject, cmApi, cmVersion, cmLanguage,
             LocalStorageAdapter, cmLogger, cmDevice, cmBoot,
             $rootScope, $q){
        var self = this;

        cmObject.addEventHandlingTo(this);

        this.getBrowserInfo = function(){
            //cmLogger.debug('cmSystemCheck.getBrowserInfo');
            var deferred = $q.defer();

            cmApi.post({
                path: '/services/getBrowserInfo',
                data: {
                    version: cmVersion.version,
                    isApp: cmDevice.isApp(true)
                }
            }).then(
                function(data){
                    // without token
                    if(!cmUserModel.isAuth()){
                        var language = data.languageCode.substr(0,2),
                            lc       = language == 'de' ? 'de' : 'en';
                        cmLanguage.switchLanguage(lc);
                    }
                    // flag handling
                    if('isDesktop' in data){
                        cmDevice.setFlag('isDesktop',data.isDesktop);
                    }
                    // version check
                    if('versionIsSupported' in data && data.versionIsSupported == false){
                        $rootScope.clientVersionCheck = false;
                    } else {
                        $rootScope.clientVersionCheck = true;
                    }

                    cmBoot.ready.browserInfo();

                    deferred.resolve();
                },
                function(){
                    deferred.reject();
                }
            );

            return deferred.promise;
        };

        /**
         * @param forceRedirect
         * @returns {boolean}
         */
        this.checkClientVersion = function(forceRedirect){
            //cmLogger.debug('cmSystemCheck.checkClientVersion');
            var deferred = $q.defer();
            if('clientVersionCheck' in $rootScope){
                if($rootScope.clientVersionCheck == false){
                    this.trigger('check:failed', {forceRedirect:forceRedirect});
                    deferred.reject();
                } else {
                    deferred.resolve();
                }
            } else {
                this.getBrowserInfo().then(
                    function(){
                        self.checkClientVersion(forceRedirect);
                    },
                    function(){
                        deferred.resolve();
                    }
                )
            }

            return deferred.promise;
        };

        this.checkLocalStorage = function(forceRedirect){
            var test = {key: 'cameoNet', value: 'cameoNet'};

            if (!LocalStorageAdapter.check()) {
                this.trigger('check:failed', {forceRedirect:forceRedirect});
                return false;
            } else {
                if (LocalStorageAdapter.save(test.key, test.value)) {
                    LocalStorageAdapter.remove(test.key);

                    return true;
                }

                this.trigger('check:failed', {forceRedirect:forceRedirect});
                return false;
            }
        };

        this.run = function(forceRedirect){
            this.checkClientVersion(forceRedirect);
            this.checkLocalStorage(forceRedirect);
        };

        this.on('check:failed', function(event, data){
            if(typeof data == 'object'){
                if('forceRedirect' in data && data.forceRedirect == true){
                    cmUserModel.doLogout(false);
                    $rootScope.goto('/systemcheck');
                }
            }
        });
    }
])
/**
 * @ngdoc service
 * @name cmUserModel
 * @description
 * MOEP Description
 *
 * @requires cmAuth
 * @requires cmLocalStorage
 * @requires cmIdentityFactory
 * @requires cmObject
 * @requires cmNotify
 * @requires cmLogger
 * @requires $rootScope
 * @requires $q
 * @requires $location
 *
 * @type {{isActive: boolean, id: string, userKey: string, displayName: string, cameoId: string, email: {}, phoneNumber: {}, preferredMessageType: string, created: string, lastUpdated: string, userType: string, storage: {}, identity: {}}}
 */


.service('cmUserModel',[
    'cmBoot', 'cmAuth', 'cmLocalStorage', 'cmIdentityFactory', 'cmIdentityModel', 'cmFactory',
    'cmCrypt', 'cmKeyFactory', 'cmKey', 'cmStateManagement', 'cmObject', 'cmUtil',
    'cmNotify', 'cmLogger', 'cmCallbackQueue', 'cmPushNotificationAdapter', 'cmApi',
    '$rootScope', '$q', '$location', '$timeout', 'cmMigrate', 'cmPhonegap',
    function(cmBoot, cmAuth, cmLocalStorage, cmIdentityFactory, cmIdentityModel, cmFactory,
             cmCrypt, cmKeyFactory, cmKey, cmStateManagement, cmObject, cmUtil,
             cmNotify, cmLogger, cmCallbackQueue, cmPushNotificationAdapter, cmApi,
             $rootScope, $q, $location, $timeout, cmMigrate, cmPhonegap){

        var self = this,
            isAuth = false,
            initialize = ''; // empty, run, done ! important for isAuth check

        cmObject.addEventHandlingTo(this);

        this.reset = function(){
            this.data = {
                isActive: false,
                id: '',
                userKey: '',
                displayName: '',
                cameoId: 'loading...',
                email: {},
                phoneNumber: {},
                preferredMessageType: 'default',
                created: '',
                lastUpdated: '',
                userType: '',
                storage: {},
                identity: {},
                identities: [],
                account: {}
            };
        }

        this.reset();

        this.state = new cmStateManagement(['signing']);

        //this.comesFromRegistration = false;

        /**
         * @ngdoc method
         * @methodOf cmUserModel
         *
         * @name init
         * @description
         * initialize the model with loading the identity
         *
         * @param {Object} identity_data JSON of an Identity
         * @returns {Object} this cmUserModel
         */
        function init(){
            self.loadIdentity();

            self.trigger('init');// deprecated
            self.trigger('init:finish');

            self.one('update:finished', function(){
                if(self.data.identity.keys){
                    self.signOwnKeys();
                    return true;
                }else{
                    return false;
                }
            });
        }

        this.importData = function(activeIdentity, data_identities){
            //console.log('activeIdentity', activeIdentity)

            this.data.identity = activeIdentity;
            this.data.identity.isAppOwner = true;
            this.data.id = activeIdentity.id || this.data.id;
            this.data.userKey = activeIdentity.userKey || this.data.userKey;
            this.data.userType = activeIdentity.userType || this.data.userType;

            // todo may an own factory but not a new identityFactory!
            if(this.data.identities.length > 0)
                this.data.identities = [];

            this.data.identities.push(activeIdentity);
            data_identities.forEach(function(identity){
                if(identity.id != self.data.identity.id){
                    var tmpIdentity = cmIdentityFactory.clear(identity).create(identity);
                    tmpIdentity.on('update:finished', function(){
                        /* we have to trigger an other event identity:updated is an backend event */
                       /*cmUserModel.trigger('identity:updated');*/
                    });
                    self.data.identities.push(tmpIdentity);
                }

            });

            isAuth = true;
            this.initStorage();
            this.syncLocalKeys();

            this.trigger('update:finished');

            return this;
        };

        /**
         * @name loadIdentity
         * @description create Identiy for cmUserModel
         * @param {Object|undefined} identity_data
         * @returns {*}
         */
        this.loadIdentity = function(accountData){
            //cmLogger.debug('cmUserModel:loadIdentity');

            var deferred = $q.defer();
            // for login
            function importAccount(accountData){
                if(typeof accountData !== 'undefined' && 'identities' in accountData){
                    var arr_activeIdentity = accountData.identities.filter(function(identity){
                        return identity.active == true;
                    });

                    var identity = cmIdentityFactory.clear(arr_activeIdentity[0]).create(arr_activeIdentity[0], true);

                    //identity.on('update:finished', function(event, data){
                    //    self.trigger('update:finished');
                    //});

                    self.importData(identity, accountData.identities);
                    self.importAccount(accountData);
                    self.setAppSettings(accountData);

                    // check device for pushing
                    cmPushNotificationAdapter.checkRegisteredDevice();

                    return true;
                }

                return false;
            }
            // for purl
            function importIdentity(identity_data){
                if(typeof identity_data == 'object'){

                    var identity = cmIdentityFactory.clear(identity_data).create(identity_data, true);

                    identity.on('update:finished', function(event, data){
                        self.trigger('update:finished');
                    });

                    self.importData(identity, []);

                    return true;
                }

                return false;
            }

            if(typeof accountData !== 'undefined' && 'identities' in accountData){
                if(importAccount(accountData)){
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            } else {
                if(this.getToken() !== false){
                    /**
                     * @todo hack for external user in purl
                     */
                    if($location.$$path.search('/purl') != -1){
                        cmAuth.getIdentity().then(
                            function (data) {
                                if (importIdentity(data)) {
                                    deferred.resolve();
                                } else {
                                    deferred.reject();
                                }
                            },
                            function (r) {
                                var response = r || {};

                                if (typeof response == 'object' && ('status' in response) && response.status == 401) {
                                    cmLogger.debug('cmUserModel:init:reject:401');
                                    self.doLogout(true, 'usermodel load identity reject');
                                }

                                deferred.reject();
                            }
                        )
                    } else {
                        cmAuth.getAccount().then(
                            function (data) {
                                if (importAccount(data)) {
                                    deferred.resolve();
                                } else {
                                    deferred.reject();
                                }
                            },
                            function (r) {
                                var response = r || {};
                                if('status' in response){
                                    switch(response.status){
                                        case 0:
                                            cmLogger.debug('cmUserModel:init:failed:0');
                                            $rootScope.$broadcast('cmConnectionHandler:failed', function(){
                                                self.loadIdentity(accountData);
                                            });
                                            return false;
                                        break;
                                        case 401:
                                            cmLogger.debug('cmUserModel:init:reject:401');
                                            self.doLogout(true, 'usermodel load identity reject');
                                        break;
                                    }
                                }

                                deferred.reject();
                            }
                        );
                    }
                } else {
                    // migrate crosswalk
                    cmPhonegap.isReady('cmUserModel', function(){
                        cmMigrate.migrateLocalStorage().then(function(values){
                                $rootScope.$broadcast("cmBoot:appSpinner", "show")
                                cmLogger.debug("Local storage migration. Writing old values to new local storage")
                                for (var key in values) {
                                    try {
                                        cmLogger.debug("Saving key: " + key)
                                        window.localStorage.setItem(key, values[key])
                                    } catch(e) {
                                        cmLogger.error("Error writing to local storage: " + e)
                                    }
                                }
                                cmMigrate.migrationComplete()
                                // reload app, to reinitialize storage. TODO: find a way to do this without reload
                                location.reload()

                            }, function(reason) {
                                cmLogger.error("Could not migrate local storage: " + reason)
                            }
                        )
                    });
                }
            }

            return deferred.promise;
        };

        /**
         * Returns current active Identity
         * @returns {data.identity|*}
         */
        this.getIdentity = function(){
            //cmLogger.debug('cmUserModel:getIdentity');
            return this.data.identity;
        };

        this.setIdentity = function(identity_data){
            //cmLogger.debug('cmUserModel:setIdentity');

            this.importData(cmIdentityFactory.clear(identity_data).create(identity_data, true),[]);

            return this;
        };

        this.getAccount = function(){
            return this.data.account;
        };

        this.importAccount = function(data){
            //cmLogger.debug('cmUserModel.importAccount');

            this.data.account.loginName = data.loginName || this.data.account.loginName;

            if(typeof data.email != 'string') {
                this.data.account.email = data.email || this.data.account.email;
            } else {
                this.data.account.email = {value:data.email,isVerified:false};
            }

            if(typeof data.phoneNumber != 'string') {
                this.data.account.phoneNumber = data.phoneNumber || this.data.account.phoneNumber;
            } else {
                this.data.account.phoneNumber = {value:data.phoneNumber,isVerified:false};
            }

            if(typeof data.registrationIncomplete != 'undefined'){
                this.data.account.registrationIncomplete = data.registrationIncomplete
            }

            this.trigger('account:updated');
        };

        /**
         * @TODO add Error Codes in BE
         * - invalid phoneNumber
         */
        this.updateAccount = function(newAccountData){
            //cmLogger.debug('cmUserModel.updateAccount');
            var deferred = $q.defer();

           cmAuth.putAccount(newAccountData).then(
                function(){
                    self.importAccount(newAccountData);
                    deferred.resolve();
                },
               function(result){
                    deferred.reject(result);
               }
            );

            return deferred.promise;
        };

        /**
         * @todo more better logic
         * @returns {*}
         */
        this.isAuth = function(){
//            if(this.getToken() !== false){
//                // do identity request for checking token
//                if(isAuth !== true){
//                    // check ob identity loading runs
//                    if(initialize == 'done'){
//
//                    }
//                }
//            }

            return this.getToken();
        };

        this.setAuth = function(){
            isAuth = true
        };

        this.isGuest = function(){
            if(this.data.userType == 'external'){
                return true;
            }

            return false;
        };

        this.doLogin = function(user, pass, accountData){
//            cmLogger.debug('cmUserModel:doLogin');

            var deferred = $q.defer();

            cmAuth.requestToken(user, pass).then(
                function(token){
                    cmAuth.storeToken(token, true);

                    self.loadIdentity(accountData).finally(
                        function(){
                            deferred.resolve();
                        }
                    );
                    $rootScope.$broadcast('login');
                },
                function(state, response){
                    deferred.reject(state, response);
                }
            );

            return deferred.promise;
        };

        this.doLogout = function(goToLogin, where){
            //cmLogger.debug('cmUserModel:doLogout',where);

            $rootScope.$broadcast('logout', {
                token:this.getToken(),
                goToLogin: goToLogin,
                where: where
            });
        };

        this.switchToIdentity = function(identity, identityToken){
            //cmLogger.debug('cmUserModel:switchToIdentity');
            //console.log('new identity', identity.getDisplayName())

            function doSwitch(newToken){
                self.storeToken(newToken, true);
                $rootScope.$broadcast('identity:switched');
            }

            if(identityToken){
                doSwitch(identityToken);
            } else {
                cmAuth.getIdentityToken(identity.id).then(
                    function (res) {
                        doSwitch(res.token);
                    }
                );
            }
        };

        /**
         * Key Handling
         */
        this.getLocalKeyIdsForRequest = function(){
            if(this.isAuth !== false){
                var keys = this.loadLocalKeys(),
                    queryString = '';

                if(keys.length > 0){
                    keys.forEach(function(key){
                        queryString += '&keyId=' + key.id;
                    });
                }

                return queryString;
            }

            return '';
        };

        this.hasLocalKeys = function(){
            var keys = this.loadLocalKeys();

            if(keys.length > 0)
                return true;

            return false;
        };

        /**
         * @param key
         * @returns {*}
         */
        this.storeKey = function(key){
            var local_keys      = this.loadLocalKeys() || new cmKeyFactory()

            local_keys.create(key.exportData(), true);

            this.storageSave('rsa', local_keys.exportDataArray());

            this.trigger('key:stored');

            return this;
        };

        this.loadLocalKeys = function(){
            var storedKeys  = this.storageGet('rsa') || [],
                keys        = cmKeyFactory();

            var returnKeys = keys.importFromDataArray(storedKeys)

            return returnKeys
        };

        this.hasPrivateKey = function(){
            var keys = this.loadLocalKeys(),
                result = false;

            keys.forEach(function(key){         
                result = result || !!key.getPrivateKey()
            });

            return result;
        };

        this.syncLocalKeys = function(){
            /**
             * check local Keys from Storage
             */
            
            var localKeys = this.loadLocalKeys() || [];

            localKeys.forEach(function(local_key){

                var no_matching_public_key_present = !self.data.identity.keys || !self.data.identity.keys.find(local_key),
                    missing_key_id = !local_key.id

                if(no_matching_public_key_present || missing_key_id){

                    if(local_key.getPublicKey() == undefined){
                        cmLogger.error('broken pubkey in localstorage! that can\'t be synced.');
                        return false;
                    }

                    cmAuth.savePublicKey({
                        name:    local_key.name, 
                        key:     local_key.getPublicKey(),
                        keySize: local_key.getSize()
                    })
                    .then(
                        function(data){
                            //data brings an id for the key
                            local_key.importData(data)

                            //add public key to identity
                            self.data.identity.keys.create(data)

                            //store the key with its new id:
                            self.storeKey(local_key)

                            // event for handshake modal
                            self.trigger('key:saved', {keyId: data.id});
                        },
                        function(){
                            self.removeLocalKey(local_key);
                        }
                    )
                }
            });

            return this;
        };

        this.removeKey = function(keyToRemove){
            var self            = this,
                local_keys      = this.loadLocalKeys(),
                foundInLocalKeys = -1;

            // clear in backend
            cmAuth
            .removePublicKey(keyToRemove.id)
            .then(function(){
                self.removeLocalKey(keyToRemove);
            });
        };

        this.removeLocalKey = function(keyToRemove){
            var local_keys = this.loadLocalKeys();
            // renew ls
            if(local_keys.deregister(keyToRemove)){
                this.storageSave('rsa', local_keys.exportDataArray());
            }
            // clear identity
            this.data.identity.keys.deregister(keyToRemove);

            this.trigger('key:removed');
        };

        /**
         * [getTrustToken description]
         * Used to sign a trusted key with!
         * @param  {[type]} keyToTrust [description]
         * @param  {[type]} ownerId    [description]
         * @return {[type]}            [description]
         */
        this.getTrustToken = function(keyToTrust, ownerId){
            //cmLogger.debug('cmUserModel.getTrustToken');
            var dataObject =    {
                                    pubKey: keyToTrust.getPublicKey(),
                                    identifier: ownerId
                                }
            return  cmCrypt.hashObject(dataObject)
        };

        this.signData = function(data){
            return  $q.all(this.loadLocalKeys().map(function(signingKey){                
                        return  signingKey.sign(data)
                                .then(function(signature){
                                    return  $q.when({
                                                keyId   : signingKey.id,
                                                content : signature 
                                            })
                                })
                    }))
        }

        this.signPublicKey = function(keyToSign, keyToSignFingerprint, identity){
            //cmLogger.debug('cmUserModel.signPublicKey');

            identity = identity || self.data.identity

            if(!(keyToSign instanceof cmKey) || (keyToSign.getFingerprint() !== keyToSignFingerprint)){
                self.trigger('signatures:cancel');
                return $q.reject();
            }

            var localKeys = this.loadLocalKeys();

            return  $q.all(localKeys.map(function(signingKey){
                        // Keys should not sign themselves
                        if(!signingKey.id || signingKey.id == keyToSign.id || (signingKey.getFingerprint() == keyToSign.getFingerprint())){
                            self.trigger('signatures:cancel');
                            //cmLogger.debug('cmUserModel.signPublicKey() failed; key tried to sign itself.')
                            return $q.when(false);
                        }

                        // Dont sign twice:
                        if(keyToSign.signatures.some(function(signature){ return signature.keyId == signingKey.id })){
                            self.trigger('signatures:cancel');
                            //cmLogger.debug('cmUserModel.signPublicKey() failed; dublicate signature.')
                            return $q.when(false); 
                        }

                        cmLogger.debug('cmUserModel.signPublicKey: signing...')

                        return signingKey.sign(self.getTrustToken(keyToSign, identity.cameoId))
                                .then(function(signature){
                                    return cmAuth.savePublicKeySignature(signingKey.id, keyToSign.id, signature)
                                })
                                .then(
                                    function(signature){
                                        keyToSign.importData({signatures:[signature]})  
                                        return signature                          
                                    },
                                    function(){
                                        self.trigger('signatures:failed');
                                    }
                                )
                    }))
                    .then(function(result){
                        self.trigger('signatures:saved', result)
                    })
        };

        this.verifyOwnPublicKey = function(key){
            // cmLogger.debug('cmUserModel.verifyOwnPublicKey');

            return this.loadLocalKeys().reduce(function(previous_try, local_key){
                return  previous_try
                        .catch(function(){
                            return  local_key.verifyKey(key, self.getTrustToken(key, self.data.identity.cameoId))
                        })
            }, $q.reject())
        };

        this.signOwnKeys = function(){
            //cmLogger.debug('cmUserModel.signOwnKeys');
            return this.verifyIdentityKeys(this.data.identity, true)
        };

        /**
         * [verifyIdentityKeys Checks for keys that are either signed by a local key or keys that are signed by a key of the former kind and have the same owner as the signing key]
         * @param  {cmIdentitymodel} identity [description]
         * @return {cmKeyFactory}   cmKeyFactory returning all transitively trusted keys of identity. Users local keys are assumed to be trusted.
         */

        this.verifyIdentityKeys = function(identity, sign, use_cache){
            //cmLogger.debug('cmUserModel.verifyIdentityKeys');

            identity            = identity || self.data.identity;
            var own_identity    = self.data.identity;

            if(sign && use_cache){
                cmLogger.error('Tried to sign keys relying on cache.')
                throw('Tried to sign keys relying on cache.')
            }

            if(!identity.keys)
                return $q.when([])

            if(!own_identity.keys)
                return $q.when([])

            var local_keys = this.loadLocalKeys();

            return  $q.when()
                    .then(function(){
                        return  own_identity.keys.getTransitivelyTrustedKeys(local_keys, function trust(trusted_key, key){
                                    return trusted_key.verifyKey(key, self.getTrustToken(key, own_identity.cameoId), use_cache)
                                })
                    })
                    .then(function(own_ttrusted_keys){
                        return  identity.keys.getTransitivelyTrustedKeys(own_ttrusted_keys, function trust(trusted_key, key){
                                    return trusted_key.verifyKey(key, self.getTrustToken(key, identity.cameoId), use_cache)
                                });
                    })
                    .then(function(ttrusted_keys){


                        //looks for keys that are transitively trusted but not yet signed by all local keys:
                        var unsigned_ttrusted_keys  =   ttrusted_keys.filter(function(ttrusted_key){
                                                            return  local_keys.some(function(local_key){
                                                                        return  ttrusted_key.signatures.every(function(signature){
                                                                                    return signature.keyId != local_key.id
                                                                                })
                                                                    })
                                                        });


                        if(sign != true || unsigned_ttrusted_keys.length == 0)
                            return $q.when(ttrusted_keys);

                        self.state.set('signing');

                        $q.all(
                            unsigned_ttrusted_keys.map(function(ttrusted_key){
                                //console.info('signing: '+ttrusted_key.name)
                                return  self.data.identity == own_identity
                                        ?   self.signPublicKey(ttrusted_key, ttrusted_key.getFingerprint(), identity)
                                        :   $q.reject('cmUserModel: wrong identity tries to sign verified keys!')
                            })
                        )
                        .finally(function(){
                             self.state.unset('signing')
                        });

                        return $q.when(ttrusted_keys)
                    })
        };

        this.verifyTrust = function(identity, use_cache){
            return  identity.keys.length != 0
                    ?   this.verifyIdentityKeys(identity, null, use_cache)
                        .then(function(trusted_keys){
                            return  identity.keys.length == trusted_keys.length
                                    ?   $q.when()
                                    :   $q.reject('untrusted key found.')
                        })
                    :  $q.reject('missing keys.')
        };

        this.clearLocalKeys = function(){
            this.storageSave('rsa', []);
        };

        this.decryptPassphrase = function(encrypted_passphrase, keyId){
            var keys    =   this.loadLocalKeys().filter(function(key){
                                return (!keyId || key.id == keyId)
                            })


            return keys.reduce(function(previous_try, key){
                return  previous_try
                        .catch(function(){
                                return  key.decrypt(encrypted_passphrase)
                        })
            }, $q.reject('cmUserModel.decrypt(): missing local keys.'))

        };

        /**
         * @deprecated
         */
        this.bulkReKeying = function(localKeyId){
            //cmLogger.debug('cmUserModel.startBulkReKeying');

            console.log('cmUserModel.bulkReKeying depracted!');

            if(!this.state.is('rekeying')){
                this.state.set('rekeying');

                if(typeof localKeyId == 'string' && cmUtil.validateString(localKeyId)){
                    var localKey    = this.loadLocalKeys().find(localKeyId);

                    if(localKey instanceof cmKey){

                        this.data.identity.getTrustedKeys().then(
                            function(trusted_keys){

                                var rekeying_processes = [];

                                trusted_keys.forEach(function(key){
                                    if(key.id != localKey.id){

                                        rekeying_processes.push(cmAuth.getBulkPassphrases(localKey.id, key.id).then(
                                            function(list){
                                                if(list.length == 0)
                                                    return [];

                                                //re and encrypt passphrasees one by one, dont try to de and encrypt them all simultaniuosly:
                                                list.reduce(function(previous_run, item){
                                                    return  previous_run
                                                        .then(function(list_so_far){
                                                            return  self.decryptPassphrase(item.aePassphrase, localKey.id)
                                                                .then(function(passphrase){
                                                                    return key.encrypt(passphrase)
                                                                })
                                                                .then(function(encrypted_passphrase){
                                                                    return  list_so_far.concat([{
                                                                        conversationId: item.conversationId,
                                                                        aePassphrase:   encrypted_passphrase
                                                                    }])
                                                                })

                                                        })
                                                }, $q.when([]))
                                                    .then(function(newList){
                                                        return  cmAuth.saveBulkPassphrases(key.id, newList)
                                                    })
                                                    .then(
                                                        function(){
                                                            return  cmApi.broadcast({
                                                                name: 'rekeying:finished',
                                                                data:{
                                                                    keyId: key.id
                                                                }
                                                            });
                                                        },
                                                        function(){
                                                            cmLogger.debug('cmUserModel.bulkReKeying - Request Error - saveBulkPassphrases');
                                                        }
                                                    )
                                            },
                                            function(){
                                                cmLogger.debug('cmUserModel.bulkReKeying - Request Error - getBulkPassphrases');
                                            }
                                        ))
                                    }
                                });

                                $q.all(rekeying_processes).finally(
                                    function(){
                                        self.trigger('bulkrekeying:finished');
                                        self.state.unset('rekeying');
                                    }
                                );
                            }
                        );
                    }
                } else {
                    cmLogger.debug('cmUserModel.bulkReKeying - Parameter Error - getBulkPassphrases');
                    this.trigger('bulkrekeying:aborted');
                    this.state.unset('rekeying');
                }
            }
        };

        this.verifyPublicKeyForAuthenticationRequest = function(toKey, identity){
            identity = identity || self.data.identity

            var publicKeys = identity.keys;
            var localKeys = this.loadLocalKeys();


            return      toKey instanceof cmKey
                    &&  publicKeys.find(toKey) != null 
                    &&  localKeys.length > 0 
                    &&  localKeys.find(toKey) == null
        };

        /**
         * Token Functions
         * @TODO handle Token with identity
         */
        this.getToken = function(){
            //cmLogger.debug('cmUserModel:getToken');

            var token = cmAuth.getToken();

            if(token !== undefined && token !== 'undefined' && token !== null && token.length > 0){
                return token;
            }

            return false;
        };

        this.storeToken = function(token, force){
            //cmLogger.debug('cmUserModel:storeToken');
            cmAuth.storeToken(token, force);

            return this;
        };

        this.removeToken = function(where){
            //cmLogger.debug('cmUserModel:removeToken');
            cmAuth.removeToken(where);

            return this;
        };

        /**
         * LocalStorage Functions
         */
        this.initStorage = function(){
            this.data.storage = cmLocalStorage.create(this.data.id, this.data.userKey);
        };

        /**
         * save to identity storage
         * @param key
         * @param value
         */
        this.storageSave = function(key, value){
            if(isAuth !== false && this.data.storage !== null){
                this.data.storage.save(key, value);

                return true;
            }

            return false;
        };

        /**
         *  get from identity storage
         * @param key
         */
        this.storageGet = function(key){            
            if(isAuth !== false && this.data.storage !== null){
                return this.data.storage.get(key);
            }

            return null;
        };

        /**
         * remove from identity storage
         * @param key
         */
        this.storageRemove = function(key){
            if(isAuth !== false && this.data.storage !== null){
                this.data.storage.remove(key);
            }
        };

        /**
         * setLocalStorageSettings
         * Server Overwrite Local Changes
         */
        this.setAppSettings = function(data){
            //cmLogger.debug('cmUserModel.setAppSettings');
            var settings = this.storageGet('appSettings') || {};

            if('userSettings' in data){
                this.storageSave('appSettings', angular.extend({}, settings, data.userSettings));
            }
        };

        this.saveAppSettings = function(){
            //cmLogger.debug('cmUserModel.saveAppSettings');
            var settings = this.storageGet('appSettings') || {};

            if(cmUtil.objLen(settings) > 0){
                this.updateAccount({'userSettings': settings})
            }
        };

        /**
         * clear identity storage
         */
        this.resetUser = function(){
            this.reset();
        };

        init();

        /**
         * Event Handling
         */
        $rootScope.$on('logout', function(event, data){
            //cmLogger.debug('cmUserModel - $rootScope.logout');

            $rootScope.generateAutomatic = undefined;

            self.reset();
            isAuth = false;

            if(typeof data == 'object' && 'where' in data){
                self.removeToken(data.where);
            } else {
                self.removeToken();
            }

            if(self.getToken() !== false){
                cmLogger.error('Token was not removed at logout!');
                throw new Error('Failure at Logout Process!')
            }

            if(typeof data == 'object' && 'goToLogin' in data && typeof data.goToLogin === 'undefined' || data.goToLogin !== false){
                $rootScope.goTo('/login');
            }
        });

        $rootScope.$on('identity:switched', function(){
            self.resetUser();
            init();
            self.one('update:finished', function(){
                if(!self.hasLocalKeys()){
                    $rootScope.goTo('/setup/keyinfo');
                } else {
                    $rootScope.goTo('/talks');
                }
            });
        });

        this.on('update:finished', function(){
            cmBoot.ready.userModel();
        });

        this.on('account:updated', function(){
            cmBoot.ready.account();
        });

        var signOwnKeys_scheduled = false;

        cmAuth.on('identity:updated', function(event, data){
            if(typeof data.id != 'undefined' && data.id == self.data.identity.id) {
                self.data.identity.importData(data);
                self.syncLocalKeys()

                //Todo: find a more general solution: AP
                if(signOwnKeys_scheduled === false){
                    signOwnKeys_scheduled = true         
                    $timeout(function(){
                        signOwnKeys_scheduled = false
                        self.signOwnKeys()
                    }, 20000, false)
                }
            }
        });

        cmAuth.on('identity:new', function(event, data){
            if(typeof data.id != 'undefined' && data.id != self.data.identity.id) {
                var tmpIdentity = cmIdentityFactory.clear(data).create(data);
                self.data.identities.push(tmpIdentity);
            }
        });

        cmAuth.on('account:update', function(event, data){
            self.importAccount(data);
        });

    }
])

.service('cmUtil',
    function(cmLogger, $window, $injector, $document){
        /**
         * Checks if Key exists in an Object or Array
         * @param object
         * @param key
         * @returns {boolean}
         */
        this.checkKeyExists = function(object, key){
            if(angular.isDefined(object) && (typeof object === 'object' || typeof object === 'array') && angular.isDefined(key) && key != ''){
                var arr = Object.keys(object);

                if(arr.indexOf(key) !== -1){
                    return true;
                }
            }

            return false;
        };

        /**
         * Creates a String for Limit-Offset Handling in Api-Calls
         * @param limit
         * @param offset
         * @returns {string}
         */
        this.handleLimitOffset = function(limit,offset,timeLimit){
            var s = '';

            if(angular.isDefined(timeLimit) && this.validateInt(timeLimit) !== false){
                s = '?timeLimit=' + parseInt(timeLimit);
            } else {
                if(angular.isDefined(limit) && this.validateInt(limit) !== false){
                    s = '?limit=' + parseInt(limit);
                } else {
                    //default limit
                }

                if(s != '' && angular.isDefined(offset) && this.validateInt(offset) !== false){
                    s += '&offset=' + parseInt(offset);
                }
            }

            return s;
        };

        /**
         * Validate Numbers
         * @param val
         * @returns {boolean}
         */
        this.validateInt = function(val){
            var reg = /^\d+$/;

            return reg.test(val);
        };

        /**
         * Validate Strings without Special Characters and Whitespaces
         * @param val
         * @returns {boolean}
         */
        this.validateString = function(val){
            var reg     = /^[a-zA-Z0-9\-_]{1,}$/,
                valid   = reg.test(val)

            if(!valid)
                cmLogger.debug('cmUtil: validateString() failed for: ' + val)

            return valid;
        };

        /**
         * convert json to more row string
         * @param json
         * @returns well formated string
         */
        this.prettify = function(json){

            function censor(censor) {
                var i = 0;

                return function(key, value) {
                    if(i !== 0 && typeof(censor) === 'object' && typeof(value) == 'object' && censor == value)
                        return '[Circular]';

                    if(i >= 29) // seems to be a harded maximum of 30 serialized objects?
                        return '[Unknown]';

                    ++i; // so we know we aren't using the original object anymore

                    return value;
                }
            }

            return JSON.stringify(json, censor(json), 2);
        };

        /**
         * return key length of an object
         * @param obj
         * @returns {Number}
         */
        this.objLen = function(obj){
            if(obj == undefined)
                obj = {};
            return Object.keys(obj).length;
        };

        /**
         * convert first letter of string to Uppercase
         * @param string
         * @returns {string}
         */
        this.ucFirst = function(string){
            if(string == undefined || typeof string != 'string')
                string = '';

            string += '';
            var f = string.charAt(0).toUpperCase();
            return f + string.substr(1);
        };

        /**
         * converts bytes to human readable string
         * @param bytes
         * @returns {string}
         */
        this.bytesToStr = function(bytes) {
            var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            if (bytes == 0 || typeof bytes != 'number') return 'n/a';
            var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
        };

        /**
         *
         * @param current (integer) unix timestamp in ms
         * @param prev (integer) unix timestamp in ms
         * @returns {boolean} returns true, if day is different
         */
        this.compareDate = function(current, prev){
            if (typeof current !== 'undefined' && typeof prev !== 'undefined') {
                if (current > prev) {
                    var cDate = new Date(current);
                    var pDate = new Date(prev);

                    if ((cDate.getUTCFullYear() > pDate.getUTCFullYear())
                        || (cDate.getUTCMonth() > pDate.getUTCMonth())
                        || (cDate.getUTCDate() > pDate.getUTCDate())
                    ) {
                        return true;
                    }
                }
            } else if (typeof current !== 'undefined' && typeof prev === 'undefined') {
                return true;
            }
            return false;
        };

        /**
         * convert milliseconds to human readable string
         * @param milliseconds
         * @returns {string}
         */
        this.millisecondsToStr = function(milliseconds, printOutMs) {
            // TIP: to find current time in milliseconds, use:
            // var current_time_milliseconds = new Date().getTime();

            function addToString(newStr){//addWhiteSpace
                str+= (str != '' ? ' ': '')+newStr
            }

            if(typeof milliseconds != 'number')
                return 'n/a';

            var str = '',
                temp = milliseconds / 1000,
                years = Math.floor(temp / 31536000);

            if (years)
                addToString(years + 'y');

            var days = Math.floor((temp %= 31536000) / 86400);
            if (days)
                addToString(days + 'd');

            var hours = Math.floor((temp %= 86400) / 3600);
            if (hours)
                addToString(hours + 'h');

            var minutes = Math.floor((temp %= 3600) / 60);
            if (minutes)
                addToString(minutes + 'm');

            var seconds = temp % 60;
            if (seconds && !printOutMs)
                addToString(Math.floor(seconds) + 's');

            if(seconds && printOutMs)
                addToString(temp + 's');

            if(str == '')
                addToString('...');

            return str;
        };

        /**
         * return type of given variable especially for array and objects
         * @param x
         * @returns {String}
         */
        this.getType = function(x){
            if(typeof x == 'string') return('String')

            var regex  = /\[object (.*)\]/,
                results = regex.exec(x.toString())

            return (results && results.length > 1) ? results[1] : '';
        };

        /**
         * check if string starts with needle
         * @param haystack
         * @param needle
         * @returns {boolean}
         */
        this.startsWith = function(haystack, needle){
            if(haystack == undefined || haystack == '' || needle == undefined) return false;
            return haystack.slice(0, needle.length) == needle;
        };

        /**
         * check if string ends with needle
         * @param haystack
         * @param needle
         * @returns {boolean}
         */
        this.endsWith = function (haystack, needle){
            if(haystack == undefined || haystack == '' || needle == undefined) return false;
            return haystack.slice(-needle.length) == needle;
        };

        this.isArray = function(value) {
            return Object.prototype.toString.call(value) === '[object Array]';
        };

        this.isAlphaNumeric = function(id, length){
            var alphNumericRegExp = "^[a-zA-Z0-9]{"+(length||20)+"}$";
            var matches = id ? String(id).match(alphNumericRegExp) : null;
            return matches != null;
        };

        this.scrollToInputError = function() {
            var el          = document.querySelector(".cm-input-error:not(.ng-hide)") || document.querySelector("form .ng-invalid:not(.ng-hide)") || document.querySelector(".cm-alert:not(.ng-hide)"),
                offset      = this.getOffsetToBody(el),
                bodyAndHtml = angular.element($document[0].querySelectorAll('body,html')),
                cmHeader    = angular.element($document[0].querySelector('cm-header'));

            angular.forEach(bodyAndHtml, function (tag) {
                tag.scrollTop = offset.top - cmHeader[0].offsetHeight - 10; //-10 for the looks
            });
        };

        /**
         * Function returns a reference of requested parent element.
         * @param {String} tag_name Tag name of requested parent element.
         * @param {HTMLElement} el Initial element (from which search begins).
         */
        this.findParent = function(tag_name, el) {
            // loop up until parent element is found
            while (el && el.nodeName.toLowerCase() !== this.camelCaseToDash(tag_name)) {
                el = el.parentNode;
            }
            // return found element
            return el;
        };

        this.isInParent = function(parent, children){
            var el = children;

            while (el && el !== parent) {
                el = el.parentNode;

                if(el == parent){
                    return true;
                }
            }
            return false;
        };

        this.getOffsetToBody = function(el){
            var top=0, left=0;
            while(el) {
                top = top + parseInt(el.offsetTop);
                left = left + parseInt(el.offsetLeft);
                el = el.offsetParent;
            }
            return {top: top, left: left};
        };

        this.camelCaseToDash = function(str){
            return typeof str == 'string'
                  ? str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
                  : false;
        }
    }
)
angular.module('comps/files/drtv-choose-source.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/files/drtv-choose-source.html',
'<div class="wrapper {{options.tooltip}}" ng-show="showList"><i ng-if="options.tooltip == \'down\'" class="fa cm-nose-up flip"></i><div class="source" ng-repeat="type in types" ng-click="choosedType(type)" cm-reactive><i class="fa {{type.icon}}"></i>{{\'DRTV.CHOOSE_SOURCE.\'+type.i18n|cmTranslate}}</div><i ng-if="options.tooltip == \'up\'" class="fa cm-nose-down flip"></i></div>');
}]);
angular.module('comps/files/drtv-files-preview.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/files/drtv-files-preview.html',
'<div class="file-wrap" ng-repeat="file in files"><i class="fa cm-close" cm-reactive ng-click="removeFile(file)"></i><div class="file-image" ng-if="file.isImage()"><cm-loader ng-show="!file.loaded" class="full-inline"></cm-loader><img cm-blob-image="file" /></div><div ng-if="!file.isImage()" class="file {{file.detectedExtension}}"></div></div>');
}]);
angular.module('comps/files/drtv-upload-avatar.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/files/drtv-upload-avatar.html',
'<button><i class="fa cm-settings" ng-show="!imageUpload"></i><cm-loader ng-show="imageUpload"></cm-loader></button><cm-files ng-model="files" id="files-droparea" data-qa="avatar-upload-btn"><cm-file-choose cm-droparea="files-droparea" cm-accept="image/*"></cm-file-choose><cm-choose-source cm-options="{tooltip:\'down\',useFrontCamera:true}"></cm-choose-source></cm-files>');
}]);
angular.module('cmFiles',[
    'cmCore',
    'cmUi',
    'cmPhonegap'
,'comps/files/drtv-choose-source.html','comps/files/drtv-files-preview.html','comps/files/drtv-upload-avatar.html'])
.directive('cmBlobImage',[
    'cmFilesAdapter',
    function (cmFilesAdapter) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs){

                function showFile(file){
                    // mocked
                    if('url' in file && 'src' in file.url){
                        element.attr('src', file.url.src);
                        element.on('load', function(){
                            // hide spinner
                            scope.$apply(function(){
                                file.loaded = true;
                            });
                        });
                    // loaded
                    } else if(typeof file.blob == 'object'){
                        cmFilesAdapter
                        .getBlobUrl(file.blob, true)
                        .then(
                            function(objUrl){
                                file.url = objUrl;
                                element.attr('src', file.url.src);
                                element.on('load', function(){
                                    // hide spinner
                                    scope.$apply(function(){
                                        file.loaded = true;
                                    });
                                });
                                element.on('error', function(){
                                    scope.$apply(function(){
                                        file.loaded = true;
                                    });
                                })
                            }
                        );

                    } else {
                        // hide spinner
                        file.loaded = true;
                    }
                }

                function handleBlob(file){
                    if(typeof file !== 'undefined'){
                        if(file.state.is('cached') || file.state.is('new')){
                            showFile(file);
                        }

                        file.on('file:cached', function(){
                            showFile(file);
                        });

                        file.on('upload:finish', function(){
                            showFile(file);
                        });
                    }
                }

                // load image via fileapi
                scope.$watch(attrs.cmBlobImage, handleBlob);
            }
        }
    }
])
.directive('cmBlobVideoAudio',[
    'cmDevice', 'cmFilesAdapter',
    function (cmDevice, cmFilesAdapter) {
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                function showFile(file){
                    // mocked
                    if('url' in file && 'src' in file.url){
                        element.attr('src', file.url.src);
                        if(file.url.src && file.url.src != ' ')
                            fileReady(file);
                    // loaded
                    } else if(typeof file.blob == 'object'){
                        var canPlay = element[0].canPlayType(file.type);
                        // browser supports file
                        if(!cmDevice.isiOS() && canPlay) {
                            cmFilesAdapter.getBlobUrl(file.blob).then(function(objUrl){
                                file.url = objUrl;
                                element.attr('src', file.url.src);
                                fileReady(file);
                            });
                        // file can't play via html5 video
                        } else {
                            fileReady(file);

                            var fileEl = angular
                                .element('<div class="file '+file.detectedExtension+'" ></div>')
                                .on('click',function(){
                                    file.promptSaveAs()
                                });

                            element.parent().html('').append(fileEl[0]);
                        }
                        // can play mov without use filereader...
//                        element.attr('src',window.URL.createObjectURL(file.blob));
                    } else {
                        // hide spinner
                        file.loaded = true;
                    }
                }

                function handleBlob(file){
                    if(typeof file !== 'undefined'){
                        if(file.state.is('cached') || file.state.is('new')){
                            showFile(file);
                        }

                        file.on('file:cached', function(){
                            showFile(file);
                        });

                        file.on('upload:finish', function(){
                            showFile(file);
                        });
                    }
                }

                function fileReady(file){
                    // hide spinner
                    file.loaded = true;
                }

                // load image via fileapi
                scope.$watch(attrs.cmBlobVideoAudio, handleBlob);
            }
        }
    }
])
// https://github.com/apache/cordova-plugin-camera/blob/b76b5ae670bdff4dd4c716e889ab12e049f9c733/doc/index.mdhttps://github.com/apache/cordova-plugin-camera/blob/b76b5ae670bdff4dd4c716e889ab12e049f9c733/doc/index.md

.directive('cmChooseSource', [
    'cmDevice', 'cmCamera', 'cmAnswerFiles',
    '$rootScope', '$document',
    function (cmDevice, cmCamera, cmAnswerFiles,
              $rootScope, $document) {

        return {
            restrict: 'E',
            templateUrl: 'comps/files/drtv-choose-source.html',
            scope: {
                cmOptions: '=cmOptions'
            },
            controller: function($scope){
                // option for drtv
                $scope.options = angular.extend({}, {
                    tooltip:'up', // up | down
                    useFrontCamera: false
                }, $scope.cmOptions || {});
            },

            link: function (scope, element) {
                // only for phonegap
                if (!cmDevice.isApp() && !cmDevice.isAndroid()) {
                    return false;
                }

                // source types
                scope.types = [
                    {icon:'cm-camera',i18n:'CAMERA'},
                    {icon:'cm-file',i18n:'FILE'}
                ];

                // watch for extern handler
                var kill_listener = $rootScope.$on('cmChooseSource:open', function(){
                    scope.toggleList('show',true);
                });

                // type handler
                scope.choosedType = function(type){
                    scope.toggleList('close');
                    switch(type.i18n.toLowerCase()){
                        case "camera":
                            cmCamera.takePhoto(function(blob){
                                cmAnswerFiles.set(blob);
                            },scope.options.useFrontCamera);
                        break;
                        case "file":
                            cmCamera.chooseFile(function(blob){
                                blob.useLocalUri = true;
                                cmAnswerFiles.set(blob);
                            });
                        break;
                    }
                };

                // click outside
                var body = angular.element($document[0].querySelector('body'));

                function findParent (tag_name, el) {
                    // loop up until parent element is found
                    while (el && el.nodeName.toLowerCase() !== tag_name) {
                        el = el.parentNode;
                    }
                    // return found element
                    return el;
                }

                function clickOutside(e){
                    if(e.target != element[0] && // target not emojilist
                        !findParent('cm-choose-source',e.target) // chooselist isnt parent
                     && !findParent('cm-files',e.target) // isnt handler
                        ) {
                        scope.toggleList('close',true);
                    }
                }

                scope.toggleList = function(action, withApply){
                    scope.showList = action && action == 'close'
                                  || action && action == 'show' && scope.showList
                                  || !action && scope.showList
                                  ? false : true;

                    if(scope.showList){
                        body.on('click',clickOutside);
                        body.on('touchstart',clickOutside);
                    } else {
                        body.off('click',clickOutside);
                        body.off('touchstart',clickOutside);
                    }

                    if(withApply != undefined && withApply)
                        scope.$apply();
                };

                scope.toggleList('close');

                scope.$on('$destroy',function(){
                    kill_listener();
                    body.off('click',clickOutside);
                    body.off('touchstart',clickOutside);
                });
            }
        }
    }]
)
// https://github.com/apache/cordova-plugin-camera/blob/b76b5ae670bdff4dd4c716e889ab12e049f9c733/doc/index.mdhttps://github.com/apache/cordova-plugin-camera/blob/b76b5ae670bdff4dd4c716e889ab12e049f9c733/doc/index.md

.directive('cmFileChoose', [
    'cmDevice', 'cmAnswerFiles',
    '$rootScope',
    function (cmDevice, cmAnswerFiles,
              $rootScope) {

        var tpl = '<input type="file" data-qa="btn-file-choose" accept="{{accept}}" />';

        return {
            restrict: 'AE',
            template: tpl,

            controller: function($scope, $element, $attrs){
                // use accept var
                $scope.accept = '*';//file_extension|audio/*|video/*|image/*|media_type
                if('cmAccept' in $attrs){
                    $scope.accept = $attrs.cmAccept;
                }
            },
            link: function (scope, element, attrs) {
                var index = 1;

                // add countrer for save resets
                function addCounter(){
                    element.find('input').attr('cm-resets',index);
                }

                // phonegap
                if (cmDevice.isApp() && cmDevice.isAndroid()){
                    element.on('click', function (evt) {
                        evt.preventDefault();
                        evt.stopPropagation();

                        // broadcast choos opener
                        $rootScope.$broadcast('cmChooseSource:open');
                    });
                } else {
                    // default fileapi
                    // file is selected
                    element.on('change', function (event) {
                        cmAnswerFiles.set(event.target.files[0]);
                    });
                }

                // reset files from sended message
                function callback_files_reset(){
                    element.html(tpl.replace('{{accept}}',scope.accept));
                    index++;
                    addCounter();
                }

                cmAnswerFiles.on('file:removed', callback_files_reset);
                scope.$on('$destroy', function(){
                    cmAnswerFiles.off('file:removed', callback_files_reset);
                });

                if(attrs.cmDroparea){
                    var droparea = angular.element(document.getElementById(attrs.cmDroparea));

                    if(droparea != undefined) {
                        droparea.on('dragleave', function (evt) {
                            var target = evt.target;
                            if (target && target === droparea[0]) {
                                droparea.removeClass('files-dragged');
                            }
                            evt.preventDefault();
                            evt.stopPropagation();
                        });

                        droparea.on('dragenter', function (evt) {
                            droparea.addClass('files-dragged');
                            evt.preventDefault();
                            evt.stopPropagation();
                        });

                        droparea.on('dragover', function (evt) {
                            evt.preventDefault();
                            evt.stopPropagation();
                        });

                        droparea.on('drop', function (evt) {
                            evt.preventDefault();
                            evt.stopPropagation();

                            var files = evt.dataTransfer.files;

                            for (var i=0, l=files.length; i<l; i++) {
                                cmAnswerFiles.set(files[i]);
                            }

                            droparea.removeClass('files-dragged');
                        });
                    }
                }

                // init
                addCounter();
            }
        }
    }
])
.directive('cmFilesPreview',[
    'cmAnswerFiles',
    '$rootScope', '$document',
    function(cmAnswerFiles,
             $rootScope, $document) {
        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'comps/files/drtv-files-preview.html',

            controller: function ($scope, $element) {
                $scope.files = cmAnswerFiles.files;

                $scope.removeFile = function(file){
                    cmAnswerFiles.remove(file);
                };

                function callback_files_resetted(){
                    $scope.files = cmAnswerFiles.files;
                }

                cmAnswerFiles.on('files:resetted', callback_files_resetted);
                var watch = $rootScope.$on('cmResizeTextarea:resize', function(){
                    var answerMessage = $document[0].querySelector('cm-answer .message');
                    $element.css('bottom',answerMessage.offsetHeight+'px');
                });

                $scope.$on('$destroy', function(){
                    cmAnswerFiles.off('files:resetted', callback_files_resetted);
                    watch();
                });
            }
        }
    }
])
.directive('cmUploadAvatar',[
    'cmNotify', 'cmUserModel', 'cmAnswerFiles', 'cmErrorCodes',
    '$rootScope', '$timeout',
    function(cmNotify, cmUserModel, cmAnswerFiles, cmErrorCodes,
             $rootScope, $timeout) {
        return {
            restrict: 'E',
            templateUrl: 'comps/files/drtv-upload-avatar.html',

            link: function (scope) {

                var callback_file_setted = function(){
                    cmAnswerFiles.validateChoosenFiles({
                        passphrase: undefined
                    }).then(
                        function(files){
                            if (files.length > 0) {
                                scope.imageUpload = true;
                                files[0].uploadChunks();
                                files[0].one('upload:finish',function(){
                                    cmUserModel
                                        .data.identity
                                        .update({
                                            avatar: files[0].id
                                        });

                                    cmUserModel.data.identity.one('update:finished', function(){
                                        cmUserModel.data.identity.one('avatar:loaded',function(){
                                            $timeout(function(){
                                                scope.imageUpload = false;
                                                $rootScope.$broadcast('cmUploadAvatar:success');
                                            },50);
                                        });
                                    });
                                });
                            }
                        },
                        function(error) {
                            cmNotify.warn(error.codes[0], {
                                ttl: 0,
                                i18n: cmErrorCodes.toI18n(error.codes[0], {
                                    error: error.data,
                                    headers: error.headers
                                })
                            });
                        }
                    )
                };

                scope.imageUpload = false;

                cmAnswerFiles.on('file:setted', callback_file_setted);

                scope.$on('$destroy',function(){
                    cmAnswerFiles.off('file:setted', callback_file_setted);
                });
            }
        }
    }
])
.filter('cmFileSize', [
    'cmFilesAdapter',
    function () {
        return function(bytes, unit) {
            var sizes = ['B', 'KB', 'MB', 'GB', 'TB'],
            units = {
                1000 : ['bytes', 'kb', 'MB', 'GB', 'TB'],
                1024 : ['bytes', 'KiB', 'MiB', 'GiB', 'TiB']
            };

            var base = (unit && unit.toUpperCase().match(/I/gi)) ? 1024 : 1000;

            if (bytes == 0) return 'n/a';
            var i = unit ? sizes.indexOf(unit.toUpperCase().replace(/I/gi)) :-1;

            i = (i == -1) ? parseInt(Math.floor(Math.log(bytes) / Math.log(base))) : i;

            return Math.round(bytes / Math.pow(base, i)*100)/100 + ' ' + units[base][i];
        }
    }
])

.service('cmAnswerFiles', [
    'cmObject', 'cmFileFactory',
    '$q',
    function (cmObject, cmFileFactory,
              $q) {

        var self = {
            files: [],
            set: function (blob) {
//                console.log(blob)

                if (!blob)
                    return false;

                var found = this.files.some(function (file) {
                    return (file.name == blob.name && file.size == blob.size);
                });

                if (found) {
                    return false;
                }

                var file = cmFileFactory.create(blob, true);

                this.files.push(file);

                this.trigger('file:setted');

                return true;
            },
            remove: function (file) {
                if (cmFileFactory.remove(file)) {
                    var index = self.files.indexOf(file);
                    self.files.splice(index, 1);
                    this.trigger('file:removed');
                    return true;
                }

                return false;
            },
            reset: function () {
                this.files = [];
                this.trigger('files:resetted');
            },

            getFilesForTransfer: function(){
                var files = this.files;
                this.reset();
                return files;
            },

            setFiles: function(filesArray){
                this.files = filesArray;
            },

            validateChoosenFiles: function (options) {
                var promises = [];

                // create all files and get fileIds
                angular.forEach(this.files, function (file) {
                    promises.push(
                        file
                            .setPassphrase(options.passphrase)
                            .encryptName()
                            .prepareForUpload(options.conversationId)
                    )
                });

                var deferred = $q.defer();

                $q.all(promises)
                .then(
                    function () {
                        deferred.resolve(self.files);
                        self.reset();
                    },
                    function (result) {
                        deferred.reject({
                            codes: result.data.errorCodes,
                            data: result.data.data,
                            headers: result.config.headers
                        });
                    }
                );

                return deferred.promise;
            }
        };

        cmObject.addEventHandlingTo(self);

        return self;
    }
])
angular.module('cmPhonegap',['cmCore'])
//https://github.com/apache/cordova-plugin-inappbrowser/blob/8ce6b497fa803936784629187e9c66ebaddfbe1b/doc/index.md


.directive('target',[
    'cmDevice',
    '$window',
    function (cmDevice,
              $window){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                if(!cmDevice.isApp()){
                    return false;
                }

                /*
                 target
                 _self: Opens in the Cordova WebView if the URL is in the white list, otherwise it opens in the InAppBrowser.
                 _blank: Opens in the InAppBrowser.
                 _system: Opens in the system's web browser.
                 */

                //

                if(attrs.target != ''){
                    element.on('click',function(event){
                        event.stopPropagation();
                        event.preventDefault();

                        //navigator.app.loadUrl(attrs.href, { openExternal:true });

                        var ref = $window.open(attrs.href, '_system', 'location=yes');

                        // loadstart loadstop loaderror exit
                        // ref.addEventListener(eventname, callback);
                        // ref.removeEventListener(eventname, callback);
                        // ref.close();
                        // ref.show();
                        // ref.executeScript(details, callback);
                        // ref.insertCSS(details, callback);
                    });
                }
            }
        }
    }
])

.factory('$cordova', ['cmPhonegap',
    function(cmPhonegap){
        function init(){
            return typeof cordova != 'undefined' ? cordova : 'undefined';
        }

        var $cordova = init();

        cmPhonegap.isReady('$cordova',function(){
            $cordova = init();
        });

        return $cordova;
    }
])

.factory('$device', ['cmPhonegap',
    function(cmPhonegap){
        function init(){
            return typeof device != 'undefined' ? device : 'undefined';
        }

        var $device = init();

        cmPhonegap.isReady('$device',function(){
            $device = init();
        });

        return {
            get: function () {
                return $device;
            }
        }
    }
])

.factory('$phonegapCameoConfig', [
    function(){
        return typeof phonegapCameoConfig != 'undefined' ? phonegapCameoConfig : 'undefined';
    }
])

.factory('$screen', function(){
    return typeof screen != 'undefined' ? screen : 'undefined';
})
// https://github.com/phonegap-build/PushPlugin


.service('cmPushNotificationAdapter', [
    'cmPhonegap', 'cmDevice', 'cmPushNotifications',
    'cmUtil', 'cmLanguage', 'cmApi', 'cmLogger', 'cmObject',
    '$rootScope', '$window', '$injector',
    function (cmPhonegap, cmDevice, cmPushNotifications,
              cmUtil, cmLanguage, cmApi, cmLogger, cmObject,
              $rootScope, $window, $injector) {

        var self = {
            plugin: null,
            currentDeviceData: {
                token: undefined,
                id: undefined
            },
            deviceIsRegistrated: false,
            isDeviceRegistrated: function(){
                return this.deviceIsRegistrated;
            },

            init: function(){
                cmPhonegap.isReady('cmPushNotificationAdapter.init',function(){
                    if(!('plugins' in $window) || !('pushNotification' in $window.plugins)) {
                        //cmLogger.info('PUSHNOTIFICATION PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $window.plugins.pushNotification;
                    self.registerAtService();
                })
            },

            registerAtService: function(){
                //cmLogger.info('cmPushNotificationAdapter.registerAtService')
                cmPushNotifications.registerAtService(self.plugin);
            },

            unregisterAtService: function(){
                cmPushNotifications.unregisterAtService();
            },

            getDeviceData: function(){
                return cmPushNotifications.getDeviceData();
            },

            checkRegisteredDevice: function(accountPushDevices){
//                cmLogger.info('cmPushNotificationAdapter.checkRegisteredDevice')
                // BE MOCK
                /*
                 accountPushDevices = [
                     {
                         "deviceToken": "id",
                         "language": "en-US",
                         "platform": "android"
                     }
                 ]
                 */
                // check if BE knows the registered device
//                this.getDeviceData()
//                .then(function(deviceData){
//                    var accountPushDevices = accountPushDevices || [],
//                        deviceIsRegistered = accountPushDevices.filter(function(deviceToken){
//                            return deviceToken == deviceData.token
//                        }).length == 1;
//
//                    if(!deviceIsRegistered){
//                        self.registerDevice();
//                    }
//                });
                cmPhonegap.isReady('cmPushNotificationAdapter.checkRegisteredDevice',function(){
                    if($injector.get('cmSettings').get('pushNotifications')) {
                        self.registerDevice();
                    }
                });
            },

            registerDevice: function(){
//                cmLogger.info('cmPushNotificationAdapter.registerDevice')
                // BE MOCK
                /*
                 {
                 "deviceId":"id",
                 "language":"en-US",
                 "platform":"android"
                 }
                 */
                this.getDeviceData()
                .then(function(deviceData){
                    //cmLogger.info('post pushDevice: '+ deviceData.token)
                    self.currentDeviceData = deviceData;
                    cmApi.post({
                        path: '/pushDevice',
                        data: {
                            deviceToken: deviceData.token,
                            language: cmLanguage.getCurrentLanguage().replace('_','-'),
                            platform: cmDevice.getCurrentOS()
                        }
                    }).then(
                        function(){
                            self.deviceIsRegistrated = true;
                            self.trigger('device:registrated');
                        }
                    );
                });
            },

            deleteDevice: function(token){
//                cmLogger.info('cmPushNotificationAdapter.deleteDevice')
                if(cmDevice.getCurrentOS() != 'unknown'
                && this.currentDeviceData.token) {

                    //cmLogger.info('delete pushDevice: '+ this.currentDeviceData.token)

                    var data = {
                        path: '/pushDevice/'+cmDevice.getCurrentOS()+'/'+this.currentDeviceData.token,
                    };

                    // this token for logout
                    if(token)
                        data.overrideToken = token;

                    cmApi.delete(data)
                    .then(function(){
                        self.deviceIsRegistrated = false;
                        self.trigger('device:unregistrated');
                    });
                }
            }
        };

        cmObject.addEventHandlingTo(self);

        $rootScope.$on('logout', function(event, data){
            self.deleteDevice(data.token);
        });

        return self;
    }
])
// https://github.com/phonegap-build/PushPlugin
// https://github.com/phonegap-build/PushPlugin#plugin_api


.service('cmPushNotifications', [
    'cmPhonegap', 'cmUtil', 'cmDevice', 'cmLogger', 'cmNotify',
    '$q', '$rootScope', '$phonegapCameoConfig',
    function (cmPhonegap, cmUtil, cmDevice, cmLogger, cmNotify,
              $q, $rootScope, $phonegapCameoConfig) {

        var self = {
            plugin: null,
            deviceToken: '',
            promise: undefined,
            channelName: 'cameo',

            reset: function(){
                this.deviceToken = '';
            },

            registerAtService: function(plugin){
                //cmLogger.info('cmPushNotifications.registerAtService')

                this.plugin = plugin;
                this.reset();

                // only gcm needs an senderid
                if (cmDevice.isAndroid()) {
                    this.plugin.register(
                        function() {
                            self.handler.success('registerAtService.isAndroid',arguments);
                        },
                        function() {
                            self.handler.error('registerAtService.isAndroid',arguments);
                        },
                        {
                            senderID: $phonegapCameoConfig.googleSenderId,
                            ecb: 'window.PushNotificationsCB.onNotification.Android'
                        }
                    );
                } else if(cmDevice.isiOS()){
                    this.unregisterAtService();

                    this.plugin.register(
                        function(result){
                            self.handler.success('registerAtService.isiOS',arguments);
                            self.handler.token(result);
                        },
                        function(){
                            self.handler.error('registerAtService.isiOS',arguments);
                        },
                        {
                            badge: true,
                            sound: true,
                            alert: true,
                            ecb: 'window.PushNotificationsCB.onNotification.iOS'
                        }
                    );
                } else if(cmDevice.isWinPhone()) {
                    this.plugin.register(
                        function(result) {
                            self.handler.channel(result);
                        },
                        function() {
                            self.handler.error('registerAtService.isWinPhone8',arguments);
                        },
                        {
                            channelName: this.channelName,
                            ecb: 'window.PushNotificationsCB.onNotification.WP8',
                            uccb: 'window.PushNotificationsCB.handler.channel',
                            errcb: 'window.PushNotificationsCB.handler.error'
                        }
                    );
                }
            },

            unregisterAtService: function(){
                this.plugin.unregister(
                    function(){
                        self.handler.success('unregisterAtService',arguments)
                    },
                    function(){
                        self.handler.error('unregisterAtService',arguments)
                    },
                    {
                        channelName: this.channelName
                    }
                );
            },

            setDeviceToken: function(token){
                //cmLogger.info('cmPushNotifications.setDeviceToken: '+token)
                this.deviceToken = token;

                this.initPromise();
                this.promise.resolve({token:this.deviceToken,id:0});
            },

            initPromise: function(){
                if(!this.promise)
                    this.promise = $q.defer();
            },
            getDeviceData: function(){
                this.initPromise();
                return this.promise.promise;
            },

            handler: {
                success: function(result){
                    //cmLogger.info('cmPushNotifications.handler.success: '+cmUtil.prettify(result))
                },
                token: function(token){
                    self.setDeviceToken(token);
                },
                channel: function(result){
                    //console.log('##channelHandler###############');
                    //console.log(cmUtil.prettify(result));
                },
                error: function(result) {
                    cmLogger.error('cmPushNotifications.handler.error: '+cmUtil.prettify(result))
                }
            },

            onNotification: {
                Android: function (event) {
                    switch (event.event) {
                        case 'registered':
                            if (event.regid.length > 0) {
                                self.setDeviceToken(event.regid);
                            } else {
                                cmLogger.warn('Device couldn\'t register at GCM');
                            }
                            break;
                        case 'message':
                            if(!event.foreground){
                                self.onContext(event.payload.context);
                            } else {
                                //console.log('cmBimmel!!!',event.payload.context)
                            }
                            break;

                        case 'error':
                            self.handler.error('onNotification.Android.error',event);
                        break;
                        default:
                            self.handler.error('onNotification.Android.default',event);
                        break;
                    }
                },
                iOS: function (event) {
                    if('sound' in event && event.sound != '' && event.foreground != 1) {
                        self.onContext(event.sound);
                    }

                    if (event.badge) {
                        self.plugin.setApplicationIconBadgeNumber(
                            function(result) {
                                self.handler.success('onNotification.iOS.setApplicationIconBadgeNumber',arguments);
                            },
                            function() {
                                self.handler.error('onNotification.iOS.error',arguments);
                            },
                            event.badge
                        );
                    }
                },
                WP8: function(event){
                    if (event.type == "toast" && event.jsonContent) {
                        self.plugin.showToastNotification(
                            function(){
                                self.handler.success('onNotification.WP8.showToastNotification',arguments);
                            },
                            function(){
                                self.handler.error('onNotification.WP8.error',arguments);
                            },
                            {
                                Title: event.jsonContent["wp:Text1"],
                                Subtitle: event.jsonContent["wp:Text2"],
                                NavigationUri: event.jsonContent["wp:Param"]
                            });
                    }

                    if (event.type == "raw" && event.jsonContent) {
                        self.onContext(event.jsonContent.Body);
                    }
                }
            },

            onContext: function(data){
                cmLogger.error('cmPushNotifications.onContext: '+data);
                var context = data.split(':');
                switch(context[0]){
                    case 'message':
                        $rootScope.goTo('conversation/'+context[1], true);
                    break;
                    case 'friendRequest':
                        $rootScope.goTo('contact/request/list', true);
                    break;
                }
            }
        };
        // for callback
        window.PushNotificationsCB = self;

        return self;
    }
])
// https://github.com/apache/cordova-plugin-camera/blob/b76b5ae670bdff4dd4c716e889ab12e049f9c733/doc/index.md
// https://github.com/apache/cordova-plugin-device/blob/d7b0855ef8eaa6731485a8e529b3607a3c65e7f2/doc/index.md

/*
 Camera = {
 "DestinationType":{
     "DATA_URL":0, //base64
     "FILE_URI":1,
     "NATIVE_URI":2
 },
 "EncodingType":{
     "JPEG":0,
     "PNG":1
 },
 "MediaType":{
     "PICTURE":0,
     "VIDEO":1,
     "ALLMEDIA":2
 },
 "PictureSourceType":{
     "PHOTOLIBRARY":0,
     "CAMERA":1,
     "SAVEDPHOTOALBUM":2
 },
 "PopoverArrowDirection":{
     "ARROW_UP":1,
     "ARROW_DOWN":2,
     "ARROW_LEFT":4,
     "ARROW_RIGHT":8,
     "ARROW_ANY":15
 },
 "Direction":{
     "BACK":0,
     "FRONT":1
 }
 }*/


.service('cmCamera', [
    'cmPhonegap', 'cmFilesAdapter', 'cmFileTypes',
    '$navigator', '$window',
    function (cmPhonegap, cmFilesAdapter, cmFileTypes,
              $navigator, $window) {

        function FileError(e){
            var msg;
            switch (e.code) {
                case FileError.ABORT_ERR:
                    msg = 'ABORT_ERR';
                    break;
                case FileError.NOT_READABLE_ERR:
                    msg = 'NOT_READABLE_ERR';
                    break;
                case FileError.ENCODING_ERR:
                    msg = 'ENCODING_ERR';
                    break;
                case FileError.NO_MODIFICATION_ALLOWED_ERR:
                    msg = 'NO_MODIFICATION_ALLOWED_ERR';
                    break;
                case FileError.SYNTAX_ERR:
                    msg = 'SYNTAX_ERR';
                    break;
                case FileError.TYPE_MISMATCH_ERR:
                    msg = 'TYPE_MISMATCH_ERR';
                    break;
                case FileError.PATH_EXISTS_ERR:
                    msg = 'PATH_EXISTS_ERR';
                    break;
                case FileError.QUOTA_EXCEEDED_ERR:
                    msg = 'QUOTA_EXCEEDED_ERR';
                    break;
                case FileError.NOT_FOUND_ERR:
                    msg = 'NOT_FOUND_ERR';
                    break;
                case FileError.SECURITY_ERR:
                    msg = 'SECURITY_ERR';
                    break;
                case FileError.INVALID_MODIFICATION_ERR:
                    msg = 'INVALID_MODIFICATION_ERR';
                    break;
                case FileError.INVALID_STATE_ERR:
                    msg = 'INVALID_STATE_ERR';
                    break;
                default:
                    msg = 'Unknown Error';
                    break;
            };
            console.log('errror readEntries '+msg)
        }

        var CameraVars = {
            "DestinationType":{
                "DATA_URL":0, //base64
                "FILE_URI":1,
                "NATIVE_URI":2
            },
            "EncodingType":{
                "JPEG":0,
                "PNG":1
            },
            "MediaType":{
                "PICTURE":0,
                "VIDEO":1,
                "ALLMEDIA":2
            },
            "PictureSourceType":{
                "PHOTOLIBRARY":0,
                "CAMERA":1,
                "SAVEDPHOTOALBUM":2
            },
            "PopoverArrowDirection":{
                "ARROW_UP":1,
                "ARROW_DOWN":2,
                "ARROW_LEFT":4,
                "ARROW_RIGHT":8,
                "ARROW_ANY":15
            },
            "Direction":{
                "BACK":0,
                "FRONT":1
            }
        };

        var self = {
            plugin: null,

            init: function () {
                cmPhonegap.isReady('cmCamera',function () {
                    if($navigator == 'undefined'
                    || !('camera' in $navigator)) {
                        //cmLogger.info('CAMERA PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $navigator.camera;
                });

                return true;
            },

            existsPlugin: function () {
                return this.plugin != null;
            },

            getDateForName: function(){
                var date = new Date();
                return date.getFullYear()+''+(date.getMonth()+1)+''+date.getDate();
            },

            takePhoto: function (callback, useFrontCamera) {
                if (!this.existsPlugin()) {
                    return false;
                }

                if (callback == undefined)
                    callback = function () {
                    };

                this.plugin.getPicture(
                    function (base64) {
                        var blob = cmFilesAdapter.base64ToBlob(base64, 'image/jpeg');

                        blob.name = 'cmPicture_'+self.getDateForName()+'.jpg';
                        callback(blob);
                    },
                    null,
                    {
                        sourceType: CameraVars.PictureSourceType.CAMERA,
                        quality: 60,
                        encodingType: CameraVars.EncodingType.JPEG,
                        destinationType: CameraVars.DestinationType.DATA_URL,
                        mediaType: CameraVars.MediaType.PICTURE,
                        cameraDirection: CameraVars.Direction[useFrontCamera ? 'FRONT' : 'BACK'],
                        saveToPhotoAlbum: true,
                        correctOrientation: true
                    }
                );

                return true;
            },
            chooseFile: function (callback) {
                if (!this.existsPlugin()) {
                    return false;
                }

                if (callback == undefined)
                    callback = function () {
                    };

                this.plugin.getPicture(
                    function (fileUri) {
                        if (!('resolveLocalFileSystemURL' in $window))
                            return false;

                        // uri to blob
                        $window.resolveLocalFileSystemURL(fileUri, function (fileEntry) {
                            // TODO: get displayname (filename) of file (exp.: data.extension)
//                            console.log('resolveLocalFileSystemURL')
//                            console.log(fileEntry.fullPath)
//                            fileEntry.getParent(function(parent){
//                                console.log('getparent biatsch '+parent.name)
//                                var reader = parent.createReader();
//                                reader.readEntries(function(entries){
//                                    console.log('readEntries of '+entries.length)
//                                    console.log(cmUtil.prettify(arguments))
//                                }, FileError);
//                            }, FileError)

                            fileEntry.file(function (blob) {

                                if(blob.name == 'content') {
                                    var extension = cmFileTypes.find(blob.type);
                                    blob.name = 'cmFile_' + self.getDateForName() + '.'+extension;
                                }

                                callback(blob);
                            }, FileError);
                        });
                    },
                    null,
                    {
                        sourceType: CameraVars.PictureSourceType.PHOTOLIBRARY,
                        destinationType: CameraVars.DestinationType.FILE_URI,
                        mediaType: CameraVars.MediaType.ALLMEDIA
                    }
                );

                return true;
            }
        };

        self.init();

    return self;
    }
])
// https://github.com/VersoSolutions/CordovaClipboard


    .service('cmClipboard', [
        'cmPhonegap',
        '$cordova',
        function (cmPhonegap,
                  $cordova) {
            var self = {
                plugin: null,
                available: false,

                init: function(){
                    cmPhonegap.isReady('cmClipboard',function(){
                        if(!('plugins' in $cordova)
                            || !('clipboard' in $cordova.plugins)) {
                            //cmLogger.info('NETWORK-INFORMATION PLUGIN IS MISSING');
                            return false;
                        }

                        self.available = true;
                        self.plugin = $cordova.plugins.clipboard;
                    })
                },

                copy: function(text){
                    if(!this.available)
                        return false;

                    this.plugin.copy(
                        text,
                        function(){
                            // onSuccess
                        },
                        function(){
                            // onError
                        }
                    );
                },

                paste: function(){
                    if(!this.available)
                        return false;

                    this.plugin.paste(
                        function(){
                            // onSuccess
                        },
                        function(){
                            // onError
                        }
                    );
                }
            };

            return self;
        }
    ])
// https://github.com/memoConnect/de.cameonet.cordova.crypto


.service('cmCryptoHelper', [
    'cmPhonegap', 'cmDevice', 'cmLogger', 'cmUtil',
    '$window', '$q',
    function (cmPhonegap, cmDevice, cmLogger, cmUtil,
              $window, $q) {

        var self = {
            plugin: null,
            keySize: 2048,

            init: function(){
                cmPhonegap.isReady('cmCryptoHelper',function(){

                    if(!('cmCryptoHelper' in $window)){
                        //cmLogger.info('CRYPTOHELPER PLUGIN IS MISSING');
                        return false;
                    }

                    // only for ios
                    if(!cmDevice.isiOS()){
                        return false;
                    }

                    self.plugin = $window.cmCryptoHelper;
                });
            },

            isAvailable: function(){
                return this.plugin != null;
            },

            getPrivateKey: function(length){
                var deferred = $q.defer();

                if(this.isAvailable()){
                    this.plugin.getPrivateKey(function (privKey) {
                            deferred.resolve(privKey);
                        }, function () {
                            deferred.reject();
                        },
                            length | self.keySize
                    );
                } else {
                    deferred.reject('NO PLUGIN EXISTS');
                }

                return deferred.promise;
            },

            rsaEncrypt: function(publicKey, plainText){
                var deferred = $q.defer();

                if(this.isAvailable()){
                    this.plugin.encrypt(
                        function (result) {
                            deferred.resolve(result);
                        }, 
                        function (reason) {
                            deferred.reject(reason);
                        },
                        publicKey, 
                        plainText
                    )
                } else {
                    deferred.reject('NO PLUGIN EXISTS');
                }

                return deferred.promise;
            },

            rsaDecrypt: function(privateKey, encryptedText){
                var deferred = $q.defer();

                if(this.isAvailable()){
                    this.plugin.decrypt(
                        function (result) {
                            deferred.resolve(result);
                        }, 
                        function (reason) {
                            deferred.reject(reason);
                        },
                        privateKey, 
                        encryptedText
                    )
                } else {
                    deferred.reject('NO PLUGIN EXISTS');
                }

                return deferred.promise;
            },

            rsaSign: function(privateKey, text){
                var deferred = $q.defer();

                if(this.isAvailable()){
                    this.plugin.sign(
                        function (result) {
                            deferred.resolve(result);
                        }, 
                        function (reason) {
                            deferred.reject(reason);
                        },
                        privateKey, 
                        text
                    )
                } else {
                    deferred.reject('NO PLUGIN EXISTS');
                }

                return deferred.promise;
            },

            rsaVerify: function(publicKey, text, signature){
                var deferred = $q.defer();

                if(this.isAvailable()){
                    this.plugin.verify(
                        function (result) {
                            result == 'true'
                            ?   deferred.resolve(result)
                            :   deferred.reject(result)
                        }, 
                        function (reason) {
                            deferred.reject(reason);
                        },
                        publicKey, 
                        text,
                        signature
                    )
                } else {
                    deferred.reject('NO PLUGIN EXISTS');
                }

                return deferred.promise;
            }

        };

        self.init();

        return self;
    }
])
.service('cmDeviceDownload', [
    'cmPhonegap', 'cmDevice', 'cmUtil',
    function (cmPhonegap, cmDevice, cmUtil) {

        function errorHandler(){
            var msg = '';

            switch (e.code) {
                case FileError.QUOTA_EXCEEDED_ERR:
                    msg = 'QUOTA_EXCEEDED_ERR';
                    break;
                case FileError.NOT_FOUND_ERR:
                    msg = 'NOT_FOUND_ERR';
                    break;
                case FileError.SECURITY_ERR:
                    msg = 'SECURITY_ERR';
                    break;
                case FileError.INVALID_MODIFICATION_ERR:
                    msg = 'INVALID_MODIFICATION_ERR';
                    break;
                case FileError.INVALID_STATE_ERR:
                    msg = 'INVALID_STATE_ERR';
                    break;
                default:
                    msg = 'Unknown Error';
                    break;
            };

            console.log('cmDeviceDownload Error: ' + msg);
        }

        return {
            isSupported: function(){
                return false && cmDevice.isAndroid();
            },
            saveAs: function(cmFileModel){



                /*
                 LocalFileSystem.PERSISTENT
                 window.TEMPORARY
                */

                window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;

                window.requestFileSystem(
                LocalFileSystem.PERSISTENT,
                5*1024*1024 /*5MB*/,
                function(fileSystem){
                    console.log('Opened file system: ' + fileSystem.name);

                    var directoryEntry = fileSystem.root,
                        directoryReader = directoryEntry.createReader();

                    directoryReader.readEntries(function(entries){
                        var sOutput = "";
                        for(var i=0; i < entries.length; i++){
                            if(!entries[i].isDirectory){
                                console.log(entries[i].name)
                                //fileSystem.root.getFile(entries[i].name,null,gotFileEntry,errorHandler);
                            }
                        }
                        //displayMessage(sOutput);
                    },errorHandler);

//                    directoryEntry.getFile('file:///example.txt', {create: true, exclusive: true}, function(fileEntry) {
//
//                        // fileEntry.isFile === true
//                        // fileEntry.name == 'log.txt'
//                        // fileEntry.fullPath == '/log.txt'
//                        console.log('file fullpath: '+fileEntry.fullPath)
//                    }, errorHandler);

                },
                errorHandler);

                function gotFileEntry(fileEntry){
                    fileEntry.file(function(file){
                        var reader = new FileReader();
                        reader.onloadend = function(evt){
                            displayMessage(evt.target.result);
                        };
                        reader.readAsText(file);
                    },errorHandler);
                }
            }
        }
    }
])
// https://github.com/apache/cordova-plugin-device/blob/master/doc/index.md


.service('cmDevice',[
    'cmPhonegap', 'cmLogger', 'cmUtil',
    '$window', '$device', '$phonegapCameoConfig',
    function (cmPhonegap, cmLogger, cmUtil,
              $window, $device, $phonegapCameoConfig) {

        var unknown = 'unknown';

        var self = {
            plugin: null,
            emulateDevice: false,
            emulateDeviceType: 'android', // android | ios | winphone
            flags: {},

            init: function(){
                cmPhonegap.isReady('cmDevice',function(){
                    if($device.get() == 'undefined'){
                        //cmLogger.info('DEVICE PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $device.get();
                });
            },

            existsPlugin: function(){
                return this.plugin != null;
            },

            getUserAgent: function(){
                var nAgt = '';

                // TODO: iOS8 Bug: Deprecated attempt to access property 'userAgent' on a non-Navigator object.
// http://stackoverflow.com/questions/24784541/cordova-2-9-x-ios-8-useragent-bug
// https://github.com/apache/cordova-js/blob/26e3e49e49b2fb61ca836572af85c7a776ea9f1c/src/common/init.js#L46-L65

                nAgt = ($window.navigator.userAgent || $window.navigator.vendor || $window.opera).toLowerCase();

                return nAgt;
            },

            setFlag: function(name, boolean){
                if(typeof name == 'string' && typeof boolean == 'boolean')
                    this.flags[name] = boolean;
            },

            getPlatform: function(){
                return this.isApp()
                && 'platform' in this.plugin
                    ? this.plugin.platform.toLowerCase()
                    : unknown;
            },

            isApp: function(withoutPlugin){
                if(this.emulateDevice) {
                    cmLogger.warn('cmPhonegap.cmDevice.debug == true!!!');
                    this.plugin = {};
                }

                return this.emulateDevice || !this.emulateDevice && !withoutPlugin && this.existsPlugin() || !this.emulateDevice && withoutPlugin && $phonegapCameoConfig != 'undefined';
            },

            isDesktop: function(whoIs){
                // emulate device
                if(this.emulateDevice)
                    return false;

                // setted by backend
                if('isDesktop' in this.flags)
                    return this.flags.isDesktop;

                // self detection
                var userAgent = this.getUserAgent(),
                    checkOne = userAgent.match(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/g),
                    checkTwo = userAgent.substr(0,4).match(/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/g);

                if(checkOne != null || checkTwo != null)
                    return false;
                return true;
            },

            isMobile: function(where){
                return !this.isDesktop(where+' isMobile');
            },

            is: function(deviceType){
                var acceptedTypes = {
                    'android': 'isAndroid',
                    'ios': 'isiOS',
                    'winphone': 'isWinPhone'
                };
                if(Object.keys(acceptedTypes).indexOf(deviceType) >= 0
                && acceptedTypes[deviceType] in self){
                    if(self[acceptedTypes[deviceType]]()){
                        return true;
                    }
                }
                return false;
            },

            isAndroid: function(){
                if(this.emulateDevice && this.emulateDeviceType.indexOf('android') >= 0){
                    return true;
                }
                return (this.isApp()
                    && this.getPlatform().indexOf('android') >= 0 )
                    || this.getUserAgent().indexOf('android') >= 0;
            },
            isiOS: function(){
                if(this.emulateDevice && this.emulateDeviceType.indexOf('ios') >= 0){
                    return true;
                }
                return (this.isApp()
                   && this.getPlatform().match(/ip(ad|hone|od)/g) )
                   || this.getUserAgent().match(/ip(ad|hone|od)/g);
            },
            isWinPhone: function(){
                if(this.emulateDevice && this.emulateDeviceType.indexOf('winphone') >= 0){
                    return true;
                }
                return (this.isApp()
                    && this.getPlatform().indexOf('iemobile') >= 0)
                    || this.getUserAgent().indexOf('iemobile') >= 0;
            },

            isIE: function(_version_){
                var msie = 'msie '
                //var version = parseInt(this.getUserAgent().substring(msieIndex + 5, this.getUserAgent().indexOf(".", msieIndex)));

                return (
                    this.isApp() && this.getPlatform().indexOf(msie) >= 0
                 || this.isApp() && !!this.getPlatform().match(/trident.*rv\:11\./)
                 || this.getUserAgent().indexOf(msie) >= 0
                 || !!this.getUserAgent().match(/trident.*rv\:11\./)
                );
            },
            isBlackBerry: function(){
                return this.isApp()
                    && this.getPlatform().indexOf('blackberry') >= 0;
            },
            isAmazonFireOS: function(){
                return this.isApp()
                    && this.getPlatform().indexOf('amazon-fireos') >= 0;
            },


            getCurrentOS: function(){
                var os = 'unknown';

                if(!this.isApp())
                    return os;

                if (this.isAndroid()) {
                    os = 'and';
                } else if (this.isWinPhone()) {
                    os = 'win';
                } else if (this.isiOS()) {
                    os = 'ios';
                } else if (this.isBlackBerry()){
                    os = 'bby';
                }

                return os;
            },

            getId: function(){
                if(!this.isApp())
                    return unknown;

                return this.plugin.uuid;
            },

            getName: function(){
                if(!this.isApp())
                    return unknown;

                return this.plugin.name;
            },

            getVersion: function(){
                if(!this.isApp())
                    return unknown;

                return this.plugin.version;
            },

            detectOSAndBrowser: function() {
                var nAgt = this.getUserAgent(),
                    OSName = 'unknown OS',
                    browserName = 'unknown Browser',
                    nameOffset,
                    verOffset;

                function has(needle){
                    return nAgt.indexOf(needle) != -1
                }

                var detecable = {
                    os: {
                        win: 'Windows',
                        sym: 'Symbian',
                        ios: 'iOS',
                        mac: 'Mac OS X',
                        and: 'Android',
                        uni: 'Unix',
                        lin: 'Linux'
                    },
                    browser: {
                        opr: 'Opera',
                        iex: 'Internet Explorer',
                        iem: 'IEMobile',
                        nab: 'Native Browser',
                        chr: 'Google Chrome',
                        saf: 'Safari',
                        mff: 'Mozilla Firefox',
                        app: 'App'
                    }
                };

                // os detection
                if (has('win'))
                    OSName = detecable.os.win;
                else if(has('symbianos'))
                    OSName = detecable.os.sym;
                else if(has('like mac os x'))
                    OSName = detecable.os.ios;
                else if(has('mac'))
                    OSName = detecable.os.mac;
                else if(has('android'))
                    OSName = detecable.os.and;
                else if(has('x11'))
                    OSName = detecable.os.uni;
                else if(has('linux'))
                    OSName = detecable.os.lin;

                // browser detection
                if ((verOffset = has('opera')) || (verOffset = has('opr')))
                    browserName = detecable.browser.opr;
                else if ((verOffset = has('iemobile')))
                    browserName = detecable.browser.iem;
                else if ((verOffset = has('msie')) || (verOffset = has('rv:11.0')))
                    browserName = detecable.browser.iex;
                else if ((verOffset = has('linux; u; android')))
                    browserName = detecable.browser.nab;
                else if ((verOffset = has('chrome')))
                    browserName = detecable.browser.chr;
                else if ((verOffset = has('safari')))
                    browserName = detecable.browser.saf;
                else if ((verOffset = has('firefox')))
                    browserName = detecable.browser.mff;
                // In most other browsers, 'name/version' is at the end of userAgent
                else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
                    browserName = nAgt.substring(nameOffset, verOffset);
                    if (browserName.toLowerCase() == browserName.toUpperCase()) {
                        browserName = 'unknown Browser';
                    }
                }

                // app check overrides all
                if(this.isApp())
                    browserName = detecable.browser.app;

                return {
                    givenBrowserUserAgent: nAgt,
                    os: OSName,
                    browser: browserName
                };
            }
        };

        self.init();

        return self;
    }
])
// https://github.com/driftyco/ionic-plugins-keyboard


.service('cmKeyboard', [
    'cmPhonegap', 'cmObject',
    '$cordova', '$window', '$rootScope', '$timeout',
    function (cmPhonegap, cmObject,
              $cordova, $window, $rootScope, $timeout){

        var self = {
            plugin: null,

            init: function(){
                cmObject.addEventHandlingTo(self);

                $rootScope.$on('cmEnter:pressed', self.forceClose);
                $rootScope.$on('$locationChangeStart', function(){
                    self.forceClose();
                    $rootScope.lastFocus = undefined;
                });

                cmPhonegap.isReady('cmKeyboard',function(){
                    if(!('plugins' in $cordova) || !('Keyboard' in $cordova.plugins)) {
                        //cmLogger.info('KEYBOARD PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $cordova.plugins.Keyboard;

                    // event handling
                    angular.element($window)
                    .on('native.keyboardhide',function(){
                        self.trigger('hidden');
                    })
                    .on('native.keyboardshow',function(){
                        self.trigger('visible');
                    });
                });
            },
            existsPlugin: function(){
                return self.plugin != null;
            },
            isVisible: function(){
                if(self.plugin != null) {
                    return self.plugin.isVisible;
                }
                return false;
            },
            scroll: function(bool){
                if(self.plugin != null) {
                    self.plugin.disableScroll(bool || true);
                    return true;
                }
                return false;
            },
            close: function(){
                if(self.plugin != null) {
                    self.plugin.close();
                    return true;
                }
                return false;
            },
            forceClose: function(){
                self.close();
            },
            show: function(){
                if(self.plugin != null) {
                    self.plugin.show();
                    return true;
                }
                return false;
            },
            focusLast: function(event){
                if($rootScope.lastFocus) {

                    if(event && 'stopPropagation' in event) {
                        event.stopPropagation();
                        event.preventDefault();
                    }

                    //$timeout(function(){
                        self.show();
                        $rootScope.lastFocus.focus();
                    //}, 50);
                    return true;
                }
                return false;
            }
        };

        self.init();

        return self;
    }
])
// https://github.com/EddyVerbruggen/LaunchMyApp-PhoneGap-Plugin/


.service('cmLauncher', [
    '$rootScope', '$window',
    function ($rootScope, $window) {

        var self = {
            params: {},

            parse: function(url){
                var protocolRegexp = '.*://',
                    queryRegexp = '([^?=&]+)(=([^&]*))?';

                url
                    .replace(new RegExp( protocolRegexp, 'g' ),'')
                    .replace(new RegExp( queryRegexp, 'g' ),function( $0, $1, $2, $3 ){
                        self.params[ $1 ] = $3;
                    });

                this.doLaunch();
            },

            doLaunch: function(){
                console.log('doLaunch',self.params)
                // on launch with params
                if(Object.keys(self.params).length > 0) {
                    switch (true) {
                        case ('purlId' in self.params):
                            $rootScope.goTo('purl/'+self.params.purlId, true);
                        break;
                    }
                }
            }
        };

        // do it global
        $window.handleOpenURL = function(url) {
            self.parse(url);
        };

        return self;
    }
])
// https://github.com/wildabeast/cordova-plugin-contacts/blob/b8f6ce5bd04298f7fd4cba7c136389cf66eddc6b/doc/index.md

/*  android & ios contact json
 {
    displayName: "GiverName FamilyName",
    name: {
        familyName: "FamilyName",
        formatted: "GiverName FamilyName",
        givenName: "GiverName",
        middleName: "MiddleName",
    },
    phoneNumbers: [
     {
        id: "1234",
        pref: false,
        type: "mobile", // mobile | work | fax
        value: "+49 123 4567890",
     }
    ],
    emails: [
     {
         id: "1246",
         pref: false,
         type: "work", // other
         value: "some.coworker@cameo.io",
     }
    ]
 }
 */

.service('cmLocalContacts', [
    'cmPhonegap', 'cmUtil', 'cmLogger', 'cmDevice',
    '$q', '$navigator',
    function (cmPhonegap, cmUtil, cmLogger, cmDevice,
              $q, $navigator) {

        var self = {
            plugin: null,

            init: function () {
                cmPhonegap.isReady('cmLocalContacts',function(){
                    if(!('contacts' in $navigator)) {
                        //cmLogger.info('CONTACTS PLUGIN IS MISSING');
                        return false;
                    }
                    self.plugin = $navigator.contacts;
                });
            },

            canRead: function() {
                if(cmDevice.emulateDevice)
                    cmLogger.warn('cmPhonegap.cmLocalContacts.debug == true!!!');
                return cmDevice.emulateDevice || !cmDevice.emulateDevice && this.plugin != null;
            },

            selectOne: function() {
                var loaded = $q.defer();

                if(cmDevice.emulateDevice){
                    loaded.resolve({
                        displayName: "GiverName FamilyName",
                        name: {
                            familyName: "FamilyName",
                            formatted: "GiverName FamilyName",
                            givenName: "GiverName",
                            middleName: "MiddleName"
                        },
                        phoneNumbers: [
                            {
                                id: "1234",
                                pref: false,
                                type: "mobile", // mobile | work | fax
                                value: "+49 123 4567890"
                            },
                            {
                                id: "2343",
                                pref: false,
                                type: "work", // mobile | work | fax
                                value: "+49 123 "
                            },
                            {
                                id: "2343",
                                pref: false,
                                type: "work", // mobile | work | fax
                                value: "+49523123123 "
                            },
                            {
                                id: "2343",
                                pref: false,
                                type: "work", // mobile | work | fax
                                value: "+49 (30) 23434234"
                            }
                        ],
                        emails: [
                            {
                                id: "1246",
                                pref: false,
                                type: "work", // other
                                value: "some.coworker@cameo.io"
                            },
                            {
                                id: "3534",
                                pref: false,
                                type: "other", // other
                                value: "other.coworker@cameo.io"
                            }
                        ]
                    });// return mock use above
                    return loaded.promise;
                }

                if(this.canRead()){
                    this.plugin.pickContact(
                        function (contact) {
                            loaded.resolve(contact);
                        },
                        function onError(contactError) {
                            loaded.reject(contactError);
                        }
                    );
                }

                return loaded.promise;
            }
        };

        self.init();

        return self;
    }
])

    .service('cmMigrate', [
        'cmPhonegap',
        '$phonegapCameoConfig', '$window', '$q', 'cmLogger',
        function (cmPhonegap,
                  $phonegapCameoConfig, $window, $q, cmLogger){

            var self = {

                plugin: null,

                init: function(){

                    cmPhonegap.isReady('cmMigrate',function(){
                        if(!('cmMigrate' in $window)) {
                            //cmLogger.info('MIGRATION PLUGIN IS MISSING');
                            return false;
                        }
                        self.plugin = $window.cmMigrate;
                    });
                },

                isAvailable: function(){
                    return this.plugin != null;
                },

                migrateLocalStorage: function() {

                    cmLogger.debug('Starting local storage migration');

                    var deferred = $q.defer();

                    if(this.isAvailable()){
                        cmLogger.info('Calling migration plugin...');
                        this.plugin.getOldLocalStorage(
                            function (values) {
                                try {
                                    var jsonObj = JSON.parse(values)
                                    deferred.resolve(jsonObj)
                                } catch (e) {
                                    deferred.reject(e)
                                }

                            }, function (reason) {
                                deferred.reject(reason);
                            },
                            $phonegapCameoConfig.isCrosswalk
                        );
                    } else {
                        deferred.reject('MIGRATION PLUGIN IS MISSING');
                    }

                    return deferred.promise;
                },
                migrationComplete: function() {
                    this.plugin.migrationComplete()
                }
            };

            self.init();

            return self;
        }
    ])
// https://github.com/apache/cordova-plugin-network-information/blob/cd67d7a30f51efe7b2e3adb098ae65409d292d21/doc/index.md


.service('cmNetworkInformation', [
    'cmPhonegap', 'cmUtil', 'cmLogger', 'cmApi',
    '$navigator', '$document', '$window', '$rootScope',
    function (cmPhonegap, cmUtil, cmLogger, cmApi,
              $navigator, $document, $window, $rootScope) {
        var self = {
            plugin: null,
            state: '',

            init: function(){
                cmPhonegap.isReady('cmNetworkInformation',function(){
                    if(!('connection' in $navigator) || !('type' in $navigator.connection) || !Connection) {
                        //cmLogger.info('NETWORKINFORMATION PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $navigator.connection;

                    $document.on('online', function(){
                        self.checkConnection();
                        self.goesOnline();
                    });

                    $document.on('offline', function(){
                        self.checkConnection();
                        self.goesOffline();
                    });

                    self.checkConnection();
                })
            },

            checkConnection: function(){
                var networkState = this.plugin.type;

                var states = {};
                states[Connection.UNKNOWN] = 'Unknown connection';
                states[Connection.ETHERNET] = 'Ethernet connection';
                states[Connection.WIFI] = 'WiFi connection';
                states[Connection.CELL_2G] = 'Cell 2G connection';
                states[Connection.CELL_3G] = 'Cell 3G connection';
                states[Connection.CELL_4G] = 'Cell 4G connection';
                states[Connection.CELL] = 'Cell generic connection';
                states[Connection.NONE] = 'No network connection';

//                console.log('Connection type: ' + states[networkState]);
                this.state = states[networkState];
            },
            goesOffline: function(){
                $rootScope.$emit('cmApi:sleep');
            },
            goesOnline: function(){
                $rootScope.$emit('cmApi:wakeup');
            }
        };
        
        // html5 events
        if('onLine' in $navigator && $navigator.onLine) {
            // is already offline
            if(!$navigator.onLine){
                //api.state.unset('event_call_running');
                self.goesOffline();
            }
            // handle event states
            angular.element($window)
            .on('online', function () {
                self.goesOnline();
            })
            .on('offline', function () {
                self.goesOffline();
            });
        }

        return self;
    }
])

.service('cmPhonegap', [
    'cmLogger', 'cmHistory', 'cmModal',
    '$q', '$document', '$phonegapCameoConfig',
    '$navigator', '$rootScope',
    function (cmLogger, cmHistory, cmModal,
              $q, $document, $phonegapCameoConfig,
              $navigator, $rootScope) {

        var isReady = $q.defer();

        var self = {
            init: function(){
                if($phonegapCameoConfig == 'undefined'){
                    return false;
                }

                $document.on('deviceready', function () {
                    $phonegapCameoConfig.deviceReady = true;
                    isReady.resolve();
                });
            },
            isReady: function(whoIs, callback){
                if($phonegapCameoConfig == 'undefined'){
                    return false;
                }

                //cmLogger.info(whoIs+' called cmPhonegap.isReady? '+$phonegapCameoConfig.deviceReady)

                // if config doesn't get device ready watch again
                if(!$phonegapCameoConfig.deviceReady){
                    isReady.promise.then(function(){
                        if(typeof callback == 'function') {
                            //console.log('calling callback of '+whoIs)
                            callback();
                        }
                    });
                // nothing to wait phonegap is ready
                } else {
                    if(typeof callback == 'function')
                        callback();
                }

                return false;
            },
            initDeviceButtons: function(){
                if($document.length > 0 && 'addEventListener' in $document[0]) {
                    // handle history back and exit app
                    $document.on('backbutton', function () {
                        if (cmHistory.isEmpty()) {
                            cmModal.confirm({
                                title: 'MODAL.EXIT.HEADER',
                                text: 'MODAL.EXIT.TEXT'
                            })
                            .then(function() {
                                if('app' in $navigator && 'exitApp' in $navigator.app){
                                    $navigator.app.exitApp();
                                }
                            });
                        } else {
                            $rootScope.goBack();
                        }
                        $rootScope.$apply();
                    });
                    // handle menu
                    $document.on('menubutton', function (e) {
                        $rootScope.$broadcast('cmMenu:toggle');
                        $rootScope.$apply();
                    });
                }
            },
            initDevicesEvents: function(){
                if($document.length > 0 && 'addEventListener' in $document[0]) {
                    // detect when app goes in background
                    $document.on('pause', function () {
                        $rootScope.$emit('cmApi:sleep');
                    });
                    // detect when app goes in foreground
                    $document.on('resume', function () {
                        $rootScope.$emit('cmApi:wakeup');
                    });
                }
            }
        };

        self.init();

        // buttons on device
        self.isReady('cmPhonegap.button init',function(){
            self.initDeviceButtons();
            self.initDevicesEvents();
        });

        return self;
    }]
)
// http://www.w3.org/TR/screen-orientation/
// https://github.com/yoik/cordova-yoik-screenorientation


    .service('cmScreenOrientation', [
        'cmPhonegap',
        '$screen',
        function (cmPhonegap,
                  $screen){

            var self = {
                plugin: null,
                defaultOrientation: 4,//portrait
                orientations: [
                    'portrait-primary',
                    'portrait-secondary',
                    'landscape-primary',
                    'landscape-secondary',
                    'portrait',
                    'landscape'
                ],

                init: function(){
                    cmPhonegap.isReady('cmScreenOrientation',function(){
                        if(!('unlockOrientation' in $screen)) {
                            //cmLogger.info('SCREENORIENTATION PLUGIN IS MISSING');
                            return false;
                        }

                        self.plugin = $screen;

                        self.setPortrait();
                    });
                },
                getCurrent: function(){
                    if(self.plugin != null)
                        return self.plugin.orientation;
                    return self.orientations[4];
                },
                setPortrait: function(){
                    self.lockTo(self.orientations[4]);
                },
                setLandscape: function(){
                    self.lockTo(self.orientations[5]);
                },
                lockTo: function(orientation){
                    if(self.plugin != null && self.orientations.indexOf(orientation))
                        self.plugin.lockOrientation(orientation);
                },
                lock: function(){
                    if(self.plugin != null && self.orientations.indexOf(orientation))
                        self.plugin.lockOrientation(self.orientations[self.defaultOrientation]);
                },
                unlock: function(){
                    if(self.plugin != null)
                        self.plugin.unlockOrientation();
                }
            };

            self.init();

            return self;
        }
    ])
// https://github.com/apache/cordova-plugin-splashscreen/blob/b46cdca795173d67337c97731b343922d24fc770/doc/index.md


.service('cmSplashScreen', [
    'cmPhonegap',
    '$navigator', '$timeout',
    function (cmPhonegap,
              $navigator, $timeout){

        var self = {
            plugin: null,

            init: function(){
                cmPhonegap.isReady('cmSplashScreen',function(){
                    if(!('splashscreen' in $navigator)) {
                        //cmLogger.info('SPLASHCREEN PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $navigator.splashscreen;

                    self.hide();
                })
            },
            hide: function(){
                if(self.plugin != null) {
                    $timeout(function(){
                        self.plugin.hide();
                    },100);
                }
            },
            show: function(){
                if(self.plugin != null)
                    self.plugin.show();
            }
        };

        self.init();

        return self;
    }
])
// https://github.com/EddyVerbruggen/SSLCertificateChecker-PhoneGap-Plugin/tree/21a98bf


.service('cmSslCertificateChecker', [
    'cmPhonegap', 'cmConfig', 'cmLogger', 'cmUtil',
    '$rootScope', '$window', '$document',
    function (cmPhonegap, cmConfig, cmLogger, cmUtil,
              $rootScope, $window, $document) {

        var self = {
            plugin: null,
            isSecure: false,
            data: {},

            init: function(){
                cmPhonegap.isReady('cmSslCertificateChecker',function(){
                    if(!('plugins' in $window)
                        || !('sslCertificateChecker' in $window.plugins)) {
                        //cmLogger.info('SSL_CERTIFICATE PLUGIN IS MISSING');
                        return false;
                    }

                    self.plugin = $window.plugins.sslCertificateChecker;

                    $document.on('online', function(){
                        self.control();
                    });

                    self.control();
                })
            },

            control: function(){
                var target = 'prod',
                //    target = (function(){
                //    if(cmConfig.target != 'prod')
                //        return 'stage';
                //    return cmConfig.target;
                //})(),
                    certificate = ('certificates' in cmConfig.static && target in cmConfig.static.certificates)
                                   ? cmConfig.static.certificates[target]
                                   : null,
                    server = certificate != null ? certificate.server : '',
                    fingerprint = certificate != null ? certificate.fingerprint : '';

                this.data = {
                    target: cmConfig.target+'/'+target,
                    server: server,
                    fingerprint: fingerprint
                };

                //cmLogger.info('cmSslCertificateChecker '+cmConfig.target+'/'+target+' '+server+' '+fingerprint);

                if(server != '' && fingerprint != '') {
                    self.plugin.check(
                        self.handler.success,
                        self.handler.error,
                        server,
                        fingerprint
                    );
                } else {
                    this.handler.error('NO_CREDENTIALS');
                }
            },

            handler: {
                success: function(){
                    cmLogger.info('cmSslCertificateChecker secure '+cmUtil.prettify(self.data));
                    self.isSecure = true;
                },
                error: function(message){
                    cmLogger.error('cmSslCertificateChecker insecure '+message,cmUtil.prettify(self.data));

                    switch(true){
                        case message == 'CONNECTION_NOT_SECURE':
                        case message == 'NO_CREDENTIALS':
                            $rootScope.$broadcast('cmConnectionHandler:notSecure',function(){
                                self.control();
                            });
                        break;
                        case message.indexOf('CONNECTION_FAILED') >= 0:
                            $rootScope.$broadcast('cmConnectionHandler:failed',function(){
                                self.control();
                            });
                        break;
                    }

                    self.isSecure = false;
                }
            }
        };

        return self;
    }
])
angular.module('comps/security_aspects/drtv-security_aspect.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/security_aspects/drtv-security_aspect.html',
'<section class="content clearfix" ng-click="show = !show"><cm-icons class="{{class}} cm-fl w15" count="{{count}}" icons="{{icons}}"></cm-icons><span class="item cm-fl w80" > {{aspect.languagePrefix+"."+aspect.id+".NAME"|cmTranslate:aspect}}</span></section><span class="icon-list security-settings" ng-click="show = !show"><i class="fa cm-info"></i></span><section class="content mb10" ng-if="show"><cm-info-bubble cm-bind-template="aspect.template"></cm-info-bubble></section><span class="toggleOption" ng-if="showToggleOptions"><a ng-click="aspect.toggle()" ng-if="aspect.isToggleAble" class="classic-link">{{aspect.languagePrefix+"."+aspect.id+".TOGGLE"|cmTranslate}}</a></span>');
}]);
angular.module('comps/security_aspects/drtv-security_indicator.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/security_aspects/drtv-security_indicator.html',
'<cm-loader ng-if ="checking" cm-color ="ci-color"></cm-loader><div ng-if = "!checking"><i ng-if="leading_icon" class="fa with-response leading-icon {{leading_icon}}"></i><cm-icons count="{{positive}}" icons="cm-checkbox-add" class="positive" with-response></cm-icons><cm-icons count="{{negative}}" icons="cm-checkbox-minus" class="negative" with-response></cm-icons><span ng-if="missing_aspects" class="ng-hide">{{"SECURITY_ASPECTS.ERROR.MISSING_DATA"|cmTranslate}}</span></div>');
}]);
angular.module('cmSecurityAspects',['comps/security_aspects/drtv-security_aspect.html','comps/security_aspects/drtv-security_indicator.html'])

.directive('cmSecurityAspect',[

    '$compile',

    function cmSecurityAspect($compile){
        return {
            restrict:       'AE',
            templateUrl:    'comps/security_aspects/drtv-security_aspect.html',
            scope:          {
                                aspect:'=cmData'
                            },

            link:       function(scope, element, attrs){
                            if(typeof attrs.cmShowToggleOptions == 'undefined'){
                                scope.showToggleOptions = true;
                            } else {
                                scope.showToggleOptions = scope.$eval(attrs.cmShowToggleOptions);
                            }

                            if(scope.aspect.value < 0){
                                scope.class = 'negative';
                                scope.icons = 'cm-checkbox-minus';
                            }

                            if(scope.aspect.value == 0)
                                scope.class = 'neutral' ;

                            if(scope.aspect.value > 0){
                                scope.class = 'positive';
                                scope.icons = 'cm-checkbox-add';
                            }

                            element.addClass(scope.class);

                            scope.count = Math.abs(scope.aspect.value);
                        }
        }
    }
])
.directive('cmSecurityIndicator',[
    'cmUserModel', 'cmLogger',
    '$timeout',
    function(cmUserModel, cmLogger,
             $timeout){
        return {
            restrict:   'E',
            templateUrl:'comps/security_aspects/drtv-security_indicator.html',
            scope: {
                conversation: '=cmData'
            },
            controller: function($scope, $element, $attrs){
                $scope.missing_aspects  = true;
                $scope.leading_icon     = 'cm-lock';
                $scope.checking         = true;

                function refreshScope(){
                    //cmLogger.debug('cmSecurityIndicator.refresh');
                    
                    $scope.checking = true

                    $scope.conversation.securityAspects
                    .get()
                    .then(function(){
                        $scope.positive         = $scope.conversation.securityAspects.getPositiveAspects().reduce(function(sum, aspect){ return sum+aspect.value } ,0);
                        $scope.negative         = $scope.conversation.securityAspects.getNegativeAspects().reduce(function(sum, aspect){ return sum-aspect.value } ,0);
                        $scope.missing_aspects  = false;
                        $scope.checking         = false;
                        $scope.leading_icon     = ($scope.positive >= $scope.negative) ? 'cm-lock' : 'cm-unlock';
                    })

                    //console.log('$scope.conversation.recipients', $scope.conversation.recipients.length)
                    //console.log('aspects.length', $scope.conversation.securityAspects.aspects.length)
                    //console.log('aspects', $scope.positive, $scope.negative)

                }

                function check(){ $scope.checking = true }

                if($scope.conversation){
                    refreshScope()
                    $scope.conversation.securityAspects.on('schedule', check);
                    $scope.conversation.securityAspects.on('refresh', refreshScope);
                    

                    $scope.$on('$destroy', function(){
                        $scope.conversation.securityAspects.off('schedule', check);
                        $scope.conversation.securityAspects.off('refresh', refreshScope)
                    })

                } else {
                    cmLogger.debug('cmSecurityIndicator - Conversation not found!')
                }

            }
        }
    }
])

.factory('cmSecurityAspects',[
    'cmObject',
    'cmLogger',
    '$q',
    '$timeout',
    function (cmObject, cmLogger, $q, $timeout){
        /**
         * Generic security aspect
         * @param {Object} [config] contains id, dependencies, value and a function check() that checks if the security aspect applies, returning its value. 
         * Negative values indicate that the aspect lowers the overall security when present, aspects with positive value will improve the security.  the check function should return 0 if it does not apply.
         * An aspect only applies if all its dependencies apply. 
         */
        function SecurityAspect(config){

            cmObject.addEventHandlingTo(this)

            //The id determines the message id for the translations of name and description.
            this.id             = config.id             || 'DEFAULT';
            //Name:         'SECURITY_ASPECT.CONVERSATION.DEFAULT.NAME'
            //Description:  'SECURITY_ASPECT.CONVERSATION.DEFAULT.DESCRIPTION'
            this.value          = config.value          || 0;
            this.dependencies   = config.dependencies   || [];  //Array of aspect ids
            this.languagePrefix = config.languagePrefix || ''

            this.description    = this.languagePrefix+'.'+this.id+'.DESCRIPTION'
            this.name           = this.languagePrefix+'.'+this.id+'.NAME'
            this.toggleLabel    = this.languagePrefix+'.'+this.id+'.TOGGLE'

            this.template       = config.template       || '{{"'+this.description+'"|cmTranslate}}'

            /**
             * Function to check if the aspect applies to the target.
             * @param  {*}      target to evaluate against.
             * @return {Number}        returns true id the aspects applies, false otherwise
             */
            this.check = config.check || function(target){
                return false
            };

            this.isToggleAble = (config.toggleCheck && config.toggleCall) ? true : false;

            /**
             * Function to check the requirements for toggleCall. (Meant to be overwritten!)
             * When .toggle() is called, toggleCall() will only be called if .toggleCheck() retruns truthly.
             * @param   {*}         target  The target the aspect should apply to.
             * @returns {Boolean}           Returns wheter requirements are met.
             */            
            this.toggleCheck = config.toggleCheck || function(target){
                return false
            };

            /**
             * Function change the target in a way the aspect does nit longer apply.
             * When .toggle() is called, toggleCall() will only be called if .toggleCheck() retruns truthly.
             * @param   {*}         target  The target the aspect should apply to.
             */            
            this.toggleCall = config.toggleCall || function(target){
                return false
            };

            //cmSecurityAspects is listening to this event:
            this.toggle = function(){
                this.trigger('toggle')
            };
        }

        /**
         * Security aspect management
         */
        
        function cmSecurityAspects(config){
            config = config || {};

            var self = this;

            cmObject.addEventHandlingTo(this);

            // Array of SecurityAspect instances
            this.aspects = [];
            // Object all aspects should apply to
            this.target = undefined;
            this.applyingAspects = null

            this.countForDigest = 0;

            this.languagePrefix = config.languagePrefix;


            /**
             * Function to set the target all aspects should evaluate against
             * @param {*} target 
             */
            this.setTarget = function(target){
                //cmLogger.debug('cmSecurityAspects.setTarget');

                this.target = target;
                return this;
            };

            /**
             * Function to add a new SecurityAspect instance to the list
             * @param {Object}  config contains the configuration data for security aspect, see above
             * @return {self}   returns self for chaining
             */
            this.addAspect = function(config){
                //cmLogger.debug('cmSecurityAspects.addAspect');

                config.languagePrefix = config.languagePrefix || this.languagePrefix

                var aspect = new SecurityAspect(config);

                aspect.on('toggle', function(){
                    if(aspect.toggleCheck(self.target))
                        aspect.toggleCall(self.target)
                });

                this.aspects.push(aspect);
                return this;
            };

            this.reset = function(){
                this.applyingAspects    = null
            }

            this.refresh = function(){
                //cmLogger.debug('cmSecurityAspects.refresh');

                this.countForDigest++;

                this.reset()

                var failed_aspects = []

                function calculate(applying_aspects){
                    applying_aspects = applying_aspects || [];

                    var candidates =    self.aspects.filter(function(aspect){
                                            return  (
                                                        // Only add aspects not already assumed to apply:
                                                        applying_aspects.indexOf(aspect) == -1
                                                        // Only add aspects that still can apply:
                                                        && failed_aspects.indexOf(aspect) == -1
                                                        // check if all dependencies are among the applying aspects:
                                                        && aspect.dependencies.every(function(dependency_id){
                                                            return applying_aspects.some(function(applying_aspect){
                                                                 return applying_aspect.id == dependency_id
                                                            })
                                                        })
                                                    )
                                        })

                    var additional_aspects = []

                    return $q.all(
                                candidates.map(function(aspect){
                                    return  $q.when(aspect.check(self.target))
                                            .then(function(result){
                                                result === true
                                                ?   additional_aspects.push(aspect)
                                                :   failed_aspects.push(aspect)
                                            })
                                            .finally(function(){
                                                return $q.when()
                                            })

                                })
                            ).then(function(){
                                return  additional_aspects.length == 0
                                        ?   $q.when(applying_aspects)
                                        :   calculate( applying_aspects.concat(additional_aspects) );
                            })

                }

                return  calculate()
                        .then(function(applying_aspects){
                            self.applyingAspects = applying_aspects
                            self.trigger('refresh')
                            $q.when(applying_aspects)
                        })

            }



            var refresh_scheduled = false

            this.scheduleRefresh = function(){
                //prevent more than 1 refresh call per second
                if(!refresh_scheduled){
                    self.reset()

                    $timeout(function(){
                        self.refresh();
                    }, 400)
                    .then(function(){
                        refresh_scheduled = false
                    })

                    refresh_scheduled = true
                    self.trigger('schedule')
                } 
            }

            /**
             * Function to calculate applying aspects if needed, i.e. cached is empty
             * @return {[type]} [description]
             */
            this.get = function(){
                return  this.applyingAspects == null
                        ?   this.refresh()
                        :   $q.when(this.applyingAspects)
            }


            /**
             * Function to get all applying security aspects
             * @package {Array}  [applying_aspects = []]    Array of already applying aspects, used to resolve dependencies
             * @return  {Array}                             Array of all applying aspects
             */
            this.getApplyingAspects = function(applying_aspects){
                if(this.applyingAspects == null)
                    cmLogger.warn('cmSecurityAspects: no applying aspects found, you probably forgot to call .refresh().')

                return  this.applyingAspects 
            }

            /**
             * Function to get all security aspects that evaluate positively against the target
             * @return {Array}              Array of aspects
             */
            this.getPositiveAspects = function(){
                return this.getApplyingAspects().filter(function(aspect){ return aspect.value > 0 });
            };

            /**
             * Function to get all security aspects that evaluate positively against the target
             * @return {Array}              Array of aspects
             */           
            this.getNegativeAspects = function(){
                return this.getApplyingAspects().filter(function(aspect){ return aspect.value < 0 });
            };

            /**
            * Function to get all security aspects that evaluate neutrally (value == 0) against the target
            * @return {Array}              Array of aspects
            */           
            this.getNeutralAspects = function(){
                return this.getApplyingAspects().filter(function(aspect){ return aspect.value === 0 });
            };

            /**
             * Function to get all security aspects that do not apply to the target
             * @return {Array}              Array of aspects
             */
            this.getNonApplyingAspects = function(){                
                return this.aspects.filter(function(aspect){ return self.getApplyingAspects().indexOf(aspect) == -1 });
            };

            /**
             * Function to check wether an aspect with given id applies
             * @param  {string} id  Aspect id
             * @return {boolean}    true iff the aspect applies
             */
            this.applies = function(id){
                return !!this.getApplyingAspects().filter(function(aspect){ return aspect.id == id })[0]
            }
        }


        return cmSecurityAspects
    }
])
angular.module('comps/setup/drtv-setup-account.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/setup/drtv-setup-account.html',
'<cm-scrollable><article class="content" ng-click="toggleHeadlineInfo()" data-qa="ctn-toggle-headline"><cm-info-bubble nose-x="45%"><div ng-show="!showHeadlineInfo" data-qa="info-headline-small"><i class="fa cm-info cm-ci-color"></i> {{::\'ACCOUNT.CREATE.INFO.NOTE_ABOUT_THIS_DATA_SMALL\'|cmTranslate}}</div><div ng-show="showHeadlineInfo" data-qa="info-headline"><i class="fa cm-info cm-ci-color"></i> {{::\'ACCOUNT.CREATE.INFO.NOTE_ABOUT_THIS_DATA_SMALL\'|cmTranslate}}<hr class="margin-small" /><span ng-bind-html="::\'ACCOUNT.CREATE.INFO.NOTE_ABOUT_THIS_DATA\'|cmParse"></span></div></cm-info-bubble></article><hr class="margin-small" /><form name="cmForm" novalidate autocomplete="off"><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="2" cm-label="ACCOUNT.PLACEHOLDER.PHONENUMBER" cm-info="ACCOUNT.INFO.INVALID.PHONENUMBER" cm-toggle-info="ACCOUNT.INFO.PHONENUMBER" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="3" cm-label="ACCOUNT.PLACEHOLDER.EMAIL" cm-info="ACCOUNT.INFO.INVALID.EMAIL" cm-toggle-info="ACCOUNT.INFO.EMAIL" ></cm-form-email><hr class="margin-small" /></form><article class="content" ng-show="saveError" data-qa="ctn-save-error"><cm-info-bubble class="cm-alert"><i class="fa cm-info"></i><span ng-bind-html="::\'ACCOUNT.CREATE.ERROR\' | cmParse"></span></cm-info-bubble></article></cm-scrollable><cm-footer><button class="cm-btn-grey" ng-click="saveAccount()" data-qa="btn-next-step" cm-reactive><span ng-show="!showLoader && !isPristine" data-qa="btn-saveAccount"> {{::\'ACCOUNT.FOOTER.SAVE\'|cmTranslate}}<i class="fa cm-checker"></i></span><span ng-show="isPristine" data-qa="btn-pristineSkip"> {{::\'ACCOUNT.FOOTER.SKIP\'|cmTranslate}}<i class="fa cm-right"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/setup/drtv-setup-identity.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/setup/drtv-setup-identity.html',
'<cm-scrollable><article class="content" ng-click="toggleHeadlineInfo()" data-qa="ctn-toggle-headline"><cm-info-bubble nose-x="45%"><div ng-show="!showHeadlineInfo" data-qa="info-headline-small"><i class="fa cm-info cm-ci-color"></i> {{\'IDENTITY.INFO.CREATE.HEADLINE_SMALL\'|cmTranslate}}</div><div ng-show="showHeadlineInfo" data-qa="info-headline"><i class="fa cm-info cm-ci-color"></i> {{\'IDENTITY.INFO.CREATE.HEADLINE_SMALL\'|cmTranslate}}<hr class="margin-small" /><span ng-bind-html="\'IDENTITY.INFO.CREATE.HEADLINE\'|cmParse"></span></div></cm-info-bubble></article><hr class="margin-small" /><form name="cmForm" novalidate autocomplete="off"><article class="content"><label data-qa="ctn-toggle-avatar-info" ng-click="toggleAvatarInfo()" cm-reactive>{{\'CONTACT.PLACEHOLDER.AVATAR\'|cmTranslate}}<i class="fa cm-ci-color cm-info"></i></label><cm-info-bubble ng-click="toggleAvatarInfo()" ng-show="showAvatarInfo" data-qa="ctn-avatar-info" nose-x="20%"> {{\'IDENTITY.INFO.CREATE.AVATAR\'|cmTranslate}}</cm-info-bubble></article><article class="content tac"><div class="avatar"><cm-upload-avatar class="border-complete"></cm-upload-avatar><cm-avatar cm-data="identity" cm-avatar-view="{{chooseAvatar?\'unknown\':\'\'}}" class="mega"></cm-avatar></div></article><hr class="margin-small" /><article class="content"><label data-qa="ctn-toggle-cameoid-info" ng-click="toggleCameoIdInfo()" cm-reactive>{{\'CONTACT.PLACEHOLDER.CAMEOID\'|cmTranslate}}<i class="fa cm-ci-color cm-info"></i></label><cm-info-bubble ng-click="toggleCameoIdInfo()" ng-show="showCameoIdInfo" data-qa="ctn-cameoid-info" nose-x="25%"> {{\'IDENTITY.INFO.CREATE.CAMEOID\'|cmTranslate}}</cm-info-bubble><div class="cm-input-ctn is-selectable-all with-inside-left-icon"><i class="fa cm-rhino-positive cameo-id-icon"></i><span class="without-input">{{identity.cameoId}}</span></div></article><hr class="margin-small" /><article class="content"><label data-qa="ctn-toggle-displayname-info" ng-click="toggleDisplayNameInfo()" cm-reactive>{{\'SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}<i class="fa cm-ci-color cm-info"></i></label><cm-info-bubble ng-click="toggleDisplayNameInfo()" ng-show="showDisplayNameInfo" data-qa="ctn-displayname-info" nose-x="25%"> {{\'IDENTITY.INFO.CREATE.DISPLAYNAME\'|cmTranslate}}</cm-info-bubble><div class="cm-input-ctn with-inside-icon"><input tabindex="2" data-qa="input-displayname" type="text" name="displayName" ng-model="formData.displayName" ng-keyup="validateDisplayName()" /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show=" cmForm.displayName.$dirty && cmForm.displayName.$invalid && cmForm.displayName.length > 0 "><div ng-show="cmForm.displayName.$error.required"><i class="fa cm-info"></i> {{\'SETTINGS.PAGES.IDENTITY.CREATE.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="3" cm-label="SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.PHONENUMBER" cm-info="SETTINGS.PAGES.IDENTITY.CREATE.INFO.INVALID.PHONENUMBER" cm-toggle-info="IDENTITY.INFO.CREATE.PHONE" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="4" cm-label="SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.EMAIL" cm-info="SETTINGS.PAGES.IDENTITY.CREATE.INFO.INVALID.EMAIL" cm-toggle-info="IDENTITY.INFO.CREATE.EMAIL" ></cm-form-email></form></cm-scrollable><cm-footer><button class="cm-btn-grey" ng-click="updateIdentity()" data-qa="btn-next-step" cm-reactive><span ng-show="!showLoader && !isPristine || !showLoader && !isFakePristineBecauseOfAvatar"> {{\'SETTINGS.PAGES.IDENTITY.CREATE.FOOTER\'|cmTranslate}} <i class="fa cm-checker"></i></span><span ng-show="isPristine && isFakePristineBecauseOfAvatar" data-qa="btn-pristineSkip"> {{\'ACCOUNT.FOOTER.SKIP\'|cmTranslate}}<i class="fa cm-right"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('cmSetup',[
    'cmCore',
    'cmValidate'
,'comps/setup/drtv-setup-account.html','comps/setup/drtv-setup-identity.html'])

.directive('cmSetupAccount', [
    'cmUserModel','cmUtil','cmLoader','cmLogger', 'cmPristine',
    '$rootScope', '$q',
    function(cmUserModel, cmUtil, cmLoader, cmLogger, cmPristine,
             $rootScope, $q){
        return {
            restrict: 'E',
            templateUrl: 'comps/setup/drtv-setup-account.html',
            controller: function($scope){
                var loader = new cmLoader($scope);

                $scope.account = cmUserModel.data.account;
                $scope.saveError = false;

                /**
                 * Toogle HeadlineInfo
                 */
                $scope.showHeadlineInfo = false;
                $scope.toggleHeadlineInfo = function() {
                    $scope.showHeadlineInfo = !$scope.showHeadlineInfo ? true : false;
                };

                $scope.formData = {
                    phoneNumber: '',
                    mergedPhoneNumber: '',
                    email: ''
                };

                $scope.validateForm = function(){
                    var deferred = $q.defer(),
                        objectChange = {};

                    function checkPhoneNumber() {
                        var value = $scope.formData.mergedPhoneNumber;

                        if (value != undefined) {
                            objectChange.phoneNumber = value;
                        }
                    }

                    function checkEmail() {
                        var value = $scope.formData.email;
                        if (value != undefined) {
                            objectChange.email = value;
                        }
                    }

                    checkPhoneNumber();
                    checkEmail();
                    if($scope.cmForm.$valid !== false && cmUtil.objLen(objectChange) > 0){
                        deferred.resolve(objectChange);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.saveAccount = function(){
                    $scope.saveError = false;

                    if($scope.isPristine){
                        $scope.goToNextStep();
                        return false;
                    }

                    if(loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm().then(
                        function(objectChange){
                            cmUserModel.updateAccount(objectChange).then(
                                function(){
                                    $scope.goToNextStep();
                                    loader.stop();
                                },
                                function(res){
                                    loader.stop();

                                    if(!'errorCodes' in res.data){
                                        $scope.saveError = true;
                                    }
                                }
                            );
                        },
                        function(){
                            loader.stop();
                            cmUtil.scrollToInputError();
                        }
                    );
                };

                $scope.goToNextStep = function(){
                    $rootScope.goTo('/setup/identity');
                };

                /**
                 * Pristine Service Handling
                 */
                cmPristine.initView($scope);
            }
        }
    }
])

    .directive('cmSetupIdentity', [
        'cmUserModel', 'cmAuth', 'cmIdentityFactory', 'cmUtil', 'cmPristine', 'cmNotify', 'cmLoader', 'cmLogger',
        '$rootScope', '$q',
        function(cmUserModel, cmAuth, cmIdentityFactory, cmUtil, cmPristine, cmNotify, cmLoader, cmLogger,
                 $rootScope, $q){
            return {
                restrict: 'E',
                templateUrl: 'comps/setup/drtv-setup-identity.html',
                controller: function($scope) {
                    var loader = new cmLoader($scope);

                    $rootScope.generateAutomatic = {
                        generate: true,
                        keySize: 2048
                    };

                    $scope.identity = cmUserModel.data.identity;

                    /**
                     * Toogle HeadlineInfo
                     */
                    $scope.showHeadlineInfo = false;
                    $scope.toggleHeadlineInfo = function() {
                        $scope.showHeadlineInfo = !$scope.showHeadlineInfo ? true : false;
                    };
                    /**
                     * Toogle AvatarInfo
                     */
                    $scope.showAvatarInfo = false;
                    $scope.toggleAvatarInfo = function() {
                        $scope.showAvatarInfo = !$scope.showAvatarInfo ? true : false;
                    };
                    /**
                     * Toogle CameoIdInfo
                     */
                    $scope.showCameoIdInfo = false;
                    $scope.toggleCameoIdInfo = function() {
                        $scope.showCameoIdInfo = !$scope.showCameoIdInfo ? true : false;
                    };
                    /**
                     * Toogle DisplayNameInfo
                     */
                    $scope.showDisplayNameInfo = false;
                    $scope.toggleDisplayNameInfo = function() {
                        $scope.showDisplayNameInfo = !$scope.showDisplayNameInfo ? true : false;
                    };

                    function reset(){
                        $scope.formData = {
                            displayName: $scope.identity.displayName,
                            phoneNumber: $scope.identity.phoneNumber ? $scope.identity.phoneNumber.value : '',
                            mergedPhoneNumber: '',
                            email: $scope.identity.email ? $scope.identity.email.value : ''
                        };
                    }

                    reset();

                    $scope.validateDisplayName = function () {
                        if ($scope.formData.displayName == undefined
                            || $scope.formData.displayName.length == 0
                        ) {
                            $scope.cmForm.displayName.$pristine = true;
                            $scope.cmForm.displayName.$dirty = false;
                        }
                    };

                    $scope.validateForm = function () {
                        var deferred = $q.defer(),
                            objectChange = {};


                        function checkDisplayName() {
                            var value = $scope.formData.displayName;
                            if (value != undefined
                                && value != '') {
                                objectChange.displayName = value;
                            }
                        }

                        function checkPhoneNumber() {
                            var value = $scope.formData.mergedPhoneNumber;
                            if (value != undefined
                                && value != '') {
                                objectChange.phoneNumber = value;
                            }
                        }

                        function checkEmail() {
                            var value = $scope.formData.email;
                            if (value != undefined
                                && value != '') {
                                objectChange.email = value;
                            }
                        }

                        checkDisplayName();
                        checkPhoneNumber();
                        checkEmail();

                        if ($scope.cmForm.$valid !== false) {
                            deferred.resolve(objectChange);
                        } else {
                            deferred.reject();
                        }

                        return deferred.promise;
                    };

                    $scope.updateIdentity = function () {
                        if($scope.isPristine) {
                            $scope.goToNextStep();

                            return false;
                        }

                        if (loader.isIdle())
                            return false;

                        loader.start();

                        $scope.validateForm().then(
                            function (objectChange) {
                                if(cmUtil.objLen(objectChange) > 0){
                                    cmUserModel.data.identity.one('update:finished',function(){
                                        $scope.goToNextStep();
                                    });

                                    cmUserModel.data.identity.update(objectChange);
                                } else {
                                    $scope.goToNextStep();
                                }
                            },
                            function () {
                                loader.stop();
                            }
                        );
                    };

                    $scope.goToNextStep = function(){
                        loader.stop();

                        cmNotify.ringBimmel('markHelp');

                        cmUserModel.updateAccount({'registrationIncomplete':false}).finally(
                            function(){
                                $rootScope.goTo('/settings/identity/key/create');
                            }
                        );
                    };

                    /**
                     * Pristine Service Handling
                     */
                    $scope.isFakePristineBecauseOfAvatar = true;
                    var killWatcher = $rootScope.$on('cmUploadAvatar:success',function(){
                        $scope.isFakePristineBecauseOfAvatar = false;
                    });
                    $scope.$on('$destroy', function(){
                        killWatcher();
                    });

                    cmPristine.initView($scope);
                }
            }
        }
    ]
)
angular.module('comps/ui/context/drtv-context-bar.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/context/drtv-context-bar.html',
'<section data-qa="cm-context-ctn"><div ng-show="!showLoader"><i class="fa cm-left" ng-click="close()" data-qa="btn-context-close" cm-reactive></i><span class="counter" data-qa="ctn-context-counter">{{counter}}</span><i class="fa cm-trash" ng-click="delete()" data-qa="btn-context-delete" cm-reactive></i></div><cm-loader cm-color="ci-color" ng-show="showLoader"></cm-loader></section>');
}]);
angular.module('comps/ui/country-prefix/drtv-country-prefix-handler.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/country-prefix/drtv-country-prefix-handler.html',
'<div ng-click="toggleList()" data-qa="btn-toggleCountries"><i class="fa" ng-class="{\'cm-down\':!listVisible,\'cm-up\':listVisible}"></i><span class="flag-icon" ng-bind-html="\':\'+activeCountry.shortcut+\':\'|flags"></span><span class="number-prefix">{{activeCountry.numberPrefix}}</span></div>');
}]);
angular.module('comps/ui/country-prefix/drtv-country-prefix-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/country-prefix/drtv-country-prefix-list.html',
'<div class="country" ng-repeat="country in countries|orderBy:\'numberPrefix\':false" cm-reactive cm-country-prefix-shortcut="{{::country.shortcut}}" cm-country-prefix-number="{{::country.numberPrefixRaw}}" ng-click="chooseCountry(country)" ng-class="{ \'is-active\':activeListCountry.shortcut == country.shortcut || foundCountry.shortcut == country.shortcut }"><span class="flag-icon" ng-bind-html="::\':\'+country.shortcut+\':\'|flags"></span><strong>{{::country.shortcut|uppercase}}</strong> {{::country.numberPrefix}}</div>');
}]);
angular.module('comps/ui/drtv-default-pages.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/drtv-default-pages.html',
'<section class="default-pages"><button ng-click="goTo(\'/talks\')" ng-class="{\'isActive\':isTalks}" cm-reactive data-qa="btn-talks"><i class="fa fa-lg-icon cm-talk"></i> {{\'DRTV.FOOTER.TALKS\' | cmTranslate}}</button><button ng-click="goTo(\'/contact/list\')" ng-class="{\'isActive\':isContacts}" cm-reactive data-qa="btn-contacts"><i class="fa fa-lg-icon cm-person"></i> {{\'DRTV.FOOTER.CONTACTS\' | cmTranslate}}</button></section>');
}]);
angular.module('comps/ui/menu/drtv-menu.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/menu/drtv-menu.html',
'<div class="cm-handler" ng-click="handleMenu()" data-qa="btn-open-menu" cm-reactive><cm-notify-signal></cm-notify-signal></div><div class="cm-menu-layer" ng-class="{\'is-active\':menuVisible}"><div cm-transparent-bg ng-click="handleMenu()"></div><div class="cm-menu-list"><ul class="no-border-bottom"><li class="cm-nose-wrapper" ng-click="handleMenu()"><i class="fa cm-nose-up"></i></li><li class="cm-menu-header"><button ng-click="goTo({},\'talks\')" cm-reactive><i class="fa cm-talk"></i><div class="seperator"></div></button><button ng-click="goTo({},\'contacts\')" cm-reactive><i class="fa cm-person"></i></button></li><li ng-class="{\'cm-info-btn\':(btn == \'help\' && markHelp)}" class="{{menu[btn].css}}" ng-repeat="btn in menuKeys" ng-click="goTo(menu[btn], btn)" data-qa="{{menu[btn][\'data-qa\']}}" cm-reactive><i class="fa icon-left" ng-if="menu[btn].icon != undefined" ng-class="menu[btn].icon"></i><span> {{menu[btn].i18n|cmTranslate}}<cm-friend-request-counter ng-if="menu[btn].drtv != undefined && menu[btn].drtv == \'cm-friend-request-counter\'" ></cm-friend-request-counter></span><div class="clearfix"></div></li><li ng-click="logout()" data-qa="logout-btn" cm-reactive><i class="fa cm-logout icon-left"></i><a class="logout">{{\'MENU.LOGOUT\'|cmTranslate}}</a><div class="clearfix"></div></li><li><i class="fa cm-rhino-positive icon-left"></i><span>{{version}}</span><div class="clearfix"></div></li></ul><div class="bottom-filler"></div></div></div>');
}]);
angular.module('comps/ui/modal/drtv-modal-alert.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/modal/drtv-modal-alert.html',
'<article class="cm-modal-alert"><header ng-show="closeBtn"><button ng-click="close()" class="close"><i class="fa cm-close"></i></button></header><ng-transclude class="content"></ng-transclude><footer><button class="cm-btn-grey" ng-click="close()" data-qa="cm-modal-close-btn" cm-reactive> {{(footerLabel||\'MODAL.ALERT.OK\')|cmTranslate}}<i ng-if="footerIcon" class="fa {{footerIcon}}"></i></button></footer></article><div class="backdrop"></div>');
}]);
angular.module('comps/ui/modal/drtv-modal-confirm.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/modal/drtv-modal-confirm.html',
'<article class="cm-modal-plain" data-qa = "modal-confirm"><header><button ng-click="close()" class="close" ng-show="closeBtn" data-qa="cm-modal-close-btn"><i class="fa cm-close"></i></button><h2 class="{{severity}}">{{title|cmTranslate}}</h2></header><div class="content"><div class="modal-row taj"><span ng-bind-html="text | cmParse"></span><ng-transclude></ng-transclude></div></div><footer><button class = "cm-btn-grey cm-white-border-right dib w50" data-qa = "btn-cancel" ng-click = "cancel()" cm-reactive > {{ (labelCancel || \'MODAL.LABEL.CANCEL\') | cmTranslate }}<i class="fa cm-checkbox-wrong"></i></button><button class = "cm-btn-grey dib w50" data-qa = "btn-confirm" ng-click = "confirm()" cm-reactive > {{ (labelOkay || \'MODAL.LABEL.OK\') | cmTranslate }}<i class="fa cm-checker"></i></button></footer></article><div class="backdrop" ng-hide="options.withoutBackdrop"></div>');
}]);
angular.module('comps/ui/modal/drtv-modal-fullscreen.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/modal/drtv-modal-fullscreen.html',
'<div class="content" ng-click="close()"><cm-loader ng-show="fullscreenSpinner" cm-color="ci-color" class="fullscreen"></cm-loader><ng-transclude></ng-transclude></div><div class="backdrop"></div>');
}]);
angular.module('comps/ui/modal/drtv-modal-plain.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/ui/modal/drtv-modal-plain.html',
'<article class="cm-modal-plain"><header><button ng-click="close()" class="close" ng-show="closeBtn" data-qa="cm-modal-close-btn"><i class="fa cm-close"></i></button><h2 class="{{severity}}" ng-if="title">{{title|cmTranslate}}</h2></header><ng-transclude class="content"></ng-transclude></article><div class="backdrop" ng-hide="options.withoutBackdrop"></div>');
}]);
angular.module('cmUi', [
    'cmCore',
    'cmValidate',
    'ngSanitize',
    'emoji',
    'flags'
,'comps/ui/context/drtv-context-bar.html','comps/ui/country-prefix/drtv-country-prefix-handler.html','comps/ui/country-prefix/drtv-country-prefix-list.html','comps/ui/drtv-default-pages.html','comps/ui/menu/drtv-menu.html','comps/ui/modal/drtv-modal-alert.html','comps/ui/modal/drtv-modal-confirm.html','comps/ui/modal/drtv-modal-fullscreen.html','comps/ui/modal/drtv-modal-plain.html'])
.directive('cmContextBar',[
    'cmContextFactory', 'cmModal', 'cmLoader',
    function(cmContextFactory, cmModal, cmLoader){
        return {
            restrict: 'E',
            templateUrl: 'comps/ui/context/drtv-context-bar.html',
            scope: {},
            link: function(scope, element){

                function activate(){
                    if(!element.hasClass('cm-show')){
                        element.addClass('cm-show');
                    }

                    scope.counter = cmContextFactory.length;
                }

                function deactivate(){
                    element.removeClass('cm-show');
                }

                function check(){
                    if(cmContextFactory.length > 0){
                        scope.counter = cmContextFactory.length;
                    } else {
                        deactivate();
                    }
                }

                cmContextFactory.on('register', activate);
                cmContextFactory.on('deregister', check);

                scope.$on('$destroy',function(){
                    cmContextFactory.off('register', activate);
                    cmContextFactory.off('deregister', check);
                });

                cmContextFactory.on('clear', deactivate);

                scope.$on('$destroy',function(){
                    cmContextFactory.off('clear', deactivate);
                });

                /**
                 * @todo clear on route change?
                 */
            },
            controller: function($scope){
                var running = false,
                    loader = new cmLoader($scope);

                $scope.counter = 0;

                $scope.close = function(){
                    cmContextFactory.clear();
                };

                $scope.delete = function(){
                    if(!running){
                        running = true;

                        var constText = 'SYSTEM.CONTEXT.MODAL.CONFIRM.DELETE.ONE_ITEM';
                        if(cmContextFactory.length > 1){
                            constText = 'SYSTEM.CONTEXT.MODAL.CONFIRM.DELETE.MORE_ITEMS';
                        }

                        cmModal.confirm({
                            title:  'SYSTEM.CONTEXT.MODAL.CONFIRM.DELETE.TITLE',
                            text:   constText
                        })
                        .then(function(){
                            loader.start();

                            cmContextFactory.delete()
                                            .finally(function(){
                                                running = false;
                                                loader.stop();
                                                $scope.close();
                                            });
                        })
                    }
                };
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmContext
 * @description
 * directive for an tag that should have a tap (click) function for example goto detail
 * and have a longtap (press) function for a action like remove or something like that
 *
 * @params model (object) reference to object
 * @params type (string) type constant
 * @params tap (function) callback for tap (click) e.x. tap:setState('goto /talks/'+conversation.id)
 * @params longTap (function) callback for longtap (press) e.x. longTap:setState('longTab '+$context.type)}
 *
 * @restrict A
 * @requires $parse
 * @requires $window
 * @requires Hammer
 *
 * @example
 <example module="cmDemo">
    <file name="style.css">
        .whoop{padding:10px;background:#fff}
    </file>
    <file name="script.js">
         angular
         .module('cmDemo', ['cmUi'])
         .controller('Ctrl', function ($scope){
            $scope.conversation = {id:1123};

            $scope.state = '';
            $scope.setState = function(log){
                $scope.state += log +'\n';
            }
        })

    </file>
         <file name="index.html">
             <div ng-controller="Ctrl">
                 <div cm-context="{
                      model:conversation,
                      type:'cmContextTest conversation',
                      tap:setState('goto /conversation/'+conversation.id),
                      longTap:setState('longTab '+$context.type)
                    }" class="whoop">
                 cmContextTest conversation
                 </div>

                 <div cm-context="{model:conversation,type:'cmContextTest talks',tap:setState('goto /talks/'+conversation.id),longTap:setState('longTab '+$context.type)}" class="whoop">
                 cmContextTest talks
                 </div>

                 <pre>{{state}}</pre>
             </div>
         </file>
     </example>

*/


.directive('cmContext',[
    'cmContextFactory',
    '$parse', '$window',
    function (cmContextFactory,
              $parse, $window){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){

                var contextData = attrs.cmContext,
                    hammer;

                // init cm-selecter
                if(element.find('cm-avatar').length == 1 &&
                    element.find('cm-selecter').length == 0){
                    angular.element(element.find('cm-avatar'))
                        .append('<cm-selecter><div class="wrap"><i class="fa cm-checkbox-right"></i></div></cm-selecter>');
                    element.addClass('is-unselected');
                }

                function getContext(){
                    return {
                        model: getOption('model')(scope),
                        type: getOption('type')()
                    }
                }

                function getOption(type){

                    var matches = contextData.match('('+type+'):([0-9a-zA-Z\\(\\)/"\'+\\.$ ]+,{.+\\)|[0-9a-zA-Z\\(\\)/"\'+\\.$ ]+)'),
                        value = undefined;

                    if(matches && matches.length > 2)
                        value = $parse(matches[2]);


                    return value || undefined;
                }

                function onTap(event){
                    event.preventDefault();
                    var context = getContext(),
                        callback = getOption('tap');

                    scope.$apply(function(){
                        if(cmContextFactory.hasSelection()){
                            scope.handleLongTap(context);
                        } else if(typeof callback != 'undefined'){
                            callback(scope, {$event: event, $context: context});
                        }
                    });
                }

                function onLongTap(event){
                    event.preventDefault();
                    var context = getContext(),
                        callback = getOption('longTap');

                    scope.$apply(function(){
                        scope.handleLongTap(context);

                        if(typeof callback != 'undefined'){
                            callback(scope, {$event: event, $context: context});
                        }
                    });
                }

                if(typeof Hammer === 'undefined' || !$window.addEventListener) {
                    // fallback to mouse events where appropriate
                    element.bind('click', onTap);
                    element.bind('dblclick', onLongTap);

                    scope.$on('$destroy', function(){
                        element.off('click', onTap);
                        element.off('dblclick', onLongTap);
                    });
                    return;
                }

                if (!(hammer = element.data('hammer'))) {
                    hammer = Hammer(element[0]);
                    element.data('hammer', hammer);
                }

                hammer.on('tap', onTap);
                hammer.on('press', onLongTap);

                function setClass(){
                    element.removeClass('is-unselected');
                    element.addClass('is-selected');
                }

                function removeClass(){
                    element.removeClass('is-selected');
                }

                scope.handleLongTap = function(context){
                    var instance = cmContextFactory.find(context);

                    if(cmContextFactory.validate(context) && instance == null){
                        setClass();
                        cmContextFactory.create(context);
                    } else {
                        cmContextFactory.deregister(instance);
                        removeClass();
                    }
                };

                cmContextFactory.on('clear',removeClass);

                scope.$on('$destroy', function(){
                    hammer.off('tap', onTap);
                    hammer.off('press', onLongTap);
                    cmContextFactory.off('clear',removeClass);
                });
            }
        }
    }
])
.service('cmContextFactory', [
    'cmFactory', 'cmContextModel', 'cmStateManagement', 'cmNotify', 'cmLogger',
    '$rootScope', '$q',
    function(cmFactory, cmContextModel, cmStateManagement, cmNotify, cmLogger,
             $rootScope, $q) {

        var self = cmFactory(cmContextModel,
            function sameByData(instance, data){
                return (data &&
                        data.type &&
                        data.type != '' &&
                        data.model &&
                        data.model.id &&
                        data.model.id != '' &&
                        data.model.id == instance.model.id &&
                        data.type == instance.type)
            },
            function sameByInstance(instance_1, instance_2){
                return (instance_1 &&
                        instance_1.type &&
                        instance_1.model &&
                        instance_1.model.id &&
                        instance_2 &&
                        instance_2.type &&
                        instance_2.model &&
                        instance_1.model.id &&
                        instance_1.model.id == instance_2.model.id &&
                        instance_1.type == instance_2.type)

            });

        self.state = new cmStateManagement();

        self.clear = function(){
            self.reset();
            self.trigger('clear');
        };

        self.delete = function(){
            //cmLogger.debug('cmFactory.delete -> proceed delete context objects');

            var defered = $q.defer(),
                done = [];


            self.forEach(function(instance){
                done.push(instance.delete())
            });

            $q.all(done).then(
                function(){
                    defered.resolve();
                },
                function(){
                    cmNotify.warn('SYSTEM.CONTEXT.MODAL.NOTIFY.DELETE_ERROR')
                    defered.reject();
                }
            );

            return defered.promise;
        };

        self.validate = function(data){
            if(data != null && typeof data == 'object' && typeof data.type == 'string' && data.type != '' && data.model != null && typeof data.model == 'object' && typeof data.model.id != 'undefined' && data.model.id != ''){
                return true;
            } else {
                // error
            }

            return false;
        };

        self.hasSelection = function(){
            return self.length > 0;
        };

        /**
         * EventHandling
         */

        self.on('deleted:finished', function(event, data){
            console.log('factory on delete:finished', data)
        });

        $rootScope.$on('logout', function(){
            self.reset();
        });

        $rootScope.$on('identity:switched', function(){
            self.reset();
        });

        $rootScope.$on('login', function(){
            self.reset();
        });

        $rootScope.$on('$routeChangeSuccess', function(){
            self.reset();
        });

        return self;
    }
])
.factory('cmContextModel', [
    'cmStateManagement', 'cmObject', 'cmLogger',
    'cmConversationContextModel', 'cmContactContextModel',
    '$rootScope', '$q',
    function(cmStateManagement, cmObject, cmLogger,
             cmConversationContextModel, cmContactContextModel,
             $rootScope, $q) {

        function cmContextModel(data){
            var self = this;

            cmObject.addEventHandlingTo(this);

            this.state = new cmStateManagement();

            this.type = undefined;
            this.model = undefined;

            function init(data){
                //cmLogger.debug('cmContextModel init');
                self.importData(data);
            }

            this.importData = function(data){
                //cmLogger.debug('cmContextModel.importData');

                this.type = data.type || this.type;

                switch(this.type){
                    case "conversation":
                            this.model = new cmConversationContextModel(data.model) || this.model;
                        break;
                    case "contact":
                            this.model = new cmContactContextModel(data.model) || this.model;
                        break;
                    default:
                        // remove model from factory?
                }
            };

            this.delete = function(){
                //cmLogger.debug('cmContextModel.delete');

                if(typeof this.model.delete == 'function'){
                    return this.model.delete();
                } else {
                    return $q.when();
                }
            };


            init(data);
        }

        return cmContextModel;
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmCountryPrefixHandler
 * @description
 * a toggle handler for country prefix choosing
 *
 * @restrict A
 * @requires cmCountryPrefix
 *
 * @example
 <example module="cmDemo">
     <file name="script.js">
         angular
         .module('cmDemo', ['cmUi'])
         .controller('Ctrl', function ($scope){

                $scope.phoneNumberUndefined = undefined;
                $scope.phoneNumberUndefinedOut = undefined;
                $scope.phoneNumberEmpty = '';
                $scope.phoneNumberEmptyOut = '';
                $scope.phoneNumberFull = '+4900000000';
                $scope.phoneNumberFullOut = '+4900000000';

         });
     </file>
     <file name="index.html">
     <div ng-controller="Ctrl">
         <cm-form-phonenumber
             ng-model="phoneNumberUndefiend"
             ng-model-out="phoneNumberUndefinedOut"
             cm-tabindex="1"
             cm-label="phoneNumber model undefined"
         ></cm-form-phonenumber>
         {{'phoneNumberUndefined: '+phoneNumberUndefinedOut}}

         <cm-form-phonenumber
             ng-model="phoneNumberEmpty"
             ng-model-out="phoneNumberEmptyOut"
             cm-tabindex="2"
             cm-label="phoneNumber model empty"
         ></cm-form-phonenumber>
         {{'phoneNumberEmpty: '+phoneNumberEmptyOut}}

         <cm-form-phonenumber
             ng-model="phoneNumberFull"
             ng-model-out="phoneNumberFullOut"
             cm-tabindex="3"
             cm-label="phoneNumber model data"
         ></cm-form-phonenumber>
         {{'phoneNumberFull: '+phoneNumberFullOut}}
     </file>
 </example>
 */


.directive('cmCountryPrefixHandler',[
    'cmCountryPrefix',
    function (cmCountryPrefix){

        return{
            restrict: 'E',
            templateUrl: 'comps/ui/country-prefix/drtv-country-prefix-handler.html',
            controller: function($scope){
                $scope.activeCountry = {};

                cmCountryPrefix.getDefaultCountry().then(function(country){
                    $scope.activeCountry = country
                });

                $scope.listVisible = false;
                $scope.toggleList = function(forceClose){
                    $scope.listVisible  = !forceClose && $scope.listVisible || forceClose ? false : true;
                    $scope.$broadcast('cmCountryPrefixList:toggle', $scope.listVisible, $scope.activeCountry);
                };

                // event handling
                var killWatcher = $scope.$on('cmCountryPrefixHandler:set', function(event, country){
                    if(country)
                        $scope.activeCountry = country;
                    $scope.toggleList(true);
                });

                $scope.$on('$destroy', function(){
                    killWatcher();
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmCountryPrefixList
 * @description
 * a list for all possile countries with prefix and flag
 *
 * @restrict E
 * @requires cmCountryPrefix
 * @requires cmUtil
 * @requires $timeout
 * @requires $window
 * */


.directive('cmCountryPrefixList',[
    'cmCountryPrefix', 'cmUtil',
    '$timeout', '$window',
    function (cmCountryPrefix, cmUtil,
              $timeout, $window){

        return{
            restrict: 'E',
            templateUrl: 'comps/ui/country-prefix/drtv-country-prefix-list.html',
            controller: function($scope){
                $scope.activeListCountry = {};
                $scope.foundCountry = {};
                $scope.countries = [];
                // init
                cmCountryPrefix.getCountries().then(function(countries){
                    $scope.countries = countries;
                });

                $scope.chooseCountry = function(country){
                    $scope.$broadcast('cmCountryPrefixHandler:set', country);
                };
            },
            link: function(scope, element){
                // scroll into mask
                function scrollTo(elementTo){
                    var elementToScroll = elementTo || element[0].querySelector('.is-active')

                    if(elementToScroll){
                        var wrapOffsetTop = element[0].offsetTop,
                            middleOfWrap = (element[0].offsetHeight / 2) - (elementToScroll.offsetHeight / 2);

                        var newTop = elementToScroll.offsetTop - wrapOffsetTop - middleOfWrap;
                        element[0].scrollTop = newTop;
                    }
                }

                // search for countries
                var searchValue = '',
                    timer = null;
                function searchForCountry(event){
                    // on esc close
                    if(event.keyCode == 27){
                        scope.$apply(function(){
                            scope.chooseCountry();
                        });
                        return false;
                    }
                    // on return confirm search
                    if(event.keyCode == 13){
                        scope.$apply(function(){
                            scope.chooseCountry(scope.foundCountry);
                        });
                        return false;
                    }

                    // numpad
                    if(event.keyCode >= 96 && event.keyCode <= 105) {
                        searchValue = searchValue + String.fromCharCode(event.keyCode - 48).toLowerCase();
                    // chars and numbers and symbols
                    } else {
                        searchValue = searchValue + String.fromCharCode(event.keyCode).toLowerCase();
                    }

                    var elementFound;
                    // search for chars
                    if(searchValue.search(/^[a-zA-Z]*$/) == 0){
                        elementFound = element[0].querySelector("[cm-country-prefix-shortcut^='"+searchValue+"']")
                    // search for numberprefix
                    } else if(searchValue.search(/^[0-9]*$/) == 0){
                        elementFound = element[0].querySelector("[cm-country-prefix-number^='"+searchValue+"']")
                    }

                    // element found
                    if(elementFound){
                        scrollTo(elementFound);
                        scope.$apply(function(){
                            scope.foundCountry = cmCountryPrefix.getOneByShortcut(elementFound.getAttribute('cm-country-prefix-shortcut'))[0];
                        });
                    }

                    //reset searchValue
                    $timeout.cancel(timer);
                    $timeout(function(){
                        searchValue = '';
                    },1000)
                }

                // detect keyinput
                function initFilter(unbind){
                    if(!unbind){
                        angular.element($window).on('keyup', searchForCountry);
                    } else {
                        angular.element($window).off('keyup', searchForCountry);
                    }
                }

                function clickOutside(e){
                    if(e.target != element[0] && // target not drtv
                        !cmUtil.findParent('cmCountryPrefixList',e.target) && // isnt list
                        !cmUtil.findParent('cmCountryPrefixHandler',e.target) // isnt handler
                    ) {
                        toggleList(false);
                        scope.$apply(function() {
                            scope.chooseCountry();
                        });
                    }
                }

                function toggleList(visibility, activeCountry){
                    scope.activeListCountry = activeCountry || {};

                    if(visibility) {
                        element.addClass('is-visible');
                        angular.element($window).on('click',clickOutside);
                        angular.element($window).on('touchstart',clickOutside);
                        initFilter();
                        // be sure active is setted
                        $timeout(function () {
                            scrollTo();
                        }, 50);
                        // reset list
                    } else {
                        element.removeClass('is-visible');
                        angular.element($window).off('click',clickOutside);
                        angular.element($window).off('touchstart',clickOutside);
                        initFilter(true);
                        scope.foundCountry = {};
                    }
                }

                // event handling for toggle list click outside
                var killWatcher = scope.$on('cmCountryPrefixList:toggle', function(event, visibility, activeCountry){
                    toggleList(visibility, activeCountry);
                });

                scope.$on('$destroy', function(){
                    angular.element($window).off('keyup', searchForCountry);
                    angular.element($window).off('click',clickOutside);
                    angular.element($window).off('touchstart',clickOutside);
                    killWatcher();
                });
            }
        }
    }
])

.service('cmCountryPrefix', [
    'cmObject', 'cmConfig',
    '$http', '$q',
    function(cmObject, cmConfig,
             $http, $q){

        var self = {
            countries: [],
            ready: false,
            handleView: function(scope){

                scope.prefixHandler = {
                    isVisible: false
                };

                // add to ngModelOut the prefix
                scope.$on('cmCountryPrefixHandler:set',function(event, country){
                    if(country && scope.ngModel && scope.ngModel != '') {
                        scope.ngModelOut = country.numberPrefix + scope.ngModel;
                    } else {
                        scope.ngModelOut = '';
                    }
                });

                // check if already have a prefix
                scope.$watch('ngModel', function(data){
                    // check if country chooser is visible
                    // if phoneNumber hasn't +49
                    // or undefined
                    // after choose and enter merge country and number together
                    if(!data || data && (data != '' && data.indexOf('+') == -1 || data == '')){
                        scope.prefixHandler.isVisible = true;

                        var correctData = data;
                        // clear leading zero
                        if (correctData && correctData.indexOf('0') == 0) {
                            while (correctData.charAt(0) === '0')
                                correctData = correctData.substr(1);
                        }
                        // set to model or let it blank
                        if(correctData && correctData != '') {
                            scope.ngModelOut = scope.activeCountry.numberPrefix + correctData;
                        } else {
                            scope.ngModelOut = '';
                        }
                    // phoneNumber already has +49 inside
                    } else {
                        scope.prefixHandler.isVisible = false;
                        scope.ngModelOut = data;
                    }
                });

            },
            loadPrefixes: function(){
                if(self.countries.length > 0){
                    return false;
                }

                // load
                return $http({
                    url: cmConfig.pathToLanguages+'/countryprefix.json',
                    method: 'GET'
                }).then(
                    function(response){
                        if(typeof response.data == 'object') {
                            response.data.forEach(function(rawCountry) {
                                var country = rawCountry.split(',');

                                self.countries.push({
                                    shortcut:country[0],
                                    numberPrefix:'+'+country[1],
                                    numberPrefixRaw:country[1]
                                });
                            });

                            self.ready = true;
                        }
                    },
                    function(response){

                    }
                );
            },
            getDefaultCountry: function(){
                var deferered = $q.defer();

                deferered.resolve({
                    shortcut: 'de',
                    numberPrefix: '+49'
                });

                return deferered.promise;
            },
            getCountries: function(){
                var deferered = $q.defer();

                if(!self.ready){
                    self.loadPrefixes()
                    .then(function(){
                        deferered.resolve(self.countries);
                    })
                } else {
                    deferered.resolve(self.countries);
                }

                return deferered.promise;
            },
            getOneByShortcut: function(shortcut){
                if(typeof shortcut != 'string')
                    return [];

                return self.countries.filter(function(country){
                    return shortcut && country.shortcut == shortcut;
                });
            },
            getOneByNumberPrefix: function(numberPrefix){
                if(typeof numberPrefix != 'string' && typeof numberPrefix != 'number')
                    return [];

                return self.countries.filter(function(country){
                    return numberPrefix && country.numberPrefix == numberPrefix
                        || numberPrefix && country.numberPrefixRaw == numberPrefix;
                });
            }
        };

        cmObject.addEventHandlingTo(self);

        return self;
    }
])
.directive('cmAddButton',[
    function(){
        return {
            restrict: 'E',
            template: '<i class="fa with-response cm-{{icon}}"></i>',
            scope: {
                icon: "@cmIcon"
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmAvatar
 * @description
 * Shows the avatar of an identity.
 * It can also be used for an identity avatar placeholder.
 *
 * @restrict E
 * @requires cmIdentityModel
 *
 * @example
     <example module="cmDemo">
         <file name="style.css">
             cm-avatar {display:inline-block;vertical-align:top;width:100px;height:100px}
             cm-avatar img{width:100%;height:100%}
         </file>
         <file name="script.js">
             angular
             .module('cmDemo', ['cmUi'])
             .controller('Ctrl', function ($scope){

                 var simple_cmFileModel = {
                    state:'cached',
                    base64Url:'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QTMwOUMxNTBFQkU5MTFFM0FDOTJEQjIzQjBFNjk1Q0IiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTMwOUMxNEZFQkU5MTFFM0FDOTJEQjIzQjBFNjk1Q0IiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJFODlGRDk2RUE0MTExRTNCQkQ5OThEODZBQTJFNkU5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJFODlGRDk3RUE0MTExRTNCQkQ5OThEODZBQTJFNkU5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+As8xUwAABIRJREFUeNrEV1trXFUYXecyczKTTDKZZKZpmWZSR3shsUotVdFCFFEppdIKivrshT6UPlRfvIDQ/2AfqlYQFKFCxFIURCkWQZoKvaaWprG5dBLTmenkMvdzXHufyWQOmVsJJns4cy57n72+b+1vffs7ivrLpTEAAR5FrE3TeMR1/kWw9s2n8i+5DsBJFevUagJbPEzTgrlmwIoCM1+EtZiFJnotSz6rZlhTTcxXNOmE6ZhHXTFoLo2QW8fJ3VGcfawPG3lt5grLgGJMNg9LPFOVhrgWAQNuEcOKvF4JLCacz2Cwx48LT21FjAZ8OZXAS10+oFC0+3m2EvPYG+zAq5sCsDL5xsA08pVgOz7sC0oWrZLXZWDhVajNwK97HsGnt6fx0fkRTGQL9oBUGmZygUo3cWxHGOfIxj4aZGVyzXCNSYIfj/Yg4PPCytvs6eV+TvLuVlvSn0/FKXMNR3u7kSE9xsBmFGjpkUgQAz6PHPNDfI5mq441t2iYoF+tjIliEfMFe31f2+jHiZFJqthjAy8FysMtLnn+bHsYv5HOQ6EOef9mT6fDhx//TWHo9gyUVkM4BFNMkKb3hgstjMicaZXjAQzUfd0+ef8kAU+IJVuiWtpH688nF+WA98Jd+JaBVWfl0OLSYBHMTHOd4/M4xHdGn9lO4912MNJzizFjdHjJXFC+FWEfdE0qZZkrTnTqbgLpYmPl7icbN55/FJG2FmxixB5/fAtO09AtHjful943F7IS4OyuKFo1G8anq2Ul2FSLa1r5xuZuSVUzrZe0/j04AIW0ukqT3WTUjlMNIKjudePM0zvwXGdr+Z17pF0EqHBStbVmSQqOElh5gOzjFkRVaPnwyISkfTAcwJXBfrwYaHOMv0zqxZorXGc7qnnTSdr6eTTT/qJXXbS6V6xZRTsc7sYnkRD2dvmqvncqlpTeKmU5cS28muKwvla7Q9ntGvoTLkZ67oWdjr6DJRVUa9/N3MfVWAJKSY42MGmOMUJnRBJx63WBOzj2AJPItnZvzc1lOLWIgEvHQx6bkTHO/dbFUSk3QbNwVKIoDKgi6fuKFr1fCv16wENPROvkKRG9Gr5mEvJz3h4ux5GbUygw3apiKUsaX9YxB3x8fYJpMr/qLW+b18CxvhD66PE300lMM+FUgjpytWroyDLI9jBHX1vIrBrcS28PbPAjLXOE7gB17k7sEFbdpRb7z13DyfHZVYOfpqc/jZVSa91CoAQuEvrbw6PYf+EWLs+l606e5Ts5c2VZcJE72uvDt5YDqmEFIsA5GO0enJm8h52/X8c7V+7gUqq6AQYlmGI2+nl2DjFKbZbK+GIyjt1/3ODGZEIVG4+10jCFdXWCZ3/NskUUAaQflNnL1OnBkB/PMg1GmRIV/sYJ9j0D6IORKQ5RuZwaFsR4XksHzKpFUrI+sKNuogFiJxLW04sNVIFgMCaqEKEEw1VmTOQFuVXXLsySelNRIrYxMRODRO49pHBaeCW/C/ic8lErvxOaqAb1B41UdQlMW11Jrjak+f9pfuHxP+vx0fafAAMAUiCx0ClOvYEAAAAASUVORK5CYII='
                 };

                 var simple_cmIdentityModel = {
                    displayName: 'meoper',
                    on: function(){},
                    isAppOwner: false,
                    getAvatar: function(){
                        return simple_cmFileModel
                    },
                    getDisplayName: function(){
                        return this.displayName;
                    }
                 };

                 // simple cmIdentityModels
                 $scope.simple_cmIdentityModel_1 = angular.extend({}, simple_cmIdentityModel);
             });
         </file>
         <file name="index.html">
             <div ng-controller="Ctrl">
                 <h2>unknown / default avatar</h2>
                 <cm-avatar cm-avatar-view="unknown"></cm-avatar>

                 <h2>cmIdentity avatar</h2>
                 <cm-avatar cm-data="simple_cmIdentityModel_1"></cm-avatar>
                 {{simple_cmIdentityModel_1}}
             </div>
         </file>
     </example>
 */


.directive('cmAvatar',[
    'cmUserModel', 'cmUtil', 'cmConfig',
    function (cmUserModel, cmUtil, cmConfig){

        return {
            restrict: 'E',
            scope: {
                identity: "=cmData"
            },
            template: '<div class="wrap"><i></i></div>',
            link: function(scope, element, attrs){

                function refresh(){
                    /**
                     * without scale
                     */
                    //element.find('img').attr('src', cmConfig.restApi + '/file/' + scope.identity.avatarId + '/raw?token=' + cmUserModel.getToken());

                    /**
                     * with scale
                     */
                    var size = 200;
                    if('cmSize' in attrs && cmUtil.validateInt(attrs.cmSize)){
                        size = attrs.cmSize;
                    }

                    var imgSrc = cmConfig.restApi + cmConfig.defaultApiVersion + '/file/' + scope.identity.avatarId + '/scale/' + size + '?token=' + cmUserModel.getToken(),
                        bgImg = new Image();
                    // preload for update avatar
                    bgImg.onload = function(){
                        scope.identity.trigger('avatar:loaded');
                    };
                    bgImg.src = imgSrc;
                    angular.element(element[0].querySelector('.wrap i')).css('background-image','url('+imgSrc+')');
                }

                // is unknown avatar for add reciepients or choose avatar
                if('cmAvatarView' in attrs && attrs.cmAvatarView == 'unknown'){
                    element.find('i').addClass('fa cm-person');
                } else {
                    scope.$watch('identity',function(){
                        if(typeof scope.identity == 'object'
                        && cmUtil.objLen(scope.identity) > 0
                        && typeof scope.identity.state == 'object'
                        && typeof scope.identity.state.is == 'function'){
                            scope.identity.on('update:finished',function(){
                                refresh();
                            });

                            refresh();
                        }
                    });
                }
            }
        }
    }
])
.directive('cmBack',[
    'cmHistory',
    '$rootScope',
    function (cmHistory,
              $rootScope){
        return {
            restrict: 'AE',
            scope: {
                pageTitle: '=pageTitle'
            },
            template: '<div class="back-wrap" ng-click="goBack()" cm-reactive>'+
                        '<i class="fa with-response cm-left" ng-show="isVisible"></i>'+
                        '<span ng-if="pageTitle">{{pageTitle | cmTranslate}}</span>'+
                      '</div>',
            controller: function($scope, $element, $attrs){
                // vars
                $scope.isVisible = !cmHistory.isEmpty() ? true : false;
                //$scope.pageTitle = $attrs.pageTitle;
                $scope.fakeBack = '';
                // check default back-to attribute
                if('backTo' in $attrs){
                    $scope.backTo = $attrs.backTo;
                    $scope.isVisible = true;
                }

                $scope.goBack = function(){
                    // if history has more then one index
                    if(!cmHistory.isEmpty() && ('plainBack' in $attrs) == false){
                        $rootScope.goBack();
                        // if is set an default path in route
                        return false;
                    }

                    if($scope.backTo != ''){
                        $rootScope.goTo($scope.backTo);
                        return false;
                    }
                }
            }
        }
    }
])

.directive('cmBackground', [
    '$route',
    function ($route){
        return {
            restrict: 'A',
            controller: function($scope, $element){
                $scope.$on('$locationChangeSuccess', function() {
                    if($route.current != undefined && $route.current.$$route != undefined){
                        if($route.current.$$route.isDefault){
                            $element.addClass('start-page');
                        } else {
                            $element.removeClass('start-page');
                        }
                    }
                });
            }
        }
    }
])

.directive('cmBindTemplate',[

    '$compile',

    function cmBindTemplate($compile){
        return {
            restrict:       'A',

            link:       function(scope, element, attrs){

                            if(attrs.replace){
                                element.replaceWith( $compile(scope.$eval(attrs.cmBindTemplate))(scope) )
                            }else{
                                element.append($compile('<div>'+ scope.$eval(attrs.cmBindTemplate) +'</div>')(scope) )
                            }

                        }
        }
    }
])
.directive('cmClipboard',[
    function (){
        return{
            restrict: 'A',
            link: function(scope, element){
                element.on('focus',function(){
                    element[0].select();

                    // Work around Chrome's little problem
                    element[0].onmouseup = function() {
                        // Prevent further mouseup intervention
                        element[0].onmouseup = null;
                        return false;
                    };
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmDateSeperator
 * @description
 * Especially for Timestamp to seperate messages in days.
 *
 * @restrict E
 * @requires cmUi.directive:cmRubberSpace
 *
 * @example
 <example module="cmDemo">
    <file name="style.css">
        cm-date-seperator {display:block}
        cm-date-seperator .date-seperator{position:relative}
        cm-date-seperator .date-seperator div{display:inline-block}
        cm-date-seperator .date{color:#fff;background:#000;text-align:center}
        cm-date-seperator .line{background:#000;height:1px;vertical-align:middle}
    </file>
    <file name="script.js">
        
        .controller('Ctrl', function ($scope) {
            var now = new Date().getTime();
            $scope.timestamp = now;
        });
    </file>
    <file name="index.html">
        <div ng-controller="Ctrl">
            <cm-date-seperator cm-timestamp="timestamp-timestamp+1"></cm-date-seperator>
            message 1234
            <cm-date-seperator cm-timestamp="timestamp"></cm-date-seperator>
            message 5678
            <cm-date-seperator cm-timestamp="timestamp+timestamp"></cm-date-seperator>
        </div>
    </file>
 </example>
 */

.directive('cmDateSeperator',[
    'cmUtil',
    function (cmUtil){
        return{
            restrict: 'E',
            scope: {
                timestampCurrent: '=cmTimestamp',
                timestampPrev: '=cmTimestampPrev'
            },
            template: //'{{"current: "+timestampCurrent+" prev: "+timestampPrev}}'+
                      '<div ng-if="compareDate()" class="date-seperator" cm-rubber-space>'+
                        '<div class="line" cm-weight="1"></div>'+
                        '<div class="date" cm-weight="3">'+
                          '<cm-time-converter cm-timestamp="timestampCurrent" cm-special-type="date-seperator"></cm-time-converter>'+
                        '</div>'+
                        '<div class="line" cm-weight="1"></div>'+
                      '</div>',
            controller: function($scope, $element){
                /**
                 * compare date for date-seperator
                 * @param currentDate
                 * @param prevDate
                 * @returns {boolean}
                 */

                $scope.compareDate = function() {
                    return !$scope.timestampPrev || cmUtil.compareDate($scope.timestampCurrent, $scope.timestampPrev);
                };
            }
        }
    }
])

.directive('cmDefaultButtons',[

    'cmConfig',
    '$location',

    function (cmConfig, $location){
        return {
            restrict: 'E',
            transclude: true,
            scope: true,
            priority: 0,
            replace: true,
            template:   '<a ' +
                            'ng-repeat="btn in Object.keys(btns)" ' +
                            'href="#/{{btn}}" ' +
                            'class="btn-footer" ' +
                            'cm-weight="1" ' +
                            'cm-rubber-space-repeat ' +
                            'ng-class="{active:btns[btn].isActive}">' +
                            '<i ng-if="btns[btn].icon" class="fa {{btns[btn].icon}}"></i>' +
                            '{{btns[btn].i18n|cmTranslate}}' +
                        '</a>',

            link: function(scope, element, attrs){
                scope.btns = {};
                scope.Object = Object;                

                scope.btns = cmConfig.footer || {};

                // set active & width
                var btns = Object.keys(scope.btns);

                angular.forEach(btns, function (btnHref) {
                    var btn = scope.btns[btnHref];
                    btn.isActive = btnHref != '' && $location.$$path.search(btnHref) != -1;
                });
            }
        }
    }
])

.directive('cmDefaultPages',[
    '$location',
    function ($location){
        return {
            restrict: 'AE',
            templateUrl: 'comps/ui/drtv-default-pages.html',
            link: function(scope){
                scope.isTalks = true;
                scope.isContacts = false;

                if($location.$$path.search('contact') != -1){
                    scope.isTalks = false;
                    scope.isContacts = true;
                } else if($location.$$path.search('talks') != -1){
                    scope.isTalks = true;
                    scope.isContacts = false;
                }
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmEdge
 * @description
 * For create conversation, new contact or add recipient.<br/>
 * Works with CameoAwesome Glyphs
 *
 * @restrict E
 * @requires cameoAwesome
 *
 * @example
 <example module="cmUi">
    <file name="style.css">
         cm-edge {
          position: relative;
          display: block;
          top: 0;
          right: 0;
          z-index: 1;
          cursor: pointer;
          font-size: 6rem;
          width: 1em;
          height: 1em;
          line-height: 1em;
        }
         cm-edge .background {
          color: #02bed2;
          position: absolute;
          right: 0;
          top: -0.03em;
        }
         cm-edge .foreground{
          color: #ffffff;
          position: absolute;
          right: 0;
          top: 0;
        }
    </file>
    <file name="index.html">
        <link type="text/css" rel="stylesheet" href="../app/css/font-awesome.css"></link>
        <cm-edge></cm-edge>
    </file>
 </example>
 */

.directive('cmEdge',[
    function (){
        return{
            restrict: 'E',
            link: function(scope, element){
                var background = angular.element('<i class="fa cm-edge background"></i>'),
                    foreground = angular.element('<i class="fa cm-edge-add foreground"></i>');

                element
                .append(background)
                .append(foreground);
            }
        }
    }
])

.directive('cmEnter', [
    function() {
        return function(scope, element, attrs) {

            function onEnter(event){
                if(event.keyCode === 13) {
                    scope.$broadcast('cmEnter:pressed');
                    scope.$apply(function(){
                        scope.$eval(attrs.cmEnter, {'event': event});
                    });

                    event.preventDefault();
                }
            }

            element.on('keydown', onEnter);
            element.on('keypress', onEnter);

            scope.$on('$destroy', function(){
                element.off('keydown', onEnter);
                element.off('keypress', onEnter);
            })
        };
    }
])

.directive('cmFirstOfRepeat',[
    function (){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                if(scope.$first){
                    scope.$eval(attrs.cmFirstOfRepeat);
                }
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmFooter
 * @description
 * Footer navigation
 *
 * @restrict E
 * @requires $location
 * @requires cmTranslate
 *
 * @example
 */


.directive('cmFooter',[
    '$rootScope',
    function ($rootScope){
        return {
            restrict: 'E',
            controller: function($scope){
                $rootScope.$broadcast('cmFooter:stateChanged','show');
                $scope.$on('$destroy', function(){
                    $rootScope.$broadcast('cmFooter:stateChanged','hide');
                });
            }
        }
    }
])
.directive('cmHeader',[

    '$window', 

    function ($window){
        return {
            restrict:   'E'

        }
    }
])

.directive('cmHtmlCompile',[
    '$compile', '$parse',
    function($compile, $parse) {
        return {
            link: function (scope, element, attr) {
                var parsed = $parse(attr.ngBindHtml);

                function getStringValue() {
                    return (parsed(scope) || '').toString();
                }

                // Recompile if the template changes
                scope.$watch(getStringValue, function () {
                    $compile(element, null, -9999)(scope);
                    // The -9999 makes it skip directives so that we do not recompile ourselves
                });
            }
        }
    }
])
.directive('cmIcons',[
    function (){
        return {
            restrict:   'AE',
            template:   '',
            scope:      {},

            link: function(scope, element, attrs){
                scope.count = attrs.count
                scope.icons = attrs.icons
                scope.alt   = attrs.alt

                function draw(){
                    // clear all
                    element.children().remove();
                    // draw x
                    if(scope.count == 0 && attrs.alt) {
                        element.append('<i class="fa '+attrs.alt+'"></i>')
                    } else {
                        for (var i = 0; i < scope.count; i++) {
                            element.append('<i class="fa '+scope.icons+'"></i>')
                        }
                    }
                }

                attrs.$observe('icons', function(icons) {
                    scope.icons = attrs.icons
                    draw()
                })

                attrs.$observe('count', function(count) {
                    scope.count = attrs.count
                    draw()
                })
            }

        }
    }
])

.directive('cmImageLoaded', [
    '$parse',
    function($parse){

    return {
        restrict: 'A',
        compile: function($element, attr) {
            var fn = $parse(attr['cmImageLoaded']);

            return function(scope, element, attr) {
                element.on('load', function(event) {
                    scope.$apply(function() {
                        fn(scope, {$event:event});
                    });
                });
            };

        }
    };
}])

.directive('cmInfoBubble',[
    function (){
        return {
            restrict: 'AE',
            transclude: true,

            template: '<div ng-transclude></div>' +
                      '<i class="fa {{nose_icon}}"></i>',

            link: function(scope, element, attrs){
                scope.nose_icon = 'cm-nose-up';

                if(attrs.nosePos == 'bottom')
                    scope.nose_icon = 'cm-nose-down';

                element.toggleClass('up',   scope.nose_icon == 'cm-nose-up');
                element.toggleClass('down', scope.nose_icon == 'cm-nose-down');

                element.children('i.').css({
                    top     : attrs.nosePos == 'bottom' ? 'auto': '-3.5rem',
                    bottom  : attrs.nosePos == 'bottom' ? '-1em' : 'auto',
                    left    : attrs.noseX || '70%'
                });
            }
        }
    }
])
.directive('cmInputWatcher',[
    function(){
        return {
            restrict: 'A',

            link: function(scope, element){
                element.find('input').on('focus',function(){
                    element.addClass('isActive');
                }).on('blur',function(){
                    element.removeClass('isActive');
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:input
 * @description
 * a drtv for all input-tags
 * every input with attr name and ng-model get registred at cmPristine service
 *
 * @restrict A
 * @requires cmPristine
 * @requires $rootScope
 * @requires $timeout
 *
 * @example
 <example module="cmDemo">
 <file name="index.html">
 <article class="content">
     <div class="cm-input-ctn">
        <input type="text" value="whoop whoop" />
     </div>
 </article>

 <article class="content">
     <div class="cm-input-ctn with-inside-icon">
         <input type="text" value="whoop whoop" />
         <i class="fa cm-write"></i>
     </div>
 </article>

 <article class="content">
     <div class="cm-input-ctn with-inside-icons">
         <input type="text" value="whoop whoop" />
         <i class="fa cm-rhino-bubble-glyph"></i>
         <i class="fa cm-write"></i>
     </div>
 </article>

 <article class="content">
     <div class="cm-input-ctn with-inside-left-icon">
         <i class="fa cm-checker"></i>
         <input type="text" value="whoop whoop" />
     </div>
 </article>

 <article class="content">
     <div class="cm-input-ctn with-inside-left-icons">
         <i class="fa cm-checker"></i>
         <i class="fa cm-checkbox-wrong"></i>
         <input type="text" value="whoop whoop" />
     </div>
 </article>

 <article class="content">
     <div class="cm-input-ctn with-inside-left-icon with-inside-icon">
         <i class="fa cm-checker"></i>
         <input type="text" value="whoop whoop" />
         <i class="fa cm-checkbox-wrong"></i>
     </div>
 </article>

 <article class="content">
     <div class="cm-input-ctn with-inside-left-icons with-inside-icons">
         <i class="fa cm-checker"></i>
         <i class="fa cm-checker"></i>
         <input type="text" value="whoop whoop" />
         <i class="fa cm-checkbox-wrong"></i>
         <i class="fa cm-checkbox-wrong"></i>
     </div>
 </article>

 </file>
 </example>
 */


.directive('input', [
    'cmPristine',
    '$rootScope', '$timeout',
    function (cmPristine,
              $rootScope, $timeout) {
        return {
            restrict: 'EA',
            require: '?ngModel',
            link: function (scope, element, attrs, ngModel) {
                if (!ngModel || 'cmPristineIgnore' in attrs || 'type' in attrs && attrs.type == 'hidden')
                    return; // do nothing if no ng-model

                // old simple style
                //function callback_pristine(){
                //    $rootScope.$broadcast('pristine:false');
                //    $rootScope.$apply();
                //}
                //element.on('keydown',callback_pristine);
                //
                //scope.$on('$destroy',function(){
                //    element.off('click',callback_pristine);
                //});

                var timeout,
                    initValue;

                function broadcastPristine(bool){
                    if(bool){
                        cmPristine.set(ngModel, true);
                    } else {
                        cmPristine.set(ngModel, false);
                    }
                }

                function getValue(){
                    return element.val().trim() || '';
                }

                function setValue(){
                    ngModel.$setViewValue(getValue());
                    ngModel.$commitViewValue();
                }

                function handleChange(event, forceSet){
                    // check defaultValue
                    if(initValue == undefined) {
                        reinit();
                    }

                    // call service if input is pristine
                    if(initValue != getValue()){
                        broadcastPristine();
                    } else if(initValue == getValue()){
                        broadcastPristine(true);
                    }

                    // handle adaptive change
                    if('cmAdaptiveChange' in attrs && !forceSet){
                        $timeout.cancel(timeout);
                        timeout = $timeout(function(){
                            setValue()
                        },attrs.cmAdaptiveChange || 1000);
                    } else {
                        setValue();
                    }
                }

                // register at service
                cmPristine.add(ngModel);

                // on init or after submit
                function reinit(){
                    initValue = getValue();
                }
                cmPristine.on('reinit', reinit);

                // watch on element
                element
                    .unbind('input')
                    .unbind('keydown')
                    .on('focus', handleChange)
                    .on('keyup', handleChange)
                    .on('blur', handleChange);

                if('cmEnter' in attrs){
                    var killWatcher = scope.$on('cmEnter:pressed', function(){
                        handleChange({},true);
                    });
                }

                scope.$on('$destroy', function(){
                    element
                        .off('focus', handleChange)
                        .off('keyup', handleChange)
                        .off('blur', handleChange);

                    cmPristine.remove(ngModel);

                    cmPristine.off('reinit', reinit);

                    if(killWatcher)
                        killWatcher();
                });
            }
        }
    }
])
.directive('cmLargeInput',[
    function(){
        return {
            restrict: 'A',

            link: function(scope, element, attrs){
                var outer_wrapper = angular.element('<div></div>').addClass('cm-form-group'),
                    inner_wrapper = angular.element('<div></div>').addClass('cm-form-control white-control with-inputter with-outside-icon'),
                    icon          = angular.element('<i></i>').addClass('fa').addClass(attrs.cmIcon)

                element.wrap(outer_wrapper)
                element.after(icon)
                element.wrap(inner_wrapper)
                element.attr('data-qa','input-search')
            }
        }
    }
])

.directive('cmLastFocus',[
    '$rootScope',
    function($rootScope){
        return {
            restrict: 'A',
            link: function(scope, element){
                function setLastFocus(){
                    $rootScope.lastFocus = this;
                }

                element
                    .on('focus', setLastFocus)

                scope.$on('$destroy', function() {
                    element
                        .off('focus', setLastFocus)
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmLoader
 *
 * @description
 * shows default a spinner and with attr
 * http://fgnass.github.io/spin.js/
 *
 */


.directive('cmLoader',[
    function (){
        return {
            restrict:   'AE',
            template:   function(element, attrs){
                            return  {
                                        'spinner'   :   '<div class="spinner-wrapper"><div class="spinner"></div></div>',
                                        'balls'     :   '<div class="followingBallsWrapper halt">'+
                                                            '<div class="G_1 followingBallsG"></div>'+
                                                            '<div class="G_2 followingBallsG"></div>'+
                                                            '<div class="G_3 followingBallsG"></div>'+
                                                            '<div class="G_4 followingBallsG"></div>'+
                                                        '</div>'
                                    }[attrs.type || 'spinner']
                        },
            scope: true,
            controller: function($scope, $element, $attrs){
                var type = $attrs.type || 'spinner';

                $element.addClass(type);

                var opts = {};
                if($attrs.cmColor) {

                    switch($attrs.cmColor){
                        case 'ci-color':
                            opts.color = '#02BED2';
                        break;
                        case 'inp-grey':
                            opts.color = '#666666';
                        break;
                        default:
                            opts.color = $attrs.cmColor;
                    }
                }

                // spinner size
                if($attrs.cmSize == 'small') {
                    opts.lines = 10;
                    opts.length = 4;
                    opts.width = 4;
                    opts.radius = 6;
                }

                if(type =='spinner'){
                    var spinner = new Spinner(opts);
                    var loadingContainer = angular.element($element[0].querySelector('.spinner'))[0];
                }

                $scope.animate = function(start){
                    if(start == undefined) start = true

                    if(type == 'spinner'){
                        if(start){
                            spinner = spinner.spin()
                            loadingContainer.appendChild(spinner.el);
                        } else {
                            spinner.stop()
                            loadingContainer.innerHTML = '';
                        }
                    }

                    if(type == 'balls'){
                        if(start){
                            $element.children().removeClass('halt')
                        }else{
                            $element.children().addClass('halt')
                        }
                    }
                };

                $scope.$watch($attrs.ngShow, function(bool){
                    if(bool != false){
                        $scope.animate(true);
                        $element.attr('cm-count', parseInt($element.attr('cm-count') || 0)+1)
                    } else {
                        $scope.animate(false);
                    }
                });

                $scope.$watch($attrs.cmHalt, function(bool){
                    if(bool != false){
                        $scope.animate(true);
                    } else {
                        $scope.animate(false);
                    }
                });

                /**
                 * @ngdoc event
                 * @name start
                 * @eventOf cmUi.directive:cmLoader
                 * @description
                 * $scope.$on('cmLoader:start',...)
                 */
                $scope.$on('cmLoader:start', function(){
                    $scope.animate(true);
                });

                /**
                 * @ngdoc event
                 * @name stop
                 * @eventOf cmUi.directive:cmLoader
                 * @description
                 * $scope.$on('cmLoader:stop',...)
                 */
                $scope.$on('cmLoader:stop', function(){
                    $scope.animate(false);
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmLogo
 * @description
 * Our logo with glyphs
 *
 * @example
 <example module="cmUi">
     <file name="style.css">
        cm-logo{display:block;font-size:40px}
     </file>
     <file name="index.html">
        <link type="text/css" rel="stylesheet" href="../app/css/font-awesome.css"></link>
         <cm-logo></cm-logo>
     </file>
 </example>
 */


.directive('cmLogo',[
    function (){
        return {
            restrict: 'AE',
            template:
            //'<i class="fa cm-logo"></i>'+
                '<i class="fa cm-logo-c"></i>'+
                '<i class="fa cm-logo-a"></i>'+
                '<i class="fa cm-logo-m"></i>'+
                '<i class="fa cm-logo-e"></i>'+
                '<i class="fa cm-logo-o"></i>'+
                '<span class="net-wrap"><i class="fa cm-logo-net"></i></span>'
        }
    }
])

.directive('cmModelToLowercase',[
    function(){
        return {
            require: 'ngModel',
            link: function(scope, element, attrs, modelCtrl) {
                modelCtrl.$parsers.push(function (inputValue) {
                    var transformedInput = inputValue.toLowerCase();

                    if (transformedInput!=inputValue) {
                        modelCtrl.$setViewValue(transformedInput);
                        modelCtrl.$render();
                    }

                    return transformedInput;
                });
            }
        };
    }
])
.directive('cmMultiInput',[
    '$rootScope', '$compile',
    function ($rootScope, $compile){
        return {
            restrict: 'AE',
            scope: true,
            transclude: true,
            priority: 101,

            //template: '<div ng-repeat="item in collection" class="cm-multi-input-wrap">' +
            //            '<div ng-transclude ng-keyup="showMultiplier()"></div>'+
            //            '<div class="cm-multiplier" ng-click="multiply()" ng-show="isMultiplyable">'+
            //                '<i class="fa cm-checkbox-bg"></i>'+
            //                '<i class="fa cm-checkbox-add"></i>'+
            //            '</div>'+
            //          '</div>',

            link: function(scope, element, attrs, ctrl, transclude) {
                transclude(scope, function(clone) {
                    var template = angular.element(
                        '<div ng-repeat="item in collection" class="cm-multi-input-wrap"></div>'
                    );
                    template.append(clone);
                    element.empty();
                    element.append($compile(template)(scope));
                });
            },

            controller: function ($scope, $element, $attrs) {
                $scope.collection = [];
                $scope.isMultiplyable = false;

                $scope.$watchCollection($attrs.cmCollection,function(collection) {
                    if(collection != undefined) {
                        $scope.collection = collection;
                        $scope.showMultiplier();
                    }
                });

                $rootScope.$on('multi-input:changed', function(ngModel){
                    $scope.showMultiplier();
                });

                $scope.showMultiplier = function(){
                    var isDisabled = $scope.$eval($attrs.cmDisabled) || false;
                    var last = $scope.collection.length-1;

                    if(isDisabled == false && last > -1 && $scope.collection[last].value != ''){
                        $scope.isMultiplyable = true;
                    } else {
                        $scope.isMultiplyable = false;
                    }
                };

                $scope.multiply = function(){
                    var last = $scope.collection.length-1;
                    // check last item if filled
                    if($scope.collection[last].value != ''){
                        $scope.collection.push({value:''});
                    }
                };
            }
        }
    }
])

.directive('ngRepeatFinished', function ($timeout) {
    return {
        restrict: 'A',
        link: function (scope) {
            if (scope.$last === true) {
                $timeout(function () {
                    scope.$emit('ngRepeatFinished');
                });
            }
        }
    }
})
.directive('cmOverlay',[
    '$rootScope',
    function ($rootScope){
        return {
            restrict : 'AE',
            scope: true,
            transclude : true,

            link : function(scope, element, attrs, controller, transclude){
                var container = angular.element('<div class="container" ng-transclude></div>'),
                    bg = angular.element('<div cm-transparent-bg ng-click="hideOverlay()"></div>');

                element.append(bg);
                element.append(container);

                function show(){
                    angular.element(document.getElementById('cm-app')).append(element);

                    transclude(scope, function(clone){
                        container.append(clone);
                    });
                    element.addClass('visible');
                }

                function hide(){
                    element.removeClass('visible');
                    container.children().remove();
                }

                //container.on('click', hide)

                $rootScope.$on('cmOverlay:show', function(event, id){ if(attrs.id == id) show() });
                $rootScope.$on('cmOverlay:hide', function(event, id){ if(attrs.id == id) hide() });
            },

            controller: function($scope, $element, $attrs){
                $scope.hideOverlay = function(){
                    $scope.$emit('cmOverlay:hide', $attrs.id);
                }
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmProgressbar
 * @description
 * Handle a percentage of anything.
 *
 * @restrict E
 * @example
<example module="cmDemo">
    <file name="style.css">
         cm-progressbar {
          display: block;
          width: 100%;
          min-height: 4rem;
        }
         cm-progressbar .percent {
          font-size: 2rem;
          text-align: center;
          color: #02bed2;
          line-height: 4rem;
        }
         cm-progressbar .percent span {
          display: inline-block;
          font-size: 1.2rem;
        }
         cm-progressbar .progressbar {
          height: 0.1em;
          background: #02bed2;
        }
    </file>
    <file name="script.js">
        
        .controller('Ctrl', function ($scope) {
            $scope.percent = 0;
            $scope.percentHundretTimes = 0;

            $scope.setPercent = function(percent){
                $scope.percent = percent/100;
                $scope.percentHundretTimes = percent;
            }
        });
    </file>
    <file name="index.html">
        <div ng-controller="Ctrl">
            <button ng-click="setPercent(0)">0%</button>
            <button ng-click="setPercent(15)">15%</button>
            <button ng-click="setPercent(30)">30%</button>
            <button ng-click="setPercent(45)">45%</button>
            <button ng-click="setPercent(60)">60%</button>
            <button ng-click="setPercent(75)">75%</button>
            <button ng-click="setPercent(90)">90%</button>
            <button ng-click="setPercent(100)">100%</button>
            <button ng-click="setPercent(120)">120%</button>
            <br />

            percentHundretTimes: {{percentHundretTimes}}
            <cm-progressbar cm-percent="percentHundretTimes" cm-hundret-times="true"></cm-progressbar>

            percent: {{percent}}
            <cm-progressbar cm-percent="percent"></cm-progressbar>
        </div>
    </file>
</example>
 */

.directive('cmProgressbar',[
    function (){
        return {
            restrict: 'E',
            template: '<div class="percent">{{cmPercent}}<span>%</span></div>' +
                      '<div class="progressbar" style="width:{{cmPercent}}%"></div>',
            controller: function($scope, $element, $attrs) {
                $scope.cmPercent = 0;

                if($attrs.cmPercent){
                    $scope.$watch($attrs.cmPercent, function (newPercent) {
                        // default multiply hundret times
                        if($attrs.cmHundretTimes == undefined){
                            newPercent = newPercent * 100;
                        }

                        // for whatever reason percent over 100%
                        if(newPercent > 100) {
                            newPercent = 100;
                        }

                        $scope.cmPercent = newPercent ? Math.round(newPercent) : 0;
                    })
                }
            }
        }
    }
])
.directive('cmReactive',[
    'cmDevice',
    '$rootScope', '$timeout',
    function (cmDevice,
              $rootScope, $timeout){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){

                // is disabled
                if('cmReactive' in attrs && attrs.cmReactive != '') {
                    attrs.$observe(
                        'cmReactive',
                        function(value) {
                            var isDisabled = scope.$eval(value);
                            if(isDisabled) {
                                element.addClass('cm-reactive-disabled');
                            } else {
                                element.removeClass('cm-reactive-disabled');
                            }
                        }
                    );
                }

                if(cmDevice.isMobile()){
                    var killWatcher = $rootScope.$on('$routeChangeStart',function(e, next){
                        next.resolve = angular.extend( next.resolve || {}, {
                            animation: function(){
                                return $timeout(function () {
                                    // only do the animation
                                }, 260)
                            }
                        });
                    });

                    scope.$on('$destroy', function(){
                        killWatcher();
                    });

                    return false;
                }

                $rootScope.$on('$routeChangeSuccess',function(){
                    element.removeClass('is-hover');
                });

                element.on('mouseenter', function(){
                    element.addClass('is-hover');
                });

                element.on('mouseleave', function(){
                    element.removeClass('is-hover');
                });

                scope.$on('$destroy', function(){
                    element.off('mouseleave');
                    element.off('mouseenter');
                    element.removeClass('is-hover');
                });
            }
        }
    }
])
.directive('cmReload',[
    '$route',
    function ($route){
        return {
            restrict: 'AE',
            scope: true,
            template: '<i class="fa cm-change"></i>',
            controller: function($scope, $element){
                $element.on('click',function(){
                    //$route.reload();
                    location.reload();
                });
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmUi.directive:cmResizeTextarea
 * @description
 * Max col controleld textarea that resize on user input
 *
 * @restrict A
 * @element textarea
 * @requires $timeout
 *
 * @example
 <example module="cmDemo">
    <file name="style.css">
     textarea[cm-resize-textarea] {
      resize: none;
      word-wrap: break-word;
      transition: 0.05s;
      -moz-transition: 0.05s;
      -webkit-transition: 0.05s;
      -o-transition: 0.05s;
      background-image: none;
      border: solid 0.1rem #cccccc !important;
    }
    </file>
     <file name="script.js">
        
        .controller('Ctrl', function ($scope) {
            $scope.model = 'moep moep';
            $scope.modelLong = 'moep moep mopeppppppppppppppppppppppppppppppefpepfp ppfepfpepfpefpp dp sdpfpsdpfpsd fpspdfp';
        });
     </file>
     <file name="index.html">
         <div ng-controller="Ctrl">
            default:<br />
            <textarea cm-resize-textarea ng-model="model"></textarea>
            <br />
            max rows 4:<br />
            <textarea cm-resize-textarea ng-model="modelLong" cm-max-rows="4"></textarea>
         </div>
     </file>
 </example>
 */


.directive('cmResizeTextarea',[
    '$timeout', '$rootScope',
    function ($timeout, $rootScope) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                // vars
                var paddingLeft, paddingRight,
                    maxRows = attrs.cmMaxRows || 2,
                    shadowRowHeight = 0,
                    textAreaRowHeight = 0,
                    diffRowHeight = 0,
                    unit = 'px',
                    shadow = null;

                /**
                 * create shadow of textarea for calcing the rows
                 */
                function createShadow(){

                    var paddginLeft = element.css('paddingLeft'),
                        paddingRight = element.css('paddingRight'),
                        width = element[0].offsetWidth;

                    if(width == 0)
                        width = parseInt(element.css('width'));

                    shadow = angular.element('<div class="textarea-shadow"></div>').css({
                        position: 'fixed',
                        top: -10000+unit,
                        left: -10000+unit,
                        //top: 0,
                        //left: 0,
                        width: width - parseInt(paddingLeft || 0) - parseInt(paddingRight || 0)+unit,
                        'font-size': element.css('fontSize'),
                        'font-family': element.css('fontFamily'),
                        'line-height': element.css('lineHeight'),
                        'word-wrap': 'break-word'
                    });
                    element.after(shadow);
                }

                /**
                 * update for textarea input
                 */
                function update(){

                    if(shadow === null)
                        createShadow();
                    if (shadow === null)
                        return;

                    // replace function for white spaces
                    var times = function(string, number){
                        for (var i = 0, r = ''; i < number; i++) r += string;
                        return r;
                    };
                    // set textarea value to shadow
                    var val = element.val().replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/&/g, '&amp;')
                        .replace(/\n$/, '<br/>&nbsp;')
                        .replace(/\n/g, '<br/>')
                        .replace(/\s{2,}/g, function(space) {
                            return times('&nbsp;', space.length - 1) + ' '
                        });

                    shadow.html(val);

                    // on init get one row height
                    var shadowHeight = shadow[0].offsetHeight,
                        hasNewLines = scope.text ? scope.text.split(/\r\n|\r|\n/g) : [];

                    // on init get one row height
                    if(shadowHeight > 0 && shadowRowHeight == 0 && hasNewLines.length > 0){
                        shadowRowHeight = shadowHeight / hasNewLines.length;
                    } else if(shadowHeight > 0 && shadowRowHeight == 0){
                        shadowRowHeight = shadowHeight;
                        diffRowHeight = textAreaRowHeight-shadowHeight;
                    }

                    // handle textarea height
                    if(shadowRowHeight > 0) {
                        // one line
                        if (shadowHeight < shadowRowHeight) {
                            element.css('height', (shadowRowHeight + diffRowHeight) + unit);
                            element.attr('rows', 1);
                            element.css('overflow', 'hidden');
                        // under max rows
                        } else if (maxRows * shadowRowHeight >= shadowHeight) {
                            element.css('height', (shadowHeight + diffRowHeight) + unit);
                            element.css('overflow', 'hidden');
                            element.attr('rows', Math.round(shadowHeight/shadowRowHeight));
                        // max rows
                        } else {
                            element.css('height', (maxRows * shadowRowHeight + diffRowHeight) + unit);
                            element.css('overflow', 'auto');
                            element.attr('rows', maxRows);
                        }

                        $rootScope.$emit('cmResizeTextarea:resize',element.css('height'));
                    }
                }

                /**
                 * at cursor position inserter
                 * @param el
                 * @param text
                 */
                function insertTextAtCursor(el, text) {
                    var val = el.value, endIndex, range;
                    if (typeof el.selectionStart != 'undefined' && typeof el.selectionEnd != 'undefined') {
                        endIndex = el.selectionEnd;
                        el.value = val.slice(0, el.selectionStart) + text + val.slice(endIndex);
                        el.selectionStart = el.selectionEnd = endIndex + text.length;
                    } else if (typeof document.selection != 'undefined' && typeof document.selection.createRange != 'undefined') {
                        el.focus();
                        range = document.selection.createRange();
                        range.collapse(false);
                        range.text = text;
                        range.select();
                    }
                }

                // style textarea
                element
                    .css({
                        'overflow': 'hidden',
                        'resize': 'none'
                    })
                    .attr('rows',1);

                // find one row height for rows setting
                textAreaRowHeight = parseInt(element.css('height')||0);
                if(textAreaRowHeight == 0)
                    textAreaRowHeight = element[0].offsetHeight;

                // event binding
                element.on('keyup', update);
                element.on('keydown', function(e){
                    // on tab
                    if (e.keyCode == 9) {
                        insertTextAtCursor(this, '\t');
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    return true;
                });

                scope.$on('$destroy', function(){
                    element.off('keydown');
                    element.off('keyup',update);
                });

                // watch on ngModel for extern changes
                scope.$watch(attrs.ngModel,function(newValue){
                    if(newValue != undefined){
                        update();
                    }
                });

                // init first row hack
                element.val('&nbsp;');
                update();
                // clear because one row calced
                element.val('');
                update();
            }
        }
    }
])

.directive('cmRubberSpaceRepeat',[
    '$rootScope',
    function ($rootScope){
        return {
            restrict : 'A',
            link : function(scope) {
                if(scope.$last) {
                    $rootScope.$broadcast('rubberSpace:tighten');
                }
            }
        }
    }
])
.directive('cmRubberSpace',[
    '$rootScope',
    function ($rootScope){
        return {
            restrict : 'A',
            link : function(scope, element, attrs) {

                var className = 'is-rubber-spaced';
                
                // remove text nodes:
                angular.forEach(element[0].childNodes, function (el) {
                    if(el.nodeType == 3) {//nodeType === 8 is <!-- -->
                        angular.element(el).remove();
                    }
                });

                function tighten(){
                    if(element.hasClass(className))
                        return false;

                    // calculate total weight:
                    var available_space = 100,
                        total_weight    = 0,
                        width           = element[0].offsetWidth,
                        children        = [];

                    angular.forEach(element.children(), function(child){ 
                        children.push(angular.element(child));
                    });

                    //substract padding:
                    available_space -= 100*(element.css('paddingLeft')+element.css('paddingRight'))/width;

                    //console.log(element.css('paddingRight'))

                    //substract children's margin:
                    children.forEach(function(child){  
                        available_space -= 100*(child.css('marginLeft')+child.css('marginRight'))/width;
                    });

                    //substract width of element width undefined weight:
                    children.forEach(function(child){                         
                        var weight = parseInt( child.attr('cm-weight')) || false;

                        if(weight){
                            child.weight     =  weight;
                            total_weight     += child.weight;
                        }else{
                            available_space -= 100 * child[0].offsetWidth/width;
                        }
                    });
                    
                    // stretch children according to their weight:
                    children.forEach(function (child) {
                        if (child.weight) {
                            child.css('width', (available_space * child.weight / total_weight) + '%');
                        }
                    });

                    element.addClass(className);

                }

                scope.$watch(function(){
                    tighten();
                });

                $rootScope.$on('rubberSpace:tighten',function(){
                    tighten();
                });
            }
        }
    }
])
.directive('cmScrollTo',[
    'cmLogger', 'cmKeyboard',
    '$timeout', '$rootScope', '$document',
    function (cmLogger, cmKeyboard,
              $timeout, $rootScope, $document){
        return {
            restrict: 'A',
            scope: true,
            controller: function($scope, $element, $attrs){
                $scope.options = angular.extend({},{
                    anchor: undefined, // #id of element
                    force: undefined, // force to top or bottom
                    target: undefined, // other target then html and body where to scroll
                    onEvent: false,// only initalize the rootScope event
                    timeout: 250,
                    addElementsHeight: undefined
                },$scope.$eval($attrs.cmScrollTo)||{});
            },
            link: function(scope, element, attrs){
                if(!scope.options.anchor){
                    cmLogger.warn('drtv cm-scroll-to anchor is empty');
                    return false;
                }

                function initTimeout(where){
                    var anchor = angular.element($document[0].querySelector(scope.options.anchor)),
                        bodyAndHtml = angular.element($document[0].querySelectorAll('body,html')),
                        otherTarget = angular.element($document[0].querySelector(scope.options.target)),
                        extraOffset = 0;

                    // anchor isn't exists yet because of routeChange
                    if(anchor.length == 0) {
                        return false;
                    }

                    // subscract elements height because of overblending
                    if(scope.options.addElementsHeight) {
                        var extraHeight = angular.element($document[0].querySelectorAll(scope.options.addElementsHeight));
                        angular.forEach(extraHeight, function (tag) {
                            extraOffset = tag.offsetHeight;
                        });
                    }

                    $timeout(function(){
                        var position = anchor[0].offsetTop;

                        switch(scope.options.force){
                            case 'bottom':
                                position = position+5000;
                            break;
                            case 'top':
                                position = 0;
                            break;
                        }

                        if(otherTarget.length == 0) {
                            angular.forEach(bodyAndHtml, function (tag) {
                                tag.scrollTop = position - extraOffset;
                            });
                        } else {
                            otherTarget[0].scrollTop = position - extraOffset;
                        }
                    },scope.options.timeout);
                }

                // drtv on create
                if(!scope.options.onEvent) {
                    // drtv in ng-loop
                    if (attrs.ngRepeat && scope.$last) {
                        initTimeout('last');
                    // drtv normal
                    } else if (!attrs.ngRepeat) {
                        initTimeout('no-repeat');
                    }
                // only via event broadcast
                } else {
                    var scrollToEvent = $rootScope.$on('scroll:to',function(){
                        initTimeout('event');
                    });

                    scope.$on('$destroy', function(){
                        scrollToEvent();
                    });
                }
            }
        }
    }
])

.directive('cmSendOnReturn',[
    'cmSettings',
    '$rootScope',
    function (cmSettings,
              $rootScope){
        return {
            restrict: 'A',
            link: function(scope, element){

                function keyDownHandler(event){
                    if(event.keyCode == 13
                    && event.shiftKey == false
                    && cmSettings.is('sendOnReturn')){
                        $rootScope.$broadcast('sendOnReturn');
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                    return true;
                }

                element.on('keydown',keyDownHandler);

                scope.$on('$destroy',function(){
                    element.off('keydown',keyDownHandler);
                });
            }
        }
    }
])
.directive('cmTimeConverter',[
    'cmSettings',
    'cmUtil',
    function (cmSettings, cmUtil){
        return {
            restrict: 'AE',
            scope: {
                timestamp: '=cmTimestamp',
                dateFormat: '=cmDateFormat',
                specialType: '@cmSpecialType'
            },
            template: //'{{"time: "+time +" date: "+format}}'+
                      '<span ng-if="time > 0" class="is-selectable">{{time | date: format}}</span>',
            controller: function($scope){

                function update(){
                    /**
                     * Set Time
                     */
                    if(typeof $scope.timestamp != 'undefined'){
                        var d = new Date(parseInt($scope.timestamp));
                    } else {
                        var d = new Date()
                    }
                    $scope.time = d;

                    /**
                     * Set default Date Format
                     */
                    $scope.format = cmSettings.get('dateFormat') + ' ' + cmSettings.get('timeFormat');
                    if(typeof $scope.dateFormat != 'undefined'){
                        $scope.format = $scope.dateFormat;
                    }

                    switch($scope.specialType){
                        case 'conversation-tag':
                            $scope.format = cmSettings.get('timeFormat');

                            if(cmUtil.compareDate((new Date().getTime()), $scope.time)){
                                $scope.format = cmSettings.get('dateFormat');
                            }
                            break;
                        case 'date-seperator':
                            $scope.format = cmSettings.get('dateFormat');
                            break;
                        default:
                        // date Format does not change
                    }

                    if(typeof $scope.format == 'object'){
                        $scope.format = 'dd.MM.yyyy - HH:mm';
                    }
                }

                $scope.$watch('timestamp',function(){
                    update();
                });

                update();
            }
        }
    }
])
.directive('cmTimeout',[

    'cmUtil',

    function(cmUtil){
        return {
            restrict:   'E',
            scope:      true,
            controller: function($scope, $attrs){
                $scope.cmTimeout = cmUtil.millisecondsToStr(parseInt($scope.$parent.$eval($attrs.cmData || 0)))

                var last_value  =   undefined,
                    interval    =   window.setInterval(function(){
                                        $scope.cmTimeout = cmUtil.millisecondsToStr(parseInt($scope.$parent.$eval($attrs.cmData || 0)))
                                        if(last_value != $scope.cmTimeout){
                                            $scope.$digest()
                                            last_value = $scope.cmTimeout
                                        }
                                    }, 500)

                $scope.$on('$destroy', function(){
                    window.clearInterval(interval)
                })
            }
        }
    }
])
.directive('cmView', [
    'cmUserModel',
    '$injector',
    function (cmUserModel,
              $injector){
        return {
            restrict: 'A',
            controller: function($scope){
                var $route = $injector.get('$route')

                $scope.css = $route.current.$$route.css;

                if(cmUserModel.isGuest() !== false && $route.current.$$route.guests !== true){
                    cmUserModel.doLogout(true,'drtv-view only for guests');
                }
            }
        }
    }
])

.directive('cmEmojiHandler',[
    '$rootScope',
    function($rootScope){
        return{
            restrict: 'E',
            template: '<i class="fa cm-smile-negative with-cursor" ng-click="toggleList()" cm-reactive></i>',
            scope: true,
            controller: function($scope){
                $scope.toggleList = function(){
                    $rootScope.$broadcast('cmEmojiList:toggle');
                };
            }
        }
    }
])

.directive('cmEmojiList',[
    'cmUtil', 'emoji',
    '$window', '$rootScope',
    function (cmUtil, emoji,
              $window, $rootScope) {

        var blacklist = ['poop', 'shit', '\\-1', '\\+1', 'facepunch', 'shipit'],
            sortCategories = {
                'cameo': ['moep'],
                'people': ['smiley', 'hands', 'ape', 'cat', 'faces', 'hearts', 'specials', 'woman', 'unsorted'],
                'symbols': ['lock', 'unsorted'],
                'nature': ['misc', 'pet', 'planets']
            };

        return{
            restrict: 'E',
            template: '<div ng-show="showList">' +
                        '<div ng-repeat="emoji in emojis" class="emoji-wrapper" ng-click="insertEmoji(emoji)" cm-reactive>' +
                            '<i class="emoji emoji_{{emoji}}" title=":{{emoji}}:">{{emoji}}</i>' +
                        '</div>' +
                    '<div>',
            require: '?ngModel',
            link: function(scope, element, attrs, ngModel){
                var textarea;

                function clickOutside(e){
                    if(e.target != element[0] && // target not emojilist
                        !cmUtil.findParent('cmEmojiList',e.target) && // isnt list
                        !cmUtil.findParent('cmEmojiHandler',e.target) // isnt handler
                    ) {
                        scope.toggleList('close',true);
                    }
                }

                function createEmoji(emoji){
                    if(blacklist.indexOf(emoji) == -1) {
                        scope.emojis.push(emoji);
                    }
                }

                scope.emojis = [];

                scope.toggleList = function(action, withApply){
                    scope.showList = action != undefined && action == 'close' || action == undefined && scope.showList ? false : true;

                    if(scope.showList){
                        element.addClass('is-visible');
                        angular.element($window).on('click',clickOutside);
                        angular.element($window).on('touchstart',clickOutside);
                    } else {
                        element.removeClass('is-visible');
                        angular.element($window).off('click',clickOutside);
                        angular.element($window).off('touchstart',clickOutside);
                    }

                    if(withApply != undefined && withApply)
                        scope.$apply();

                };

                scope.insertEmoji = function(emoji){
                    if(textarea != undefined && textarea.length > 0){
                        scope.insertAt(':'+emoji+':');
                    }
                };

                scope.insertAt = function(text){
                    var oldValue = ngModel.$viewValue || '',
                        textStart = textarea[0].selectionStart,
                        textEnd = textarea[0].selectionEnd,
                        insertSymbol = text+' ',
                        strWithEmoticon = oldValue.substring(0, textStart);
                    strWithEmoticon+= cmUtil.endsWith(strWithEmoticon, ' ') ? insertSymbol : ' '+insertSymbol;
                    strWithEmoticon+= oldValue.substring(textEnd);

                    scope.toggleList('close');

                    ngModel.$setViewValue(strWithEmoticon);
                    ngModel.$commitViewValue();
                    ngModel.$render();

                    textarea[0].focus();
                    textarea[0].selectionStart = textEnd+insertSymbol.length;
                    textarea[0].selectionEnd = textEnd+insertSymbol.length;
                };

                // create emojis
                Object.keys(sortCategories).forEach(function(mainCat){
                    sortCategories[mainCat].forEach(function(subCat){
                        emoji.getFromCategory(mainCat, subCat).forEach(function(emoji){
                            createEmoji(emoji);
                        });
                    });
                });

                scope.toggleList('close');

                // emoji-list-handler watcher
                var killWatcher = $rootScope.$on('cmEmojiList:toggle',function(){
                    scope.toggleList();
                });

                // textarea for emoji insertion
                if(attrs.cmTextarea){
                    textarea = angular.element(document.getElementById(attrs.cmTextarea));
                }

                scope.$on('$destroy', function(){
                    killWatcher();
                    angular.element($window).off('click',clickOutside);
                    angular.element($window).off('touchstart',clickOutside);
                });
            }
        }
    }
])
.filter('cmEmoji', [
    '$filter',
    'cmSettings',
    function($filter, cmSettings){

        var convertSmileyToEmoji = [
            {matcher: [':\\)','\\(:','\\^\\^'], emoji:'blush'},
            {matcher: [';\\)','\\(;'], emoji:'wink'},
            {matcher: [':D'], emoji:'smile'},
            {matcher: [':\\*','\\*:'], emoji:'kissing_heart'},
            {matcher: ['<3'], emoji:'heart_eyes'},
            {matcher: ['B\\)'], emoji:'sunglasses'},
            {matcher: [':P',':p'], emoji:'stuck_out_tongue'},
            {matcher: [';P',';p'], emoji:'stuck_out_tongue_winking_eye'},
            {matcher: [':\\('], emoji:'worried'},
            {matcher: [':o '], emoji:'open_mouth'},
            {matcher: [":\\'\\("], emoji:'cry'},
            {matcher: ['\\.!\\.'], emoji:'fu'},
            {matcher: ['o_O','O_o','oO','Oo','o\\.O','O\\.o'], emoji:'flushed'},
            {matcher: ['-_-'], emoji:'expressionless'},
            {matcher: ['\\^_\\^'], emoji:'grin'},
            {matcher: ['\\\\o\/'], emoji:'ghost'}
        ];

        return function (input) {
            var str = '';

            // regular emojis
            str = $filter('emoji')(input.toString());

            // smiley to emoji
            if(cmSettings.is('convertEmoji')) {
                convertSmileyToEmoji.forEach(function (smiley) {
                    var rSmiley = new RegExp(smiley.matcher.join("|"), "g");
                    str = str.toString().replace(rSmiley, function () {
                        return '<i class="emoji emoji_' + smiley.emoji + '" title=":' + smiley.emoji + ':">' + smiley.emoji + '</i>';
                    });
                });
            }

            return str;
        };
    }
])
.factory('cmLoader',[
    function() {
        return function cmLoader($scope){
            $scope.showLoader = false;

            this.start = function(){
                $scope.showLoader = true;
            };

            this.stop = function(){
                $scope.showLoader = false;
            };

            this.isIdle = function(){
                return $scope.showLoader;
            }
        }
    }
])

.directive('cmHeaderListSearch',[
    'cmFilter',
    function (cmFilter){
        return {
            restrict: 'E',
            scope: {
                ngModel: '=ngModel',
                cmOptions: '=cmOptions'
            },
            template: '<i class="fa with-response cm-search"' +
                        ' ng-click="toggleInput($event)"' +
                        ' data-qa="btn-header-list-search" cm-reactive></i>' +
                      '<cm-search-input' +
                        ' ng-model="ngModel"' +
                        ' cm-visible="visible"' +
                        ' cm-options="{hideElements:\'cm-footer\',scrollTo:options.scrollTo}"' +
                        ' ng-class="{visible:visible}"></cm-search-input>',
            controller: function($scope, $element, $attrs){
                // option for drtv
                $scope.options = angular.extend({}, {
                    scrollTo:false
                }, $scope.cmOptions || {});

                $scope.visible = false;
                $scope.toggleInput = function(e){
                    e.stopPropagation();
                    e.preventDefault();
                    $scope.visible = $scope.visible ? false : true;
                    // set focus to input
                    if($scope.visible) {
                        var input = $element[0].querySelector('#inp-list-search');
                        input.focus();
                    } else {
                        /* if visibility is hidden, filter will be cleared */
                        $scope.ngModel = '';
                        cmFilter.clear();
                    }
                };


                if(cmFilter.getSearchVisibility()){
                    $scope.visible = true;
                    var input = $element[0].querySelector('#inp-list-search');
                    input.focus();
                }

                var filter = cmFilter.get();
                if(typeof filter == 'string' && filter != ''){
                    $scope.visible = true;
                    $scope.ngModel = filter;
                } else {
                    if($scope.visible){
                        $scope.ngModel = '';
                    }
                }
            }
        }
    }
])
.directive('cmHideOnFilter',[
    'cmFilter',
    function (cmFilter){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                function updateElement(filter){
                    if(typeof filter == 'string' && filter != ''){
                        if(!element.hasClass('cm-hide')) {
                            element.addClass('cm-hide');
                        }
                    } else {
                        if(element.hasClass('cm-hide')){
                            element.removeClass('cm-hide');
                        }
                    }
                }

                function onClearFilter(){
                    if(element.hasClass('cm-hide')){
                        element.removeClass('cm-hide');
                    }
                }

                cmFilter.onClear('hideOnFilter',onClearFilter);

                var filterListener = scope.$watch(attrs.cmHideOnFilter, function(filter){
                    updateElement(filter);
                });

                scope.$on('$destroy', function(){
                    filterListener();
                });
            }
        }
    }
])
.directive('cmSearchInput',[
    'cmFilter',
    '$document',
    '$rootScope',
    function(cmFilter, $document, $rootScope){
        return {
            restrict: 'E',
            scope: {
                search: '=ngModel',
                cmOptions: '=cmOptions',
                visible: '=cmVisible'
            },
            template:   '<i class="fa cm-left" ng-click="close()" data-qa="btn-close-search"></i>' +
                        '<input data-qa="inp-list-search" id="inp-list-search" name="inp-list-search" type="text" value="" ng-model="search" placeholder="{{placeholder}}">' +
                        '<i data-qa="btn-list-search-clear" class="fa toggle-btn" ng-click="clickToogleBtn()" ng-class="{\'cm-search\':showDefaultIcon && counterKeydown == 0,\'cm-checkbox-wrong\':counterKeydown > 0}"></i>',
            link: function(scope, element, attrs){

                scope.placeholder = attrs.placeholder || '';
                // wrapper events
                element
                .on('focus', function(){
                    scope.counterKeydown = 0;
                })
                .on('keydown', function(){
                    scope.counterKeydown++;
                })
                .on('keyup', function(){
                    cmFilter.set(scope.search);

                    if(scope.search == ''){
                        scope.counterKeydown = 0;
                        scope.$apply();
                    }
                    // on search jump to anchor
                    if(scope.options.scrollTo){
                        $rootScope.$broadcast('scroll:to');
                    }
                });

                if(scope.options.hideElements){
                    var input = angular.element(element[0].querySelector('input')),
                        elementsToHide = angular.element($document[0].querySelectorAll(scope.options.hideElements));

                    input
                    .on('focus', function(){
                        elementsToHide.addClass('ng-hide');
                    })
                    .on('blur', function(){
                        elementsToHide.removeClass('ng-hide');
                    })
                }
            },
            controller: function($scope, $element, $attrs){
                // options for drtv
                $scope.options = angular.extend({}, {
                    withoutSearchIcon:false,
                    hideElements:undefined,
                    scrollTo:undefined
                }, $scope.cmOptions || {});

                $scope.counterKeydown = 0;

                $scope.showDefaultIcon = true;

                if($scope.options.withoutSearchIcon){
                    $scope.showDefaultIcon = false
                }

                $scope.clear = function(){
                    $scope.search = undefined;
                    $scope.counterKeydown = 0;
                    cmFilter.clear();
                };

                $scope.close = function(){
                    $scope.clear();
                    $scope.visible = false;
                };

                $scope.clickToogleBtn = function(){
                    if(angular.element($element[0].querySelector('i.toggle-btn')).hasClass('cm-search')){
                        $scope.close();
                    } else {
                        $scope.clear();
                    }
                }

                var filter = cmFilter.get();
                if(typeof filter == 'string' && filter != ''){
                    $scope.search = filter;
                    $scope.counterKeydown = 1;
                }
            }
        }
    }
])
.directive('cmShowOnFilter',[
    'cmFilter',
    function (cmFilter){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                function updateElement(filter){
                    if(typeof attrs.cmShowOnEmptyList != 'undefined' && cmFilter.getResultLength() > 0){
                        if(element.hasClass('cm-show')){
                            element.removeClass('cm-show');
                        }

                        return false;
                    }

                    if(typeof attrs.cmShowOnMinLength != 'undefined' && typeof filter == 'string' && filter.length < attrs.cmShowOnMinLength){
                        if(element.hasClass('cm-show')){
                            element.removeClass('cm-show');
                        }

                        return false;
                    }

                    if(typeof filter == 'string' && filter != ''){
                        if(!element.hasClass('cm-show')) {
                            element.addClass('cm-show');
                        }
                    } else {
                        if(element.hasClass('cm-show')){
                            element.removeClass('cm-show');
                        }
                    }
                }

                function onClearFilter(){
                    if(element.hasClass('cm-show')){
                        element.removeClass('cm-show');
                    }
                }

                cmFilter.onClear('showOnFilter',onClearFilter);

                var filterListener = scope.$watch(attrs.cmShowOnFilter, function(filter){
                    updateElement(filter);
                });

                scope.$on('$destroy', function(){
                    filterListener();
                });
            }
        }
    }
])
.filter('cmSearch', [
    'cmUtil',
    'cmFilter',
    function(cmUtil,cmFilter){
        return function(arrayToSearch, searchType, searchString){

            if(!arrayToSearch.length || typeof searchString != 'string') return arrayToSearch;

            // clear view if string is empty CAM-1724
            if(typeof searchString == 'string' && searchString == '') return [];


            /**
             * @name isMatch
             * @description
             * try to find a string in a string
             * @param {String} text haystack for match
             * @returns {boolean} if the match was complete
             */
            var isMatch = function(text){
                if(text == undefined) return false;
                var haystack    = String(text).toLowerCase(),
                    needle      = String(searchString).toLowerCase().replace(/^0|\+\d\d/g, '') //ignore leading zeros for phonenumbers

                return haystack.indexOf(needle) > -1;
            };

            /**
             * @name isInArrayMatch
             * @param {Array} array for iteration
             * @param {Function} callback for matching
             * @returns {boolean} if the match was complete
             */
            var isInArrayMatch = function(array, callback){
                var boolean = false;
                if(!cmUtil.isArray(array) || typeof callback != 'function') return false;
                for ( var j = 0; j < array.length; j++) {
                    var item = array[j];
                    if(!boolean){
                        boolean = callback(item);
                    }
                }
                return boolean;
            };

            /**
             * @name search
             * @param {Object} item cmModel of cmFactory
             * @returns {boolean} if the search was complete
             */
            var search = function(item){
                var boolean = false;
                switch (searchType) {
                    case 'contacts':
                        if('contactType' in item && isMatch(item.contactType) ||
                            'identity' in item && isMatch(item.identity.getDisplayName()) ||
                            'identity' in item && isMatch(item.identity.cameoId) ||
                            'identity' in item && isMatch(item.identity.email.value) ||
                            'identity' in item && isMatch(item.identity.phoneNumber.value && item.identity.phoneNumber.value.replace(/^0|\+\d\d/g, ''))
                            )
                            boolean = true;
                        break;
                    case 'talks':
                        if('subject' in item && isMatch(item.subject) ||
                            'messages' in item && isInArrayMatch(item.messages, function(arrayItem){return isMatch(arrayItem.text)}) ||
                            'recipients' in item && isInArrayMatch(item.recipients, function(arrayItem){return isMatch(arrayItem.getDisplayName())})
                            )
                            boolean = true;
                        break;
                }
                return boolean;
            };

            // filter array
            var arrayFiltered = [];
            // iterate all
            for ( var j = 0; j < arrayToSearch.length; j++) {
                var item = arrayToSearch[j];
                if (search(item)) {
                    arrayFiltered.push(item);
                }
            }

            cmFilter.setResultLength(arrayFiltered.length);

            // return filtered array
            return arrayFiltered;
        }
    }
])

.service('cmFilter',[
    'cmLogger',
    '$rootScope',
    function(cmLogger, $rootScope){
        var self = this,
            currentFilter = '',
            currentResults = 0,
            onClearCallbacks = [],
            onUpdateCallbacks = [],
            searchVisibility = false;;

        function reset(){
            //cmLogger.debug('cmFilter reset');

            self.clear();
            onClearCallbacks = [];
            onUpdateCallbacks = [];
        }

        this.clear = function(){
            //cmLogger.debug('cmFilter.clear');

            currentFilter = '';
            currentResults = 0;
            searchVisibility = false;

            onClearCallbacks.forEach(function(obj){
                obj.callback();
            });
        };

        this.get = function(){
            //cmLogger.debug('cmFilter.get');

            return currentFilter;
        };

        this.set = function(f){
            //cmLogger.debug('cmFilter.set');

            if(typeof f == 'string' && f != '' && currentFilter != f){
                currentFilter = f;

                onUpdateCallbacks.forEach(function(obj){
                    obj.callback();
                });
            }
        };

        this.getResultLength = function(){
            //cmLogger.debug('cmFilter.getResultLength');

            return currentResults;
        };

        this.setResultLength = function(l){
            //cmLogger.debug('cmFilter.setResultLength');

            if(typeof l == 'number'){
                currentResults = l;
            }
        };

        this.getSearchVisibility = function(){
            return searchVisibility;
        };

        this.setSearchVisibility = function(bool){
            if(bool && bool === true){
                searchVisibility = true;
            }
        };

        this.onUpdate = function(identifer,callback){
            //cmLogger.debug('cmFilter.onUpdate');

            if(typeof identifer == 'string' && identifer.length > 0 && typeof callback == 'function'){
                var exists = false,
                    i = 0;

                while(i < onUpdateCallbacks.length){
                    if(onUpdateCallbacks[i].identifier == identifer){
                        exists = true;
                        break;
                    }

                    i++;
                }

                if(!exists){
                    onUpdateCallbacks.push({identifier:identifer,callback:callback});
                }
            }
        };

        this.onClear = function(identifer,callback){
            //cmLogger.debug('cmFilter.onClear');

            if(typeof identifer == 'string' && identifer.length > 0 && typeof callback == 'function'){
                var exists = false,
                    i = 0;

                while(i < onClearCallbacks.length){
                    if(onClearCallbacks[i].identifier == identifer){
                        exists = true;
                        break;
                    }

                    i++;
                }

                if(!exists){
                    onClearCallbacks.push({identifier:identifer,callback:callback});
                }
            }
        };

        this.removeOnUpdate = function(identifer){
            //cmLogger.debug('cmFilter.removeOnUpdate');

            if(typeof identifer == 'string' && identifer.length > 0){
                var i = 0,
                    index;

                while(i < onUpdateCallbacks.length){
                    if(onUpdateCallbacks[i].identifier == identifer){
                        index = i;
                        break;
                    }

                    i++;
                }

                onUpdateCallbacks.splice(index, 1);
            }
        };

        this.removeOnClear = function(identifer){
            //cmLogger.debug('cmFilter.removeOnClear');

            if(typeof identifer == 'string' && identifer.length > 0){
                var i = 0,
                    index;

                while(i < onClearCallbacks.length){
                    if(onClearCallbacks[i].identifier == identifer){
                        index = i;
                        break;
                    }

                    i++;
                }

                onClearCallbacks.splice(index, 1);
            }
        };

        /**
         * event handling
         */
        $rootScope.$on('logout', reset);

        $rootScope.$on('$routeChangeSuccess', function(){
            var url = $rootScope.getCurrentUrl(),
                whiteList = ['/talks', '/contact/list'];

            if(whiteList.indexOf(url) == -1){
                reset();
            }
        });
    }
])

.filter('appStoreLink',
    function(cmDevice){
        return function(objectStoreLinks) {
            var filteredArray = [];

            if(typeof objectStoreLinks == 'object'){
                Object.keys(objectStoreLinks).forEach(function(store){
                    if(cmDevice.is(store) && objectStoreLinks[store].href != ''){
                        var storeData = objectStoreLinks[store];
                        // compile default to app link
                        if(cmDevice.isMobile('appStoreLink') && cmDevice.isAndroid()){
                            // https://play.google.com/store/apps/details?id=appId
                            // market://details?appId
                            storeData.href = storeData.href.replace('https://play.google.com/store/apps/','market://');
                        }
                        filteredArray.push(storeData);
                    }
                });
            }

            return filteredArray;
        }
    }
)

.filter('cmAutolink', [
    '$sce', '$compile',
    'cmUtil',
    function($sce, $compile,
             cmUtil){
        return function(text, attrStrLen){
            var pattern = /(^|[\s\n]|<br\/?>)(((?:https?|ftp)(:\/\/)|(www|\/\/))[\-A-Z0-9+\u0026\u2019@#\/%?=()~_|!:,.;öäüÖÄÜ]*[\-A-Z0-9+\u0026@#\/%=~()_|])/gi;
            var strLen = attrStrLen||50;
            var slash = '&#x2F;'; // find forward slash '/'

            // unescaped links
            /*
             http://localhost:8000/app/#/conversation/zy6ofOMu5h0W5O1sPB70
             http:&#x2F;&#x2F;localhost:8000&#x2F;app&#x2F;#&#x2F;conversation&#x2F;zy6ofOMu5h0W5O1sPB70
            */

            if(text == undefined)
                return '';

            // unescaped slashes to normal slashes
            if(text.indexOf(slash) > -1) {
                text = text.replace(/&#x2F;/g, '/');
            }

            return text.replace(pattern, function(link){

                var tag = '<a href="%href" target="_blank" title="%href">%link</a>',
                    clearLink = link.replace(/\s+/g,''), // clear whitespace
                    url = !cmUtil.startsWith(clearLink,'www') // check if starts with http
                        ? clearLink
                        : 'http://'+clearLink,
                    startsWithBreak = link.indexOf('\n') != -1;

                if(url != undefined){
                    if(clearLink.length > strLen){
                        return $sce.trustAsHtml(
                                (startsWithBreak ? '\n' : '') +
                                (cmUtil.startsWith(link,' ')?' ':'') +
                                tag.replace(/%href/g,url)
                                   .replace(/%link/g,String(clearLink).substring(0, strLen))
                        );
                    } else {
                        return $sce.trustAsHtml(
                                (startsWithBreak ? '\n' : '') +
                                (cmUtil.startsWith(link,' ')?' ':'') +
                                tag.replace(/%href/g,url)
                                   .replace(/%link/g,clearLink)
                        );
                    }
                }
            });
        }
    }
])
.filter('cmBytesHumanReadable', [
    'cmUtil',
    function(cmUtil){
        return function(bytes){
            return cmUtil.bytesToStr(bytes);
        }
    }
])
.filter('cmDigits', [
    function(){
        return function(number, digits){
            var x   = parseFloat(number)
            var str =  (Math.round(x * Math.pow(10, digits)) / Math.pow(10, digits)).toString()

            str = str.match(/\./) ? str : str+'.'
            while(str.indexOf('.') >= str.length-2) str +='0'

            return str.match(/^[0-9\.]*$/) ? str : '0'
        }
    }
])

.filter('cmEscape', [
    function(){
        return function(canBeHtml){
            var entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': '&quot;',
                "'": '&#39;',
                "/": '&#x2F;'
            };

            function escapeHtml(string) {
                return String(string).replace(/[&<>"'\/]/g, function (s) {
                    return entityMap[s];
                });
            }

            var text = escapeHtml(canBeHtml||'');

            return text;
        }
    }
])

.filter('cmInlineTranslate', [
    '$filter',
    function($filter){
        return function(text){
            if(text == undefined)
                return '';

            var result = text,
                matches = text.match(/\$\$\{[A-Z0-9\.]*\}/) || [];

            matches.forEach(function(match){
                result = result.replace(match, $filter('cmTranslate')(match.replace('$${','').replace('}','')))
            });

            return result;
        }
    }
])
/*

 # Usage in html template:

 "xxx | nl2br"

 <div ng-bind-html=" YourString | nl2br "></div>

 or:

 "xxx | nl2br:Boolean"

 Boolean( true or flase or just keep null) means is xhtml  or not

 if is xhtml, replace with <br/> ; if not , replace with <br>

 <div ng-bind-html=" YourString | nl2br:true "></div>


 -------------------------

 # Example:

 //==Analog data===
 $scope.items = [
 {"message": "test"},
 {"message": "New\nLine"},
 ]
 //=====
 <div class="comment" ng-repeat="item in items">
 <p ng-bind-html=" item.message | nl2br "></p>
 </div>

 -------------------------

 # Output result:

 <div class="comment ng-scope" ng-repeat="item in items">
 <p class="ng-binding" ng-bind-html=" item.message | nl2br ">
 test
 </p>
 </div>
 <div class="comment ng-scope" ng-repeat="item in items">
 <p class="ng-binding" ng-bind-html=" item.message | nl2br ">
 New<br>Line
 </p>
 </div>

 */


.filter('nl2br', [
    '$sce',
    function($sce){
        return function(msg, is_xhtml) {
            var is_xhtml = is_xhtml || true;
            var breakTag = (is_xhtml) ? '<br />' : '<br>';
            var msg = (msg + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1'+ breakTag +'$2');
            return $sce.trustAsHtml(msg);
        }
    }
])

.filter('cmParse', [
    '$filter', '$compile',
    function($filter, $compile){
        return function(html, ignoreOrArgs){
            if(ignoreOrArgs == undefined)
                ignoreOrArgs = {};

            if(!('escape' in ignoreOrArgs))
                html = $filter('cmEscape')(html);

            if(!('translate' in ignoreOrArgs))
                html = $filter('cmTranslate')(html, 'data' in ignoreOrArgs ? ignoreOrArgs.data : {});

            if(!('inlineTranslate' in ignoreOrArgs))
                html = $filter('cmInlineTranslate')(html);

            if(!('autolink' in ignoreOrArgs))
                html = $filter('cmAutolink')(html, 40);//$sce

            if(!('emoji' in ignoreOrArgs))
                html = $filter('cmEmoji')(html);

            if(!('nl2br' in ignoreOrArgs))
                html = $filter('nl2br')(html);//$sce

            return html;
        }
    }
])
.filter('cmRecipients', [

    function(){
        return function(arrayToSearch, shouldBeRecipient, objectOfRecipients){
            // defines
            var arrayFiltered = [],
                objectOfRecipients = objectOfRecipients || {}

            if(!arrayToSearch.length) return arrayToSearch;

            // iterate all
            for ( var j = 0; j < arrayToSearch.length; j++) {
                var contact = arrayToSearch[j];
                if(shouldBeRecipient && contact.identity.id in objectOfRecipients ||
                   !shouldBeRecipient && !(contact.identity.id in objectOfRecipients) ) {
                    arrayFiltered.push(contact);
                }
            }
            // return filtered array
            return arrayFiltered;
        }
    }
])

.filter('strnl2nl', [
    '$sce',
    function($sce){
        return function(string) {
            var string = (string + '').replace(/\\n/g, '\n');
            return $sce.trustAsHtml(string);
        }
    }
])
.filter('cmTimeoutHumanReadable', [
    'cmUtil',
    function(cmUtil){
        return function(milliseconds){
            return cmUtil.millisecondsToStr(milliseconds);
        }
    }
])
.filter('truncate', [
    function () {
        return function (text, length, end) {
            if (isNaN(length))
                length = 10;

            if (end === undefined)
                end = "...";

            if (text.length <= length || text.length - end.length <= length) {
                return text;
            }
            else {
                return String(text).substring(0, length-end.length) + end;
            }

        };
    }
])

.directive('cmFullscreen', [
    'cmModal', 'cmUtil', 'cmFullscreen', 'cmDevice',
    function (cmModal, cmUtil, cmFullscreen, cmDevice) {
        return {
            restrict: 'A',
            transclude: true,
            scope: true,
            template: '<div class="fullscreen-wrap" ng-class="{\'is-open\':isOpen}">'+
                        '<i class="fa cm-close" ng-click="closeFullscreen($event)"></i>'+
                        '<ng-transclude></ng-transclude>' +
                        '<figcaption>{{::caption}}</figcaption>'+
                      '</div>',
            controller: function ($scope, $element, $attrs) {

                $scope.isOpen = false;
                $scope.caption = '';
                $attrs.$observe('cmFullscreen',function(caption){
                    $scope.caption = caption;
                });

                function isOpen(event, data){
                    if($element[0] != data.element)
                        return false;

                    $scope.$apply(function(){
                        $scope.isOpen = data.isOpen;
                    });
                }

                cmFullscreen.on('change',isOpen);

                $scope.closeFullscreen = function($event){
                    cmFullscreen.close();
                    $event.stopPropagation();
                };

                function openFullscreen(){
                    // html5 fullscreen
                    if(!cmDevice.isApp()) {
                        cmFullscreen.open($element[0]);
                        // for app the old fullscren modal
                    } else {
                        cmModal.create({
                            id: 'image-view',
                            'class': 'modal-image-fullscreen',
                            'type': 'fullscreen'
                        }, '<figure ng-style="fullscreenVisibility">' +
                        '<img cm-stay-in-viewport cm-src="fullscreenImage" cm-loaded-spinner="fullscreenSpinner" cm-loaded-visibility="fullscreenVisibility"  cm-pinch-and-pan="{initOnModalChange:true}" />' +
                        '<figcaption><cm-message-assets></cm-message-assets></figcaption>' +
                        '</figure>' +
                        '<cm-footer><i class="fa cm-grid"></i></cm-footer>', null, $scope);
                        cmModal.open('image-view');

                        $scope.fullscreenSpinner = true;
                        $scope.fullscreenVisibility = {visibility:'hidden'};
                        $scope.fullscreenImage = $element.find('img').attr('src');
                    }
                }

                $element.on('click', openFullscreen);

                $scope.$on('$destroy', function(){
                    $element.off('click', openFullscreen);
                    cmFullscreen.off('change',isOpen);
                });
            }
        }
    }
])

.directive('cmPinchAndPan',[
    'cmPinchAndPan',
    function (cmPinchAndPan){
        return {
            restrict: 'A',
            link: function(scope, element, attrs) {
                var options = scope.$eval(attrs.cmPinchAndPan);

                cmPinchAndPan.init(options,element);

                scope.$on('$destroy',function(){
                    cmPinchAndPan.destroy(element);
                });
            }
        }
    }
])

.directive('cmStayInMask',[
    'cmUtil', 'cmFullscreen', 'cmObject',
    '$window',
    function (cmUtil, cmFullscreen, cmObject,
              $window){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){

                var maskNode = cmUtil.findParent(attrs.cmStayInMask,element[0]),
                    win = {},
                    mask = {},
                    image = {};

                function calcRatio(obj){
                    obj.ratio = obj.width / obj.height;
                    obj.isPortrait = obj.width < obj.height;
                    obj.isLandscape = obj.width > obj.height;
                    obj.isSquare = obj.width == obj.height;
                }

                function calcDim(){
                    // width to big for mask
                    if(image.isLandscape){
                        image.newWidth = mask.width;
                        image.newHeight = Math.ceil(image.newWidth / image.ratio);

                        if(image.newHeight > mask.height) {
                            image.top = Math.ceil((mask.height - image.newHeight)/2);
                        }
                    } else if(image.isPortrait || image.isSquare) {
                        // scale to mask
                        if(image.height >= mask.height){
                            image.newHeight = mask.height;
                            image.newWidth = Math.ceil(image.newHeight * image.ratio);
                        } else {
                            image.newHeight = image.height;
                            image.newWidth = image.width;

                            image.top = (mask.height / 2) - (image.height / 2);
                        }
                    }

                    // check max if fit in window
                    // on landscape check first the height
                    if(win.isLandscape) {
                        if (image.height > win.height) {
                            image.maxHeight = win.height;
                            image.maxWidth = Math.ceil(image.maxHeight * image.ratio);
                        } else if(image.width > win.width) {
                            image.maxWidth = win.width;
                            image.maxHeight = image.maxWidth / image.ratio;
                        } else {
                            image.maxWidth = image.width;
                            image.maxHeight = image.height;
                        }
                    // on portrait check first the width
                    } else {
                        if(image.width > win.width) {
                            image.maxWidth = win.width;
                            image.maxHeight = image.maxWidth / image.ratio;
                        } else {
                            image.maxWidth = image.width;
                            image.maxHeight = image.height;
                        }
                    }
                }

                function browserResize(event, init){
                    win.width = $window.innerWidth;
                    win.height = $window.innerHeight;

                    calcRatio(win);

                    if(!init)
                        calcDim();
                }

                function imageDimensions(event, data){
                    
                    if(!cmUtil.isInParent(data.element, element[0])){
                        return false;
                    }

                    if(data.isOpen){
                        browserResize();
                        // in window
                        setDim({
                            top:0,
                            width:image.maxWidth,
                            height:image.maxHeight
                        });
                    } else {
                        // in mask
                        setDim({
                            top:image.top,
                            width:image.newWidth,
                            height:image.newHeight
                        });
                    }
                }

                function setDim(dim){
                    element.css({
                        top:dim.top+'px',
                        width:dim.width+'px',
                        height:dim.height+'px'
                    });

                    element.triggerHandler('dimensionsChanged',dim);
                }

                browserResize({},true);

                element.on('load', function () {
                    mask = {
                        width: maskNode.offsetWidth,
                        height: maskNode.offsetHeight
                    };
                    image = {
                        width: this.naturalWidth,
                        height: this.naturalHeight
                    };

                    calcRatio(mask);
                    calcRatio(image);
                    calcRatio(win);

                    calcDim();

                    // in mask
                    setDim({
                        top:image.top,
                        width:image.newWidth,
                        height:image.newHeight
                    });

                    cmFullscreen.on('change', imageDimensions);
                });

                angular.element($window).on('resize',browserResize);
                angular.element($window).on('orientationchange',browserResize);

                scope.$on('$destroy', function(){
                    angular.element($window).off('resize',browserResize);
                    angular.element($window).off('orientationchange',browserResize);
                    cmFullscreen.off('change', imageDimensions);
                })
            }
        }
    }
])
.directive('cmStayInViewport',[
    '$window',
    '$timeout',
    function ($window, $timeout){
        return {
            restrict: 'A',
            link: function(scope, element, attrs){
                // hide image for hidden scale operation
                element.css('visibility','hidden');

                if(attrs.cmSrc) {
                    // set src with delay for showing loader
                    $timeout(function () {
                        element.attr('src', scope[attrs.cmSrc]);
                    }, 1000);
                    // after setted src and image loaded check viewport
                    element.on('load', function () {
                        var viewport = {
                            w: $window.innerWidth,
                            h: $window.innerHeight
                        };
                        var image = {
                            w: element[0].width,
                            h: element[0].height,
                            isPortrait: element[0].height > element[0].width
                        };
                        // calc height if greater than viewport
                        if (image.isPortrait) {
                            element.parent().addClass('is-portrait');
                            if (image.h > viewport.h) {
                                element.css('height', (viewport.h - 150) + 'px');
                                element.css('max-width', 'none');
                            } else {
                                element.css('height', image.h + 'px');
                                element.css('max-width', 'none');
                            }
                        } else {
                            element.parent().addClass('is-landscape');
                            element.css('width', '90%');
                            element.css('max-width', 'none');
                        }
                        // show image and hide loader on scope
                        if (attrs.cmLoadedSpinner) {
                            scope.$apply(function () {
                                scope[attrs.cmLoadedSpinner] = false;
                            });
                        }
                        if (attrs.cmLoadedVisibility) {
                            scope.$apply(function () {
                                scope[attrs.cmLoadedVisibility] = {visibility: 'visible'};
                            });
                        }
                        // show image
                        element.css('visibility', 'visible');
                    });
                }
            }
        }
    }
])
// http://www.sitepoint.com/use-html5-full-screen-api/


.factory('cmFullscreen',[
    'cmLogger', 'cmObject', 'cmScreenOrientation',
    '$document', '$rootScope', '$window', '$timeout',
    function(cmLogger, cmObject, cmScreenOrientation,
             $document, $rootScope, $window, $timeout) {

        function detectBrowserForFullscreenApi() {
            if (typeof doc.fullscreenEnabled !== 'undefined') {
                isEnabled = 'fullscreenEnabled';
                requestOpen = 'requestFullscreen';
                isOpen = 'fullscreenElement';
                exit = 'exitFullscreen';
                eventChange = 'fullscreenchange';
                eventError = 'fullscreenerror';
                return true;
            } else if (typeof doc.mozFullScreenEnabled !== 'undefined') {
                isEnabled = 'mozFullScreenEnabled';
                requestOpen = 'mozRequestFullScreen';
                isOpen = 'mozFullScreenElement';
                exit = 'mozCancelFullScreen';
                eventChange = 'mozfullscreenchange';
                eventError = 'mozfullscreenerror';
                return true;
            } else if (typeof doc.msFullscreenEnabled !== 'undefined') {
                isEnabled = 'msFullscreenEnabled';
                requestOpen = 'msRequestFullscreen';
                isOpen = 'msFullscreenElement';
                exit = 'msExitFullscreen';
                eventChange = 'MSFullscreenChange';
                eventError = 'MSFullscreenError';
                return true;
            } else if (typeof doc.webkitFullscreenEnabled !== 'undefined') {
                isEnabled = 'webkitFullscreenEnabled';
                requestOpen = 'webkitRequestFullscreen';
                isOpen = 'webkitFullscreenElement';
                exit = 'webkitExitFullscreen';
                eventChange = 'webkitfullscreenchange';
                eventError = 'webkitfullscreenerror';
                return true;
            }
            return false;
        }

        var isEnabled,
            requestOpen,
            isOpen,
            exit,
            eventChange,
            eventError,
            doc = $document[0],
            scrollTop = 0,
        self = {
            lastElement: null,
            isAvailable: function(){
                return doc[isEnabled] ? true : false;
            },
            open: function(element){
                if(!this.isOpen() && element && requestOpen in element){
                    // cache top
                    self.scrollTop = $window.scrollY;

                    //cmScreenOrientation.unlock();

                    // open fullscreen
                    element[requestOpen]();
                    self.lastElement = element;
                }
            },
            isOpen: function(){
                return isOpen && isOpen in doc && doc[isOpen] ? true : false;
            },
            close: function(){
                if(doc[exit]) {
                    doc[exit]();
                }
            },
            handler: {
                change: function(){

                },
                error: function(){

                }
            }
        };

        if(detectBrowserForFullscreenApi()){
            $document.on(eventChange, function (event) {
                var element = self.lastElement;

                self.trigger('change', {
                    element: element,
                    isOpen: self.isOpen()
                });

                if(self.isOpen()){
                    angular.element(element).addClass('is-fullscreen');
                } else {
                    angular.element(element).removeClass('is-fullscreen');
                    // rejump to last top position
                    $timeout(function(){
                        $window.scrollTo(0,self.scrollTop);
                    },50);

                    //cmScreenOrientation.lock();
                }
            });

            $document.on(eventError, function () {
                self.trigger('error',arguments);
            });

            // workarround for device backbutton clicked if fullscreen open
            $rootScope.$on('$locationChangeStart', function(event){
                if(self.isOpen()) {
                    self.close();
                    event.preventDefault();
                }
            });
        }

        cmObject.addEventHandlingTo(self);

    return self;
    }
])

    .factory('cmPinchAndPan',[
        'cmFullscreen', 'cmUtil', 'cmModal',
        '$window', '$timeout', '$document',
        function(cmFullscreen, cmUtil, cmModal,
                 $window, $timeout, $document) {

            var utils = {
                calcBounds: function(){
                    var minX = Math.ceil((mask.dim.w / 2) - ((image.dim.w * image.scale) / 2)),
                        minY = Math.ceil((mask.dim.h / 2) - ((image.dim.h * image.scale) / 2)),
                        maxX = -(minX),
                        maxY = -(minY);

                    return {
                        x: {
                            min: minX,
                            max: maxX
                        },
                        y: {
                            min: minY,
                            max: maxY
                        }
                    }
                },
                stayInBounds: function(possibleX, possibleY, _bounds_){
                    var bounds = _bounds_ || this.calcBounds(),
                        setX = 0, setY = 0;

                    if(possibleX < bounds.x.min && possibleX > bounds.x.max)
                        setX = possibleX;
                    else if(possibleX < bounds.x.min)
                        setX = bounds.x.max;
                    else if(possibleX > bounds.x.max)
                        setX = bounds.x.min;

                    if(possibleY < bounds.y.min && possibleY > bounds.y.max)
                        setY = possibleY;
                    else if(possibleY < bounds.y.min)
                        setY = bounds.y.max;
                    else if(possibleY > bounds.y.max)
                        setY = bounds.y.min;

                    return {
                        x: setX,
                        y: setY
                    }
                }
            };

            var mask = {
                dim: {},
                init: function(){
                    this.resize();

                    angular.element($window).on('resize',this.resize);
                    angular.element($window).on('orientationchange',this.resize);
                },
                resize: function(){
                    // dimensions
                    mask.dim.w = $window.innerWidth;
                    mask.dim.h = $window.innerHeight;
                    mask.dim.r = mask.dim.w / mask.dim.h;
                },
                getCenter: function(){
                    return {
                        x: (this.dim.w / 2),
                        y: (this.dim.h / 2)
                    }
                }
            },
            image = {
                element: null,
                tmp: {},
                transform: {},
                dim: {},
                init: function(element, isFullscreenInit){
                    // dom element
                    if(isFullscreenInit)
                        this.element = angular.element(element).find('img');
                    else
                        this.element = angular.element(element);

                    // dimensions
                    this.dim.w = this.element[0].width;
                    this.dim.h = this.element[0].height;
                    this.dim.r = this.element[0].width / this.element[0].height;

                    // startScale
                    this.scale = this.tmp.startScale = self.settings.startScale || 1;

                    // check settings
                    // fits the height
                    if('fitHeight' in self.settings && self.settings.fitHeight){
                        this.scale = this.tmp.startScale = mask.dim.h / this.dim.h;
                    }
                    // fits the height
                    if('fitWidth' in self.settings && self.settings.fitWidth){
                        this.scale = this.tmp.startScale = mask.dim.w / this.dim.w;
                    }

                    this.tmp.startX = this.tmp.lastX = 0;
                    this.tmp.startY = this.tmp.lastY = 0;

                    // first draw
                    this.reset();
                },
                getDifference: function(){
                    var newWidth = this.dim.w * this.scale,
                        newHeight = this.dim.h * this.scale;
                    return {
                        w: newWidth - this.dim.w,
                        h: newHeight - this.dim.h
                    }
                },
                getCenter: function(){
                    return {
                        x: (this.dim.w / 2),
                        y: (this.dim.h / 2)
                    }
                },
                reset: function(){
                    this.transform = {
                        translate: { x: this.tmp.startX, y: this.tmp.startY },
                        scale: this.tmp.startScale
                    };

                    this.update();
                },
                update: function(clear){
                    // disable pan
                    this.transform.translate = {x:0,y:0};

                    var value = [
                        'translateX(' + this.transform.translate.x + 'px)',
                        'translateY(' + this.transform.translate.y + 'px)',
                        'scale(' + this.transform.scale + ', ' + this.transform.scale + ')'
                    ];

                    value = value.join(' ');

                    if(clear)
                        value = '';

                    //mask.textContent = value;
                    this.element.css({
                        webkitTransform: value,
                        mozTransform: value,
                        transform: value
                    });
                },
                panTo: function(newX, newY){
                    var maskCenter = mask.getCenter(),
                        difference = this.getDifference(),
                        bounds = utils.calcBounds(),
                        possibleX = -((bounds.x.min + (newX * this.scale)) - difference.w - maskCenter.x),
                        possibleY = -((bounds.y.min + (newY * this.scale)) - difference.h - maskCenter.y),
                        coords = utils.stayInBounds(possibleX, possibleY);

                    this.transform.translate.x = coords.x;
                    this.transform.translate.y = coords.y;

                    this.update();
                }
            };

            var self = {
                mc: null,
                settings: null,
                target: null,
                init: function(_settings_, _element_){

                    this.settings = {
                        startScale: 1,
                        maxScale: 3,
                        fitHeight: false,
                        fitWidth: false,
                        panInBounds: true
                    };

                    function init(target, isFullscreenInit){
                        if(self.mc != null) {
                            return false;
                        }

                        self.target = target;

                        // let the browser init all dimensions of image and mask
                        $timeout(function(){
                            mask.init();
                            self.initHammer();
                            image.init(target, isFullscreenInit);
                        },100);
                    }

                    if('initOnFullscreen' in _settings_ && _settings_.initOnFullscreen) {
                        cmFullscreen.on('change', function (event, data) {
                            if (!cmUtil.isInParent(data.element, _element_[0])) {
                                return false;
                            }

                            if (data.isOpen) {
                                init(data.element, true);
                            } else {
                                image.update(true);
                                self.destroy();
                            }
                        });
                    } else if('initOnModalChange' in _settings_ && _settings_.initOnModalChange) {
                        init(_element_[0]);

                        cmModal.one('modal:closed', function(){
                            self.destroy();
                        });
                    } else {
                        init(_element_[0]);
                    }
                },
                initHammer: function(){
                    this.mc = new Hammer.Manager(this.target);

                    this.mc.add(new Hammer.Pan({ threshold: 0, pointers: 0 }));
                    this.mc.add(new Hammer.Pinch({ threshold: 0 }))
                        .recognizeWith( this.mc.get('pan') );

                    //this.mc.on('panstart panmove', this.handler.pan);
                    this.mc.on('pinchstart pinchmove', this.handler.pinch);
                    this.mc.on('hammer.input', this.handler.final);

                    angular.element($window).on('mousewheel', this.handler.mousewheel);
                    angular.element($window).on('DOMMouseScroll', this.handler.mousewheel);
                },
                handler: {
                    // desktop pinching via mousewheel
                    mousewheel: function(e) {
                        // cross-browser wheel delta
                        var e = $window.event || e; // old IE support
                        var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))),
                            center = {
                                x: e.clientX,
                                y: e.clientY
                            };

                        self.handler.scroll(delta,center);
                    },
                    scroll: function(delta, center){
                        var fakeEvent = {
                            type: 'pinchstart',
                            center: center,
                            scale: 0
                        };

                        // zoom in
                        if(delta > 0){
                            fakeEvent.scale = 1.25;
                            // zoom out
                        } else {
                            fakeEvent.scale = 0.85;
                        }

                        self.handler.pinch(fakeEvent);
                    },
                    pinch: function(ev) {
                        if(ev.type == 'pinchstart') {
                            image.tmp.initScale = image.scale || 1;
                            image.tmp.panTo = {
                                x: -(image.tmp.lastX - ev.center.x),
                                y: -(image.tmp.lastY - ev.center.y)
                            };
                        }

                        var newScale = image.tmp.initScale * ev.scale,
                            setScale = 1;

                        switch(true){
                            case newScale > self.settings.maxScale:
                                setScale = self.settings.maxScale;
                            break;
                            case newScale < 0.5:
                                setScale = 0.5;
                            break;
                            default:
                                setScale = newScale;
                        }

                        image.scale = image.transform.scale = setScale;

                        image.panTo(image.tmp.panTo.x,image.tmp.panTo.y);

                        image.update();
                    },
                    pan: function(ev) {
                        if(ev.type == 'panstart'){
                            image.tmp.panScale = 1;
                            image.tmp.panBounds = utils.calcBounds(image.tmp.panScale);
                        }

                        var possibleX = image.tmp.lastX + ev.deltaX,
                            possibleY = image.tmp.lastY + ev.deltaY,
                            coords = self.settings.panInBounds
                                ? utils.stayInBounds(possibleX, possibleY, image.tmp.panBounds, image.tmp.panScale)
                                : {x:possibleX,y:possibleY};


                        //console.log(coords)

                        //image.transform.translate.x = coords.x;
                        //image.transform.translate.y = coords.y;

                        image.update();
                    },
                    final: function(ev) {
                        if (ev.isFinal) {
                            //console.log('final', JSON.stringify(image.transform, null));
                            image.tmp.lastX = image.transform.translate.x;
                            image.tmp.lastY = image.transform.translate.y;
                        }
                    }
                },
                destroy: function(){
                    if(self.mc != null) {
                        self.mc.destroy();
                        self.mc = null;
                    }

                    angular.element($window).off('mousewheel', self.handler.mousewheel);
                    angular.element($window).off('DOMMouseScroll', self.handler.mousewheel);

                    angular.element($window).off('resize',mask.resize);
                    angular.element($window).off('orientationchange',mask.resize);
                }
            };

            return self;
        }
])
.directive('cmMenu',[
    'cmUserModel', 'cmConfig', 'cmNotify', 'cmUtil',
    '$location', '$window', '$rootScope',
    function (cmUserModel, cmConfig, cmNotify, cmUtil,
              $location, $window, $rootScope){
        return {
            restrict: 'AE',
            scope: true,
            templateUrl: 'comps/ui/menu/drtv-menu.html',
            controller: function($scope){
                $scope.menu = cmConfig.menu;
                $scope.menuKeys = Object.keys($scope.menu);

                $scope.markHelp = cmNotify.isBimmel('markHelp');

                cmNotify.on('bell:unring', function(){
                    $scope.markHelp = cmNotify.isBimmel('markHelp');
                });

                $scope.version = cmConfig.version;
                $scope.menuVisible = false;

                $scope.handleMenu = function(){
                    $scope.menuVisible = $scope.menuVisible ? false : true;

                    if($scope.menuVisible){
                        cmNotify.unringBimmelForce();
                    }
                };

                $scope.checkActive = function(url){
                    if(cmUtil.startsWith($location.$$url,'/' + url)){
                        return true;
                    }
                    return false;
                };

                $scope.goTo = function(parentBtn, url){

                    /**
                     * if current location == url, then only close menu
                     */
                    if('/' + url == $location.$$url){
                        $scope.handleMenu();
                    }

                    if(typeof parentBtn.rootScopeCallback == 'string' && typeof $rootScope[parentBtn.rootScopeCallback] == 'function'){
                        $rootScope[parentBtn.rootScopeCallback]();
                        return false;
                    }

                    // for extern and performance
                    if('link' in parentBtn){
                        // file:///android_asset/www/index.html#/login
                        if(cmUtil.startsWith($location.$$absUrl, 'file:///')) {
                            $window.location = parentBtn.link;
                        // http://localhost:8000/app/#/settings
                        } else if($location.$$absUrl.indexOf('/#/') != -1) {
                            var arr_location = $location.$$absUrl.split('/#/');
                            location.href = arr_location[0] + '/' + parentBtn.link;
                        // http://localhost:8000/app/index.html#/settings
                        } else if($location.$$absUrl.indexOf('index.html#/') != -1) {
                            var arr_location = $location.$$absUrl.split('index.html#/');
                            location.href = arr_location[0] + '/' + parentBtn.link;
                        }

                        return false;
                    }

                    if(typeof url !== 'undefined'){
                        $scope.goto('/'+url);
                    }

                    return false;
                };

                $scope.logout = function(){
                    cmUserModel.doLogout(true,'drtv-menu logout');
                };

                var destroyWatcher = $rootScope.$on('cmMenu:toggle',function(){
                    $scope.handleMenu();
                });

                $scope.$on('$destroy', function(){
                    destroyWatcher();
                });
            }
        }
    }
])

.directive('cmModal', [
    'cmModal', 'cmTranslate',
    '$rootScope', '$timeout', '$q',
    function (cmModal, cmTranslate,
              $rootScope, $timeout, $q){

        // handle nose position
        function addNose(element, attrs){
            if(!attrs.nose)
                return null;

            var nose        =   angular.element('<i class="nose fa"></i>'),
                nose_side   =   attrs.nose.split('-'),
                nose_class  =   {
                    'top-left':     'cm-nose-up flip',
                    'top-right':    'cm-nose-up',
                    'left-top':     'cm-nose-left flip',
                    'left-bottom':  'cm-nose-left',
                    'right-top':    'cm-nose-right',
                    'right-bottom': 'cm-nose-right flip',
                    'bottom-left':  'cm-nose-down flip',
                    'bottom-right': 'cm-nose-down'
                };

            nose
                .addClass(nose_class[attrs.nose])
                .addClass(nose_side[0])
                .css(nose_side[1], attrs.nosePosition || '2rem');

            element
                .addClass('nose-'+nose_side[0])

            element.find('article').append(nose)
        }

        return {
            restrict: 'AE',
            transclude: true,
            scope: true,
            
            templateUrl: function(tElement, tAttrs){
                var type = tAttrs.type || 'plain',
                    templateUrl = {
                        plain:      'comps/ui/modal/drtv-modal-plain.html',
                        fullscreen: 'comps/ui/modal/drtv-modal-fullscreen.html',
                        alert:      'comps/ui/modal/drtv-modal-alert.html',
                        confirm:    'comps/ui/modal/drtv-modal-confirm.html'
                    };

                return templateUrl[type];
            },

            link: function(scope, element, attrs, controller, transclude){
                scope.closeBtn = attrs.cmCloseBtn ? scope.$eval(attrs.cmCloseBtn) : true;
                scope.footerLabel = attrs.cmFooterLabel || undefined;
                scope.footerIcon = attrs.cmFooterIcon || undefined;

                // refresh modal content
                scope.refresh = function(){                   
                    transclude(scope, function (clone) {
                        var transclude_container = element.find('ng-transclude');

                        transclude_container
                        .children()
                        .remove();

                        transclude_container
                        .append(clone);                 
                    });
                };

                // add external data to scope
                scope.setData = function(data){
                    if(data != undefined) {
                        scope[attrs.cmDataAs || 'data'] = data;
                    }
                    return this;
                };

                // toggle visiblity modal
                scope.toggle = function(on){
                    on = (on == undefined ? $element.hasClass('active') : on);
                    if(on){
                        scope.refresh();
                        element.addClass('active');
                        $timeout(function(){
                            $rootScope.isModalVisible = true;
                        })                        
                    } else {
                        element.removeClass('active');
                        $timeout(function(){
                            $rootScope.isModalVisible = false;
                        })
                    }

                    return this;
                };

                scope.isActive = function(){
                    return element.hasClass('active')
                };

                // open modal
                scope.open = function(ttl){
                    scope.toggle(true);
                    return scope;
                };
                // close modal
                scope.close = function(fromBackdrop){

                    if(!fromBackdrop && 'onFooterClick' in scope){
                        scope.onFooterClick();
                    }

                    this.toggle(false);
                    cmModal.trigger('modal:closed', attrs.id);

                    return this;
                };

                // close modal when clicked on backdrop
                if(!('cmCloseOnBackdrop' in attrs) || attrs.cmCloseOnBackdrop != "false"){
                    angular.element(element.children()[1]).on('click', function () {
                        scope.close(true);
                    });
                }

                element
                .addClass(attrs.severity)

                addNose(element, attrs);
                // register modal to service
                cmModal.register(attrs.id, scope);
                // refresh content
                scope.refresh();
            },

            controller: function($scope, $element, $attrs){
                $scope.title    = $attrs.cmTitle;
                $scope.severity = $attrs.severity || 'info';
                $scope.options  = $scope.$eval($attrs.cmOptions) || {withoutBackdrop:false}
                $scope.id       = $attrs.id
            }
        }
    }
])

.service('cmModal',[
    'cmObject', 'cmLogger',
    '$rootScope', '$compile', '$document', '$q', '$timeout',
    function(cmObject, cmLogger,
             $rootScope, $compile, $document, $q, $timeout){
        var self = {};

        cmObject.addEventHandlingTo(self);

        self.instances = {};

        self.register = function(id, scope){

            if(!scope){
                cmLogger.error('cmModal: unable to register modal without id or scope.');
                return null;
            }

            var old_scope = self.instances[id];

            if(old_scope != scope){
                self.instances[id] = scope;
                self.trigger('register', id);
            }

            return self;
        };

        self.open = function(id, data, ttl){
            if(self.instances[id]){
                self.instances[id]
                    .setData(data)
                    .open();
                self.trigger('modal:opened',id);
            } else {
                self.one('register', function(event, registered_id){
                    return !!(registered_id == id ? self.open(id, data) : false);
                });
            }

            if(ttl){ $timeout(function(){ self.close(id)}, ttl) }

            return self;
        };

        self.close = function(id){
            var instance = self.instances[id];

            if(instance){
                self.instances[id].close();

                self.trigger('modal:closed',id);
            }
            return self;
        };

        self.closeAll = function(){
            angular.forEach(self.instances, function (modal_instance) {
                modal_instance.close();
            });

            return self;
        };

        self.create = function(config, template, target, scope){
            var attrs = '';

            //Todo: könnte man schöner machen:
            angular.forEach(config, function(value, key){ attrs += key+'="'+value+'"' });

            // clear existing instance
            if(self.instances[config.id] != undefined){
                delete self.instances[config.id];
            }

            // clear DOM element, if neccessary
            if(angular.element($document[0].getElementById(config.id)).length > 0){
                angular.element($document[0].getElementById(config.id)).remove();
            }

            // create new element
            var scope = scope || $rootScope.$new();


            var modal = $compile('<cm-modal '+attrs+' >'+(template||'')+'</cm-modal>')(scope);
            // move modal up the dom hierarchy, if necessary:

            if(target == 'body'){
                target = $document[0].querySelector('body');
            }

            angular.element(target || $document[0].querySelector('#cm-app') || $document[0].querySelector('body')).append(modal);

            // the modal directive (<cm-modal>) will register itself on next digest

            self.one('modal:closed', function(){
                self.remove(config.id);
            });

            return modal;
        };

        self.remove = function(id){
            angular.element($document[0].querySelector('cm-modal#'+id)).remove();
            delete self.instances[id];
        };

        self.confirm = function(config){

            config  =   {
                text:   config.text,
                cancel: config.cancel   || 'MODAL.LABEL.CANCEL',
                okay:   config.okay     || 'MODAL.LABEL.OK',
                title:  config.title    || 'DRTV.CONFIRM.HEADER',
                html:   config.html     || '',
                data:   config.data
            };

            var deferred    = $q.defer(),
                scope       = $rootScope.$new(),
                modalId     = 'modal-confirm';

            scope.text              =   config.text       || '';
            scope.labelOkay         =   config.okay;
            scope.labelCancel       =   config.cancel;

            scope.cancel            =   function(){
                $rootScope.closeModal(modalId)
            };
            scope.confirm           =   function(){
                deferred.resolve(this);
                $rootScope.closeModal(modalId)
            };
            self.create({
                id:             modalId,
                type:           'confirm',
                'class':        'no-padding',
                'cm-close-btn': false,
                'cm-title':     config.title
            },'<cm-modal-confirm>'+config.html+'</cm-modal-confirm>',null,scope);

            self.open(modalId, config.data);

            self.one('modal:closed', function(event, id){
                if(id == modalId)
                    deferred.reject();
                return true;
            });

            return deferred.promise;
        };

        $rootScope.openModal        = self.open;
        $rootScope.closeModal       = self.close;
        $rootScope.isModalVisible   = false;
        $rootScope.confirm          = self.confirm;

//        $rootScope.$watch('isModalVisible' ,function(newValue){
//            console.log('watch modal '+newValue)
//            $rootScope.isModalVisible = newValue;
//        });

        // close all modals on route change:
        $rootScope.$on('$routeChangeStart', function(){
            self.closeAll();
        });

        // closeAll on ESC
        $document.bind('keydown', function (event) {
            if (event.which === 27) {
                self.closeAll();
            }
        });

        return self;
    }
])
// https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API?redirectlocale=en-US&redirectslug=DOM/Using_the_Page_Visibility_API

/*
example:
 var defaultTitle = $document[0].querySelector('title').innerHTML;
 cmVisibility.add('keyName for remove',function(isHidden, isTab){
    var title = defaultTitle;
    if(isHidden == true){
        title = defaultTitle +' '+ (isTab?'tab':'window')+' leaved';
    }
    $document[0].querySelector('title').innerHTML = title;
 })
*/


.factory('cmVisibility',[
    'cmLogger',
    '$document', '$window',
    function(cmLogger,
             $document, $window) {

        function detectBrowserForTabApi() {
            // Opera 12.10 and Firefox 18 and later support
            if (typeof doc.hidden !== 'undefined') {
                isHidden = 'hidden';
                eventName = 'visibilitychange';
                return true;
            } else if (typeof doc.mozHidden !== 'undefined') {
                isHidden = 'mozHidden';
                eventName = 'mozvisibilitychange';
                return true;
            } else if (typeof doc.msHidden !== 'undefined') {
                isHidden = 'msHidden';
                eventName = 'msvisibilitychange';
                return true;
            } else if (typeof doc.webkitHidden !== 'undefined') {
                isHidden = 'webkitHidden';
                eventName = 'webkitvisibilitychange';
                return true;
            }
        return false;
        }

        function isValidKey(key){
            if(!key || typeof key != 'string' || key == '')
                return false;
            return true;
        }

        function findCallback(key){
            var index = -1;

            if(!isValidKey(key))
                return index;

            self.callbacks.forEach(function(callback, _index_){
                if(callback.key == key)
                    index = _index_;
            });

            return index;
        }

        function handleVisibilityChange(isHidden, isTab) {
            if(self.callbacks.length == 0)
                return false;

            if (isHidden) {
                self.callbacks.forEach(function(callback){
                    if(callback.method != null)
                        callback.method(true, isTab);
                });
            } else {
                self.callbacks.forEach(function(callback){
                    if(callback.method != null)
                        callback.method(false, isTab);
                });
            }
        }

        var isHidden,
            eventName,
            doc = $document[0],
            callbacks = [],
            self = {
                callbacks: [],
                isTabEventAvailable: function(){
                    return !(typeof doc[isHidden] === 'undefined');
                },
                add: function(key, callback){
                    var index = findCallback(key);
                    if (index == -1) {
                        if(isValidKey(key)) {
                            this.callbacks.push({
                                key: key,
                                method: typeof callback == 'function' ? callback : function(isHidden){}
                            });
                        }
                    } else {
                        cmLogger.warn('cmVisibility.add key "'+key+'" already exists. please do a remove before add.');
                    }
                },

                remove: function(key){
                    var index = findCallback(key);
                    if (index > -1) {
                        this.callbacks.splice(index, 1);
                    }
                }
            };

        // tab visibility
        if(detectBrowserForTabApi()){
            // Handle page visibility change
            $document.on(eventName, function(){
                handleVisibilityChange(doc[isHidden], true);
            });
        }

        // window visibility
        angular.element($window)
        .on('focus', function() {
            handleVisibilityChange(false, false);
        })
        .on('blur', function() {
            handleVisibilityChange(true, false);
        });

        return self;
    }
])
angular.module('comps/user/drtv-account-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/drtv-account-edit.html',
'<cm-scrollable><article class="content" ng-click="showHeadlineInfo = showHeadlineInfo ? false : true"><cm-info-bubble nose-x="45%"><div ng-show="!showHeadlineInfo"><i class="fa cm-info cm-ci-color"></i> {{::\'ACCOUNT.INFO.NOTE_ABOUT_THIS_DATA_SMALL\'|cmTranslate}}</div><div ng-show="showHeadlineInfo"><i class="fa cm-info cm-ci-color"></i> {{::\'ACCOUNT.INFO.NOTE_ABOUT_THIS_DATA_SMALL\'|cmTranslate}}<hr class="margin-small" /><span ng-bind-html="::\'ACCOUNT.INFO.NOTE_ABOUT_THIS_DATA\'|cmParse"></span></div></cm-info-bubble></article><hr class="margin-small" /><form name="cmForm" novalidate autocomplete="off"><article class="content" ng-click="toggleReadOnly()"><label>{{::\'ACCOUNT.PLACEHOLDER.LOGINNAME\'|cmTranslate}}</label><div class="cm-input-ctn"><input tabindex="1" data-qa="input-loginName" disabled type="text" name="loginName" ng-model="account.loginName" /></div><cm-info-bubble class="cm-alert" ng-show="showReadOnly"><i class="fa cm-info cm-ci-color"></i><span ng-bind-html="::\'ACCOUNT.INFO.LOGINAME\'|cmTranslate"></span></cm-info-bubble></article><hr class="margin-small" /><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="2" cm-label="ACCOUNT.PLACEHOLDER.PHONENUMBER" cm-info="ACCOUNT.INFO.INVALID.PHONENUMBER" cm-verify="account.phoneNumber" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="3" cm-label="ACCOUNT.PLACEHOLDER.EMAIL" cm-info="ACCOUNT.INFO.INVALID.EMAIL" cm-verify="account.email" ></cm-form-email><ul class="border-top border-bottom mt5"><li class="no-border"><span class="item" ng-click="togglePasswordChange()" data-qa="btn-passwordChange" cm-reactive> {{::\'ACCOUNT.PLACEHOLDER.PASSWORD_CHANGE\'|cmTranslate}}</span><div class="short-links without-bg" ng-click="togglePasswordChange()"><i class="fa" ng-class="{\'cm-down\':!showPasswordChange,\'cm-up\':showPasswordChange}"></i></div><section ng-show="showPasswordChange"><hr class="margin-small" /><article class="content"><label>{{::\'ACCOUNT.PLACEHOLDER.OLD_PASSWORD\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon"><input tabindex="4" data-qa="input-oldPassword" type="password" name="oldPassword" ng-model="formData.oldPassword" /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show="cmForm.oldPassword.$error.empty || cmForm.oldPassword.$error.invalid"><div ng-show="cmForm.oldPassword.$error.empty" data-qa="form-error-oldPassword-empty"><i class="fa cm-info"></i> {{::\'ACCOUNT.INFO.INVALID.OLD_PASSWORD\'|cmTranslate}}</div><div ng-show="cmForm.oldPassword.$error.invalid" data-qa="form-error-oldPassword-invalid"><i class="fa cm-info"></i> {{::\'ACCOUNT.INFO.INVALID.OLD_PASSWORD\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><cm-password ng-model="formData.password" cm-tabindex="5" form-name="cmForm" cm-required="{{showPasswordChange}}"></cm-password></section></li></ul></form></cm-scrollable><cm-footer><button class="cm-btn-grey" ng-click="saveAccount()" data-qa="btn-saveAccount" cm-reactive><span ng-show="!showLoader && !isPristine"> {{::\'ACCOUNT.FOOTER.SAVE\'|cmTranslate}}<i class="fa cm-checker"></i></span><span ng-show="isPristine" data-qa="btn-pristineBack"> {{::\'ACCOUNT.FOOTER.BACK\'|cmTranslate}}<i class="fa cm-out"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/user/drtv-incoming-authentication-request.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/drtv-incoming-authentication-request.html',
'<div class="theme-a modal-row"><strong ng-if="is3rdParty" ng-bind-html="\'IDENTITY.KEYS.TRUST.ENTER_TRANSACTION_SECRET.NOTE\'|cmTranslate:modalMessageVars"></strong><strong ng-if="!is3rdParty" ng-bind-html="\'IDENTITY.KEYS.AUTHENTICATION.ENTER_TRANSACTION_SECRET.NOTE\'|cmTranslate:modalMessageVars"></strong><form ng-submit="verify(transactSecret)"><div class="cm-input-ctn with-inside-icon"><input id="inp-transactSecret" name="inp-transactSecret" type="text" ng-model="transactSecret" cm-model-to-lowercase data-qa="inp-transactSecret" cm-enter="verify(transactSecret)" /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert mb10" ng-show="error.emptyInput || error.wrongSecret"><div ng-show="error.emptyInput"><i class="fa cm-info"></i>{{\'SYSTEM.ERROR.EMPTY_INPUT\'|cmTranslate}}</div><div ng-show="error.wrongSecret" data-qa="warn-wrong-input"><i class="fa cm-info"></i>{{\'SYSTEM.ERROR.WRONG_INPUT\'|cmTranslate}}</div></cm-info-bubble><span ng-if="is3rdParty" ng-bind-html="\'IDENTITY.KEYS.TRUST.ENTER_TRANSACTION_SECRET.INSTRUCTIONS\'|cmTranslate:modalMessageVars"></span><span ng-if="!is3rdParty" ng-bind-html="\'IDENTITY.KEYS.AUTHENTICATION.ENTER_TRANSACTION_SECRET.INSTRUCTIONS\'|cmTranslate:modalMessageVars"></span></form></div><footer><button class = "cm-btn-grey dib w50" data-qa = "btn-cancel" cm-weight = "1" ng-click = "close()" cm-reactive > {{ (labelCancel || \'MODAL.LABEL.CANCEL\') | cmTranslate }}<i class="fa cm-checkbox-wrong cm-lg-icon"></i></button><button class = "cm-btn-grey dib w50" data-qa = "btn-acceptIncomingRequest" ng-click = "verify(transactSecret)" cm-weight = "1" cm-reactive ><span> {{ is3rdParty ? \'IDENTITY.KEYS.TRUST.ENTER_TRANSACTION_SECRET.SUBMIT_BUTTON\' : \'IDENTITY.KEYS.AUTHENTICATION.ENTER_TRANSACTION_SECRET.SUBMIT_BUTTON\' |cmTranslate }}<i class="fa cm-checker cm-lg-icon"></i></span></button><button class="cm-btn-grey dib cm-hide with-loader"><cm-loader cm-color="ci-color"></cm-loader></button></footer>');
}]);
angular.module('comps/user/drtv-login-modal.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/drtv-login-modal.html',
'<section class="theme-a"><div class="modal-outer-title"><cm-logo></cm-logo></div><h2 class="form-signin-heading ">{{\'LOGIN.HEADING\'|cmTranslate}}</h2><form class="form-signin mb15" role="form" ng-submit="doLogin()" autocomplete="off" data-qa="modal-login"><select ng-model="formData.autologin" class="cm-form-control btn-block autologin" ng-change="changeAutologin()" ng-if="cmEnv.autoLogin"><option value="none">{{\'LOGIN.PLACEHOLDER.AUTOLOGIN\'|cmTranslate}}</option><option ng-repeat="(user,prop) in loginData">{{user}}</option></select><div class="cm-input-ctn" ng-class="{\'cm-input-error\':alertState!=\'\'}"><input tabindex="1" data-qa="inp-username" type="text" ng-model="formData.user" ng-class="{\'cm-input-error\':alertState!=\'\'}" id="user" name="user" value="" required placeholder="{{\'LOGIN.PLACEHOLDER.USERNAME\'|cmTranslate}}" /></div><div class="cm-input-ctn with-inside-icon" ng-class="{\'cm-input-error\':alertState!=\'\'}"><input tabindex="2" data-qa="inp-password" type="{{passwordType}}" ng-model="formData.pass" ng-class="{\'cm-input-error\':alertState!=\'\'}" id="pw" name="pw" value="" required placeholder="{{\'LOGIN.PLACEHOLDER.PASSWORD\'|cmTranslate}}" /><i class="fa cm-icon-grey cm-lg-icon" ng-class="{\'cm-visible\':passwordType==\'password\',\'cm-hidden\':passwordType==\'text\'}" ng-click="handlePassword()"></i></div><cm-info-bubble class="cm-alert" ng-hide="alertState==\'\'" data-qa="login-info"><div><i class="fa cm-info"></i><span ng-bind-html="\'LOGIN.INFO.\'+alertState|cmParse"></span></div></cm-info-bubble><button class="btn-submit" type="submit"></button></form><button class="cm-btn-grey" ng-click="doLogin()" data-qa="login-submit-btn" cm-reactive><span ng-show="!showLoader"> {{\'LOGIN.LABEL.SUBMIT\'|cmTranslate}} <i class="fa cm-key cm-lg-icon"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></section>');
}]);
angular.module('comps/user/drtv-login.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/drtv-login.html',
'<form class="form-signin" role="form" autocomplete="off" data-qa="login" ng-submit="doLogin()"><article class="content" ng-if="cmEnv.autoLogin"><select ng-model="formData.autologin" class="cm-form-control btn-block autologin" ng-change="changeAutologin()"><option value="none">{{\'LOGIN.PLACEHOLDER.AUTOLOGIN\'|cmTranslate}}</option><option ng-repeat="(user,prop) in loginData">{{user}}</option></select></article><hr class="margin-small no-margin-bottom" ng-if="cmEnv.autoLogin"><article class="content"><div class="cm-input-ctn" ng-class="{\'cm-input-error\':alertState!=\'\'}" cm-input-watcher><input tabindex="1" type="text" ng-model="formData.user" ng-class="{\'cm-input-error\':alertState!=\'\'}" id="user" name="user" value="" required placeholder="{{\'LOGIN.PLACEHOLDER.USERNAME\'|cmTranslate}}" cm-enter="doLogin()" cm-last-focus /></div></article><article class="content"><div class="cm-input-ctn with-inside-icon" ng-class="{\'cm-input-error\':alertState!=\'\'}" cm-input-watcher><input tabindex="2" type="{{passwordType}}" ng-model="formData.pass" ng-class="{\'cm-input-error\':alertState!=\'\'}" id="pw" name="pw" value="" required placeholder="{{\'LOGIN.PLACEHOLDER.PASSWORD\'|cmTranslate}}" cm-enter="doLogin()" cm-last-focus /><i class="fa cm-icon-grey" ng-class="{\'cm-visible\':passwordType==\'password\',\'cm-hidden\':passwordType==\'text\'}" ng-click="handlePassword($event)" cm-reactive></i></div></article><article class="content mb15" ng-hide="alertState==\'\'" data-qa="login-info"><cm-info-bubble class="cm-alert"><i class="fa cm-info"></i><span ng-bind-html="\'LOGIN.INFO.\'+alertState|cmParse"></span></cm-info-bubble></article><article class="content mb15 tar"><a href="#/password/lost" class="classic-link" data-qa="btn-passwordLost">{{\'LOGIN.LABEL.PASSWORD_LOST\'|cmTranslate}}</a></article><hr class="no-margin-top no-margin-bottom"><button class="btn-submit" type="submit"></button><article class="item" data-qa="login-submit-btn" ng-click="doLogin()" cm-reactive><span class="body tac" ng-show="!showLoader"><span class="with-icon">{{\'LOGIN.LABEL.SUBMIT\'|cmTranslate}}<i class="fa cm-key"></i></span></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></article></form>');
}]);
angular.module('comps/user/drtv-rekeying-modal.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/drtv-rekeying-modal.html',
'<div class="modal-row" data-qa="re-keying-modal"><span ng-bind-html="\'DRTV.BULK_REKEYING.CONTENT\'|cmTranslate"></span></div><button class="cm-btn-grey"><cm-loader cm-color="ci-color"></cm-loader></button>');
}]);
angular.module('comps/user/identity/drtv-identity-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/drtv-identity-create.html',
'<cm-scrollable><form name="cmForm" novalidate autocomplete="off"><article class="content"><cm-cameo-id ng-model="formData.cameoId" form-name="cmForm" cm-tabindex="1" placeholder="SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.CAMEOID" ></cm-cameo-id></article><hr class="margin-small" /><article class="content"><label>{{\'SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon"><input tabindex="2" data-qa="input-displayname" type="text" name="displayName" ng-model="formData.displayName" ng-keyup="validateDisplayName()" /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show=" cmForm.displayName.$dirty && cmForm.displayName.$invalid && cmForm.displayName.length > 0 "><div ng-show="cmForm.displayName.$error.required"><i class="fa cm-info"></i> {{\'SETTINGS.PAGES.IDENTITY.CREATE.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="3" cm-label="SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.PHONENUMBER" cm-info="SETTINGS.PAGES.IDENTITY.CREATE.INFO.INVALID.PHONENUMBER" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="4" cm-label="SETTINGS.PAGES.IDENTITY.CREATE.PLACEHOLDER.EMAIL" cm-info="SETTINGS.PAGES.IDENTITY.CREATE.INFO.INVALID.EMAIL" ></cm-form-email></form></cm-scrollable><cm-footer><button class="cm-btn-grey" ng-click="addIdentity()" data-qa="btn-identity-create" cm-reactive><span ng-show="!showLoader"> {{\'SETTINGS.PAGES.IDENTITY.CREATE.FOOTER\'|cmTranslate}} <i class="fa cm-checker"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/user/identity/drtv-identity-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/drtv-identity-edit.html',
'<cm-scrollable><article class="content edit-identity-head clearfix"><div class="cm-fl mr5"><cm-upload-avatar class="border-complete"></cm-upload-avatar><cm-avatar cm-data="identity" cm-avatar-view="{{chooseAvatar?\'unknown\':\'\'}}" ng-show="identity" class="big"></cm-avatar></div><div class="cm-fl w72"><ul class="no-border"><li class="cm-disabled" data-qa="btn-identity-trust"><span class="item clearfix"><span class="title single-line"><i class="fa cm-qr-code fa-2x"></i> {{\'IDENTITY.LABEL.TRUST\'|cmTranslate}}</span><section class="icon-list"><i class="fa cm-right position-exception"></i></section></span></li><li ng-click="goTo(\'/settings/identity/key/list\')" data-qa="btn-identity-keys" cm-reactive><span class="item clearfix"><span class="title single-line"><i class="fa cm-key fa-2x"></i> {{\'IDENTITY.LABEL.KEYMANAGEMENT\'|cmTranslate}}</span><section class="icon-list"><i class="fa cm-right position-exception"></i></section></span></li></ul></div></article><hr class="margin-small" /><form name="cmForm" novalidate autocomplete="off"><article class="content"><label>{{\'CONTACT.PLACEHOLDER.CAMEOID\'|cmTranslate}}</label><div class="cm-input-ctn is-selectable-all with-inside-left-icon" data-qa="ctn-cameoid"><i class="fa cm-rhino-positive"></i><span class="without-input"> {{identity.cameoId}}</span></div></article><hr class="margin-small" /><article class="content"><label>{{\'CONTACT.PLACEHOLDER.DISPLAYNAME\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon"><input tabindex="2" data-qa="input-displayname" type="text" name="displayName" ng-model="formData.displayName" ng-keyup="validateDisplayName();" /><i class="fa cm-write"></i></div><cm-info-bubble class="cm-alert" ng-show="cmForm.displayName.$dirty && cmForm.displayName.$invalid && cmForm.displayName.length > 0"><div ng-show="cmForm.displayName.$error.required"><i class="fa cm-info"></i> {{\'CONTACT.INFO.EMPTY.DISPLAYNAME\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small" /><cm-form-phonenumber ng-model="formData.phoneNumber" ng-model-out="formData.mergedPhoneNumber" cm-tabindex="3" cm-label="CONTACT.PLACEHOLDER.PHONENUMBER" cm-info="CONTACT.INFO.INVALID.PHONENUMBER" ></cm-form-phonenumber><hr class="margin-small" /><cm-form-email ng-model="formData.email" cm-tabindex="4" cm-label="CONTACT.PLACEHOLDER.EMAIL" cm-info="CONTACT.INFO.INVALID.EMAIL" ></cm-form-email></form></cm-scrollable><cm-footer><button class="cm-btn-grey" ng-click="saveIdentity()" data-qa="btn-saveIdentity" cm-reactive><span ng-show="!showLoader && !isPristine"> {{\'CONTACT.FOOTER.SAVE\'|cmTranslate}}<i class="fa cm-checker"></i></span><span ng-show="isPristine" data-qa="btn-pristineBack"> {{\'ACCOUNT.FOOTER.BACK\'|cmTranslate}}<i class="fa cm-out"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('comps/user/identity/drtv-identity-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/drtv-identity-list.html',
'<ul><li ng-repeat="identity in identities | orderBy:\'isActive\':false" ng-click="bam(identity)" cm-reactive ng-class="{\'isActive\': identity.isActive}" data-qa="identity-list-item"><cm-identity-tag cm-data="identity"></cm-identity-tag></li></ul>');
}]);
angular.module('comps/user/identity/drtv-identity.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/drtv-identity.html',
'<a data-qa="btn-identity-settings" ng-click="goToIdentity()" cm-reactive><cm-avatar cm-data="identity" class="mr5"></cm-avatar><span>{{identity.getDisplayName()}}</span></a>');
}]);
angular.module('comps/user/identity/key/drtv-identity-key-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/key/drtv-identity-key-create.html',
'<div class="section" ng-show="active == \'choose\'" data-qa="page-chose-keysize"><cm-scrollable ng-show="active == \'choose\'"><article class="mb15 content"><cm-info-bubble nose-x="50%"><span ng-bind-html="\'IDENTITY.KEYS.GENERATE.START.EXPLANATION\' | cmParse"></span></cm-info-bubble></article><ul><li><span class="item" ng-click="toggleKeySize()" data-qa="select-key-size" cm-reactive> {{\'IDENTITY.KEYS.GENERATE.START.KEY_LENGTH.BUTTON_LABEL\'|cmTranslate}} <strong>2048 (default)</strong></span><div class="short-links without-bg" ng-click="toggleKeySize()"><i class="fa" ng-class="{\'cm-down\':!showKeySize,\'cm-up\':showKeySize}"></i></div><ul class="cm-submenu no-border-bottom no-margin-top" ng-show="showKeySize"><li ng-click="chooseKeySize(\'2048\')" cm-reactive><span class="item" data-qa="keysize-2048">2048</span><div class="short-links without-bg"><i class="fa" ng-class="{\'cm-checkbox\':keySize != 2048,\'cm-checkbox-right\':keySize == 2048}"></i></div></li><li ng-click="chooseKeySize(\'4096\')" cm-reactive><span class="item" data-qa="keysize-4096">4096</span><div class="short-links without-bg"><i class="fa" ng-class="{\'cm-checkbox\':keySize != 4096,\'cm-checkbox-right\':keySize == 4096}"></i></div></li></ul></li></ul></cm-scrollable><cm-footer><button ng-click="generate()" class="cm-btn-grey" data-qa="btn-generate-key" cm-reactive> {{\'IDENTITY.KEYS.GENERATE.START.GENERATE_BUTTON\'|cmTranslate}}<i class="fa cm-checker"></i></button></cm-footer></div><div class="section" ng-show="active == \'generate\'" data-qa="page-generating-key"><cm-scrollable ng-show="active == \'generate\'"><h3 class="content" ng-bind-html="\'IDENTITY.KEYS.GENERATE.GENERATING.HEADLINE\' | cmParse"></h3><article class="key-generates content"><cm-info-bubble nose-x="55%"><span ng-bind-html="\'IDENTITY.KEYS.GENERATE.GENERATING.EXPLANATION\' | cmParse"></span></cm-info-bubble></article><hr class="margin-small" /><article class="content" ng-if = "active == \'generate\'"><span ng-bind-html="\'IDENTITY.KEYS.GENERATE.GENERATING.TIME_PASSED\'|cmParse"></span><cm-timeout cm-data="getElapsedTime()"><section class="cm-special-text"> {{\'IDENTITY.KEYS.GENERATE.GENERATING.GENERATION_TIMER\'|cmTranslate:{ \'time\':cmTimeout} }}</section></cm-timeout></article><hr class="margin-small" /><div class="space-for-loader"><cm-loader cm-halt="waiting" type="balls"></cm-loader></div></cm-scrollable><cm-footer><button ng-click="cancel()" class="cm-btn-grey" data-qa="btn-cancel-key-generation" cm-reactive> {{\'IDENTITY.KEYS.GENERATE.GENERATING.STOP_BUTTON\'|cmTranslate}}<i class="fa cm-checkbox-wrong"></i></button></cm-footer></div><div class="section" ng-show="active == \'store\'" data-qa="page-save-key"><cm-scrollable ng-show="active == \'store\'"><h3 class="content" ng-bind-html="\'IDENTITY.KEYS.GENERATE.SAVE.HEADLINE\' | cmParse"></h3><article class="key-generates content"><cm-info-bubble nose-x="55%"><span ng-bind-html="\'IDENTITY.KEYS.GENERATE.SAVE.EXPLANATION\' | cmParse"></span><br /><strong><span ng-bind-html="\'IDENTITY.KEYS.GENERATE.SAVE.NOTE\' | cmParse"></span></strong></cm-info-bubble></article><hr class="margin-small" /><article class="content" ng-if="active == \'store\'"><span ng-bind-html="\'IDENTITY.KEYS.GENERATE.SAVE.TIME_PASSED\'|cmParse"></span><cm-timeout cm-data="getElapsedTime()"><section class="cm-special-text">{{\'IDENTITY.KEYS.GENERATE.SAVE.GENERATION_TIMER\'|cmTranslate:{ \'time\':cmTimeout} }}</section></cm-timeout></article><hr class="margin-small" /><form><article class="content"><label>{{\'IDENTITY.KEYS.GENERATE.SAVE.KEY_NAME\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon"><input name="keyName" tabindex="1" type="text" ng-model="keyName" data-qa=\'input-key-name\' /><i class="fa cm-write"></i></div></article></form></cm-scrollable><cm-footer><button ng-click="store()" class="cm-btn-grey" data-qa="btn-save-key" cm-reactive><span ng-show="!showLoader"> {{\'IDENTITY.KEYS.GENERATE.SAVE.SAVE_BUTTON\'|cmTranslate}}<i class="fa cm-checker"></i></span><cm-loader ng-show="showLoader"></cm-loader></button></cm-footer></div>');
}]);
angular.module('comps/user/identity/key/drtv-identity-key-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/key/drtv-identity-key-edit.html',
'<cm-scrollable><article class="content mb15 is-selectable-all"><h3 data-qa="header-key-name">{{keyName}}</h3><cm-info-bubble ng-if="privKey" nose-x="30%"> {{\'SETTINGS.PAGES.IDENTITY.KEYS.EXPORT_KEY_DESCRIPTION\'|cmTranslate}}</cm-info-bubble></article><article class="content is-selectable-all"><h4 ng-if="privKey" class="is-local is-selectable">{{\'SETTINGS.PAGES.IDENTITY.KEYS.IS_LOCAL_ON_THIS_DEVICE\'|cmTranslate}}</h4><h4><strong>{{\'SETTINGS.PAGES.IDENTITY.KEYS.TRUSTING\'|cmTranslate}}:</strong><span ng-if="isTrusted" class="is-trusted"> {{\'SETTINGS.PAGES.IDENTITY.KEYS.IS_TRUSTED\'|cmTranslate}}</span><span ng-if="!isTrusted" class="is-untrusted"> {{\'SETTINGS.PAGES.IDENTITY.KEYS.IS_UNTRUSTED\'|cmTranslate}}</span></h4><h4><strong>{{\'SETTINGS.PAGES.IDENTITY.KEYS.KEY_SIZE\'|cmTranslate}}:</strong> {{keySize}}</h4></article><article class="content is-selectable-all"><h4 class="is-selectable"><strong>{{\'SETTINGS.PAGES.IDENTITY.KEYS.FINGERPRINT\'|cmTranslate}}:</strong></h4><cm-info-bubble nose-x="15%"><textarea class="form-control" readonly="readonly" data-qa="fingerprint-public-key" style="resize:none">{{fingerprint}}</textarea></cm-info-bubble></article><article class="content is-selectable-all"><div ng-if="privKey"><h3>{{\'SETTINGS.PAGES.IDENTITY.KEYS.PRIVATE_KEY\'|cmTranslate}}</h3><cm-info-bubble nose-x="15%"><textarea class="form-control" ng-model="privKey" readonly="readonly" data-qa="input-private-key" cm-clipboard></textarea></cm-info-bubble></div><div ng-if="privKey"><h3>{{\'SETTINGS.PAGES.IDENTITY.KEYS.PUBLIC_KEY\'|cmTranslate}}</h3><cm-info-bubble nose-x="15%"><textarea class="form-control" ng-model="pubKey" readonly="readonly" data-qa="input-public-key" cm-clipboard></textarea></cm-info-bubble></div></article></cm-scrollable><cm-footer cm-always-on-top ng-if="isTrusted && privKey && canAuthenticate"><button ng-click="startAuthentication()" class="cm-btn-grey is-selectable" data-qa="btn-start-authentication" cm-reactive> {{\'SETTINGS.PAGES.IDENTITY.HANDSHAKE.HANDSHAKE_START\'|cmTranslate}}<i class="fa cm-checker"></i></button></cm-footer>');
}]);
angular.module('comps/user/identity/key/drtv-identity-key-import.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/key/drtv-identity-key-import.html',
'<cm-scrollable><article class="content cm-form-style"><h3 ng-show="!isError">{{\'SETTINGS.PAGES.IDENTITY.KEYS.PRIVATE_KEY\'|cmTranslate}}</h3><textarea ng-model="privKey" ng-readonly="isValid" data-qa="display-private-key" ng-show="!isError"></textarea><h3 ng-if="isValid && keySize && !isError" class="mt15">{{\'SETTINGS.PAGES.IDENTITY.KEYS.KEY_SIZE\'|cmTranslate}}: {{keySize}}</h3><div ng-show="isValid && !isError"><h3>{{\'SETTINGS.PAGES.IDENTITY.KEYS.PUBLIC_KEY\'|cmTranslate}}</h3><textarea ng-model="pubKey" readonly="readonly" data-qa="display-public-key"></textarea><h3>{{\'SETTINGS.PAGES.IDENTITY.KEYS.KEY_NAME\'|cmTranslate}}</h3><div class="cm-input-ctn with-inside-icon"><input name="keyName" ng-model="keyName" type="text" data-qa="input-key-name" /><i class="fa cm-write"></i></div></div><cm-info-bubble class="cm-alert" ng-show="isError" data-qa="info-key-error"><i class="fa cm-info"></i> {{\'SETTINGS.PAGES.IDENTITY.KEYS.WARN.IMPORT_FAILED\'|cmTranslate}}</cm-info-bubble></article></cm-scrollable><cm-footer><button ng-click="import()" class="cm-btn-grey" data-qa="btn-import-key" ng-if="!isValid && !isError" cm-reactive> {{\'SETTINGS.PAGES.IDENTITY.KEYS.IMPORT.BUTTON\'|cmTranslate}}<i class="fa cm-checker"></i></button><button ng-click="store()" class="cm-btn-grey" data-qa="btn-save-key" ng-if="isValid && !isError" cm-reactive><span ng-show="!showLoader"> {{\'SETTINGS.PAGES.IDENTITY.KEYS.STORE_KEYPAIR\'|cmTranslate}}<i class="fa cm-checker"></i></span><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button><button ng-click="goTo(\'/settings/identity/key/list\')" class="cm-btn-grey" data-qa="btn-import-error" ng-if="isError" cm-reactive> {{\'NAVIGATION.TABS.BACK\'|cmTranslate}}<i class="fa cm-out"></i></button></cm-footer>');
}]);
angular.module('comps/user/identity/key/drtv-identity-key-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/user/identity/key/drtv-identity-key-list.html',
'<cm-scrollable><article ng-if="showNoLocalKeysOnThisDevice" class="content mb15"><cm-info-bubble nose-x="50%"><div class="page in-screen-message" data-qa="message-no-keys" ng-bind-html="::\'SETTINGS.PAGES.IDENTITY.KEYS.NO_LOCALKEYS_ON_THIS_DEVICE\'|cmParse"></div></cm-info-bubble></article><article ng-if="showUntrustedPublickeysExists" class="content mb15"><cm-info-bubble nose-x="50%"><div class="page in-screen-message" data-qa="message-untrusted-keys" ng-bind-html="::\'SETTINGS.PAGES.IDENTITY.KEYS.UNTRUSTED_PUBLICKEYS_EXISTS\'|cmParse"></div></cm-info-bubble></article><ul ng-if="(publicKeys.length > 0)" ng-class="{\'no-border-top\':(!showNoLocalKeysOnThisDevice && !showUntrustedPublickeysExists)}"><li ng-if = "!canCreate && someKeyNeedsAuthentication()" ng-click = "goTo(\'/authentication\')" data-qa = "li-some-key-needs-authentication" cm-reactive ><span class="item clearfix"><span class="title"><i class="fa cm-handshake" ng-class="overview[page].icon"></i><span>{{::\'IDENTITY.KEYS.AUTHENTICATION.HEADLINE\'|cmTranslate}}</span></span><section class="icon-list"><i class="fa cm-right"></i></section></span></li><li class="key-list-item no-pad" ng-repeat="key in publicKeys | orderBy:sortByPrivKeys" data-qa="key-list-item"><section ng-click="goTo(\'settings/identity/key/edit/\'+key.id)" class="item tal" cm-reactive ><strong>{{::key.name}}</strong><span class="second-row"> {{:: privateKeys.find(key).getSize() || key.getSize() || key.size}}<span class="seperator">|</span><strong ng-if="privateKeys.find(key)" data-qa="key-is-local" class="is-local">{{::\'SETTINGS.PAGES.IDENTITY.KEYS.IS_LOCAL\'|cmTranslate}}<span class="seperator">|</span></strong><span ng-if="stillChecking(key)" class="is-checking"> ???<span class="seperator">|</span></span><span ng-if="!stillChecking(key) && isTrustedKey(key)" class="is-trusted">{{::\'SETTINGS.PAGES.IDENTITY.KEYS.IS_TRUSTED\'|cmTranslate}}<span class="seperator">|</span></span><span ng-if="!stillChecking(key) && !isTrustedKey(key)" class="is-untrusted">{{::\'SETTINGS.PAGES.IDENTITY.KEYS.IS_UNTRUSTED\'|cmTranslate}}<span class="seperator">|</span></span> {{:: key.created | date:\'dd.MM.yy - HH:mm\'}}</span></section><section class="icon-list" ng-class="{\'with-two-icons\':showHandshake(key)}"><i class="fa cm-handshake" ng-if="showHandshake(key)" ng-click="goTo(\'/authentication/\'+key.id, true)" data-qa="btn-start-handshake" cm-reactive></i><i class="fa cm-cancel-key" ng-click="remove(key)" data-qa="btn-remove-modal" cm-reactive></i></section></li><li ng-if="signing"><cm-loader></cm-loader></li></ul><article class="content" ng-if="!canCreate && someKeyNeedsAuthentication()" data-qa= "bubble-some-key-needs-authentication"><cm-info-bubble nose-x="18%"><span ng-bind-html="::\'IDENTITY.KEYS.KEYLIST.EXPLANATION.UNTRUSTED_KEYS\' | cmParse"></span></cm-info-bubble></article></cm-scrollable><cm-footer ng-if="canCreate" data-qa="canCreate"><button class="cm-btn-grey dib w50" data-qa="btn-create-key" ng-click="goTo(\'/settings/identity/key/create\')" cm-reactive> {{::\'SETTINGS.PAGES.IDENTITY.KEYS.CREATE.BUTTON\'|cmTranslate}}<i class="fa cm-create-key"></i></button><button class="cm-btn-grey dib w50" data-qa="btn-import-key" ng-click="goTo(\'/settings/identity/key/import\')" cm-reactive> {{::\'SETTINGS.PAGES.IDENTITY.KEYS.IMPORT.BUTTON\'|cmTranslate}}<i class="fa cm-import-key n"></i></button></cm-footer>');
}]);
angular.module('cmUser',[
    'cmCore',
    'cmFiles',
    'cmUi'
,'comps/user/drtv-account-edit.html','comps/user/drtv-incoming-authentication-request.html','comps/user/drtv-login-modal.html','comps/user/drtv-login.html','comps/user/drtv-rekeying-modal.html','comps/user/identity/drtv-identity-create.html','comps/user/identity/drtv-identity-edit.html','comps/user/identity/drtv-identity-list.html','comps/user/identity/drtv-identity.html','comps/user/identity/key/drtv-identity-key-create.html','comps/user/identity/key/drtv-identity-key-edit.html','comps/user/identity/key/drtv-identity-key-import.html','comps/user/identity/key/drtv-identity-key-list.html'])

    .directive('cmAccountEdit', [
        'cmUserModel', 'cmNotify', 'cmCrypt', 'cmLoader', 'cmUtil', 'cmPristine',
        '$q', '$rootScope',
        function(cmUserModel, cmNotify, cmCrypt, cmLoader, cmUtil, cmPristine,
                 $q, $rootScope){
            return {
                restrict: 'E',
                templateUrl: 'comps/user/drtv-account-edit.html',
                controller: function ($scope) {
                    var loader = new cmLoader($scope);

                    $scope.account = cmUserModel.data.account;

                    $scope.showPasswordChange = false;
                    $scope.showReadOnly = false;

                    $scope.togglePasswordChange = function(action){
                        if(action == 'close' && !$scope.showPasswordChange)
                            return false;

                        $scope.showPasswordChange = action && action == 'close' || $scope.showPasswordChange ? false : true;

                        if(!$scope.showPasswordChange){
                            $scope.formData.oldPassword = '';
                            $scope.formData.password = '';
                            $rootScope.$broadcast('cm-password:reset');
                        }
                    };

                    $scope.toggleReadOnly = function(){
                        $scope.showReadOnly = true;
                    };

                    function reset(){
                        var phoneNumber = $scope.account.phoneNumber ? $scope.account.phoneNumber.value : '';

                        $scope.formData = {
                            phoneNumber: phoneNumber,
                            mergedPhoneNumber: phoneNumber,
                            email: $scope.account.email ? $scope.account.email.value : '',
                            oldPassword: '',
                            password: ''
                        }
                    }

                    cmUserModel.on('account:updated', reset);

                    reset();

                    $scope.validateForm = function(){
                        var deferred = $q.defer(),
                            objectChange = {};

                        function checkPhoneNumber() {
                            var defValue = $scope.account.phoneNumber,
                                value = $scope.formData.mergedPhoneNumber;

                            if (value != undefined
                                && (!defValue || (defValue && value != defValue.value))) {
                                objectChange.phoneNumber = value;
                            }
                        }

                        function checkEmail() {
                            var defValue = $scope.account.email,
                                value = $scope.formData.email;
                            if (value != undefined
                                && (!defValue || (defValue && value != defValue.value))) {
                                objectChange.email = value;
                            }
                        }

                        function checkPassword(){
                            if(!$scope.showPasswordChange) {
                                $scope.cmForm.password.$setValidity('empty', true);
                                $scope.cmForm.oldPassword.$setValidity('empty', true);
                                return false;
                            }

                            // check password
                            if ($scope.formData.oldPassword != ''
                                && $scope.formData.oldPassword!= 'none'
                                && $scope.formData.oldPassword != undefined) {
                                objectChange.oldPassword = cmCrypt.hash($scope.formData.oldPassword);
                                $scope.cmForm.oldPassword.$setValidity('empty', true);
                                $scope.cmForm.oldPassword.$setValidity('invalid', true);
                            }

                            if ($scope.formData.password == ''
                                || $scope.formData.password == 'none'
                                || $scope.formData.password == undefined) {
                                $rootScope.$broadcast('cm-password:empty');
                            } else {
                                objectChange.password = $scope.formData.password;
                            }
                        }

                        checkPhoneNumber();
                        checkEmail();
                        checkPassword();

                        if($scope.cmForm.$valid !== false && Object.keys(objectChange).length > 0){
                            deferred.resolve(objectChange);
                        } else {
                            deferred.reject();
                        }

                        return deferred.promise;
                    };

                    $scope.saveAccount = function(){
                        if($scope.isPristine){
                            $scope.goTo('/settings');
                            return false;
                        }

                        if(loader.isIdle())
                            return false;

                        loader.start();

                        $scope.validateForm().then(
                            function(objectChange){
                                cmUserModel.updateAccount(objectChange)
                                    .then(
                                    function(){
                                        loader.stop();
                                        cmPristine.resetView($scope);
                                        $scope.togglePasswordChange('close');
                                    },
                                    function(result){

                                        switch(result.data.error){
                                            case 'old password required':
                                                $scope.cmForm.oldPassword.$setValidity('empty', false);
                                                break;
                                            case 'invalid old password':
                                                $scope.cmForm.oldPassword.$setValidity('invalid', false);
                                                break;
                                        }

                                        loader.stop();
                                    }
                                );

                            }, function(){
                                loader.stop();
                                cmUtil.scrollToInputError()
                            }
                        )
                    };

                    /**
                     * Pristine Service Handling
                     */
                    cmPristine.initView($scope);
                }
            }
        }
    ])
.directive('cmAutocomplete', [
    function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {

            }
        }
    }
])

.directive('cmIncomingAuthenticationRequest',[
    'cmUserModel', 'cmIdentityFactory', 'cmLoader',
    '$timeout', '$document',
    function (cmUserModel, cmIdentityFactory, cmLoader,
                $timeout, $document){
        return {
            restrict:       'E',
            scope:          false,
            templateUrl:    'comps/user/drtv-incoming-authentication-request.html',
            link: function(scope){
                var loader  = new cmLoader(scope),
                    btns    = $document[0].querySelectorAll('footer button');

                scope.isIdle = function(){
                    return loader.isIdle();
                };

                scope.startLoader = function(){
                    loader.start();

                    angular.forEach(btns,
                        function(button){
                            var e = angular.element(button);
                            if(e.hasClass('with-loader')){
                                e.removeClass('cm-hide');
                            } else {
                                e.addClass('cm-hide');
                            }
                        }
                    );
                };

                scope.stopLoader = function(){
                    angular.forEach(btns,
                        function(button){
                            var e = angular.element(button);
                            if(e.hasClass('with-loader')){
                                e.addClass('cm-hide');
                            } else {
                                e.removeClass('cm-hide');
                            }
                        }
                    );

                    loader.stop();
                };
            },
            controller: function($scope){
                function setErrorsToDefault(){
                    $scope.error = {
                        "emptyInput": false,
                        "wrongSecret": false
                    };
                }

                function refresh(){
                    $scope.is3rdParty    =   $scope.request.fromIdentityId != cmUserModel.data.identity.id;
                    $scope.fromIdentity  =   cmIdentityFactory.find($scope.request.fromIdentityId);
                    $scope.fromKey       =   $scope.fromIdentity.keys.find($scope.request.fromKeyId);

                    $scope.modalMessageVars = {
                        cameoKey: $scope.fromKey.name,
                        identity: $scope.fromIdentity.getDisplayName()
                    };

                    setErrorsToDefault();

                    $scope.transactSecret = '';

                    $timeout(function(){
                        var input = $document[0].querySelector('#inp-transactSecret');
                        input.focus();
                    }, 50);
                }

                $scope.$watch('request', refresh);
            }
        }
    }
])
.directive('cmLoginModal', [
    'cmNotify',
    'cmUserModel',
    'cmKeyStorageService',
    'cmCrypt',
    'cmConfig',
    'cmEnv',
    'cmLoader',
    '$location',
    function (cmNotify, cmUserModel, cmKeyStorageService, cmCrypt, cmConfig, cmEnv, cmLoader,
              $location) {
        return  {
            restrict    :   'AE',
            templateUrl :   'comps/user/drtv-login-modal.html',
            scope       :   {},
            controller  :   function ($scope, $rootScope) {
                $scope.cmEnv = cmEnv;
                var loader = new cmLoader($scope);
                $scope.alertState = '';
                $scope.passwordType = 'password';
                $scope.loginData = cmConfig.autoLoginData;

                $scope.formData = {
                    autologin:'none'
                };

                function checkPasswordLength(pw){
                    if(typeof pw != 'string' || (pw.length > 0 && pw.length < 6)){
                        return false;
                    }

                    return true;
                }

                $scope.handlePassword = function(){
                    $scope.passwordType = ($scope.passwordType != 'password')
                        ? 'password'
                        : 'text';
                };

                $scope.checkPasswordLength = function(){
                    if($scope.formData.pass.length > 0 && $scope.formData.pass.length < 6){
                        return true;
                    }

                    return false;
                };

                $scope.changeAutologin = function(){
                    if($scope.formData.autologin != 'none'){
                        $scope.formData.user = $scope.loginData[$scope.formData.autologin].user;
                        $scope.formData.pass = $scope.loginData[$scope.formData.autologin].pass;
                    } else {
                        $scope.formData.user = "";
                        $scope.formData.pass = "";
                    }
                };

                $scope.doLogin = function(){
                    if(loader.isIdle())
                        return false;

                    $scope.alertState = '';
                    loader.start();

                    if(!checkPasswordLength($scope.formData.pass)){
                        loader.stop();
                        $scope.alertState = 'PW';
                        return false;
                    }

                    cmUserModel.doLogin(
                        $scope.formData.user,
                        cmCrypt.hash($scope.formData.pass)
                    )
                        .then(
                        function(){
                            var storageService = new cmKeyStorageService('appSettings'),
                                skipKeyInfo = storageService.get('skipKeyInfo') || false;

                            if(!$location.$$path.match(/\/purl\/.*/)){
                                if(cmUserModel.loadLocalKeys().length == 0 && skipKeyInfo == false){
                                    $rootScope.goto("/start/keyinfo");
                                } else {
                                    $rootScope.goto("/talks");
                                }
                            }
                            $rootScope.$broadcast('cmLogin:success');
                        },
                        function(error){
                            loader.stop();
                            //$rootScope.$broadcast('cmLogin:error'); // not use in app - BS 21.08.2014

                            if(typeof error == 'object' && 'status' in error){
                                if(error.status){
                                    $scope.alertState = error.status;
                                } else {
                                    $scope.alertState = 'X';
                                }
                            } else {
                                $scope.alertState = 'X';
                            }
                        }
                    );

                    return true;
                };
            }
        }
    }
])

.directive('cmLogin', [
    'cmNotify', 'cmUserModel', 'cmKeyStorageService', 'cmCrypt',
    'cmConfig', 'cmEnv', 'cmLoader', 'cmKeyboard',
    '$location', '$rootScope',
    function (cmNotify, cmUserModel, cmKeyStorageService, cmCrypt,
              cmConfig, cmEnv, cmLoader, cmKeyboard,
              $location, $rootScope) {
        return  {
            restrict    :   'AE',
            templateUrl :   'comps/user/drtv-login.html',
            scope       :   {},
            controller  :   function ($scope) {
                $scope.cmEnv = cmEnv;
                var loader = new cmLoader($scope);
                $scope.alertState = '';
                $scope.passwordType = 'password';
                $scope.loginData = cmConfig.autoLoginData;

                $scope.formData = {
                    autologin:'none'
                };

                function checkPasswordLength(pw){
                    if(typeof pw != 'string' || (pw.length > 0 && pw.length < 6)){
                        return false;
                    }

                    return true;
                }

                $scope.handlePassword = function(event){
                    cmKeyboard.focusLast(event);
                    $scope.passwordType = ($scope.passwordType != 'password')
                        ? 'password'
                        : 'text';
                };

                $scope.checkPasswordLength = function(){
                    if($scope.formData.pass.length > 0 && $scope.formData.pass.length < 6){
                        return true;
                    }

                    return false;
                };

                $scope.changeAutologin = function(){
                    if($scope.formData.autologin != 'none'){
                        $scope.formData.user = $scope.loginData[$scope.formData.autologin].user;
                        $scope.formData.pass = $scope.loginData[$scope.formData.autologin].pass;
                    } else {
                        $scope.formData.user = "";
                        $scope.formData.pass = "";
                    }
                };

                $scope.doLogin = function(){
                    if(loader.isIdle())
                        return false;

                    $scope.alertState = '';
                    loader.start();

                    if(!checkPasswordLength($scope.formData.pass)){
                        loader.stop();
                        $scope.alertState = 'PW';
                        return false;
                    }

                    cmUserModel.doLogin(
                        $scope.formData.user,
                        cmCrypt.hash($scope.formData.pass)
                    )
                    .then(
                        function(){
                            var storageService = new cmKeyStorageService('appSettings'),
                                skipKeyInfo = storageService.get('skipKeyInfo') || false;

                            if(!$location.$$path.match(/\/purl\/.*/)){

                                if(typeof cmUserModel.data.account.registrationIncomplete != 'undefined' && cmUserModel.data.account.registrationIncomplete == true){
                                    $rootScope.goTo("/setup/account");
                                } else if(!cmUserModel.hasLocalKeys() && skipKeyInfo == false){
                                    $rootScope.goTo("/setup/keyinfo");
                                } else {
                                    $rootScope.goTo("/talks");
                                }
                            }
                        },
                        function(error){
                            loader.stop();
                            //$rootScope.$broadcast('cmLogin:error'); // not use in app - BS 21.08.2014

                            if(typeof error == 'object' && 'status' in error){
                                if(error.status){
                                    $scope.alertState = error.status;
                                } else {
                                    $scope.alertState = 'X';
                                }
                            } else {
                                $scope.alertState = 'X';
                            }
                        }
                    );

                    return true;
                };
            }
        }
    }
])
.directive('cmReKeyingModal',[
    'cmLoader',
    function (cmLoader){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/drtv-rekeying-modal.html',
            controller: function($scope){
                var loader = new cmLoader($scope);

                loader.start();
            }
        }
    }
])
.directive('cmUserRights', [
    'cmUserModel',
    function (cmUserModel) {
        return {
            restrict : 'AE',
            link: function(scope, element, attrs){
                function removeElement(){
                    // remove for guest
                    if(cmUserModel.isGuest() !== false && attrs['cmUserRights'] == ''){
                        element.remove();
                    // remove for logged user
                    } else if(attrs['cmUserRights'] == 'showForGuest' && cmUserModel.isGuest() === false) {
                        element.remove();
                    }
                }

                cmUserModel.on('update:finished',function(){
                    removeElement();
                });

                removeElement();
            }
        }
    }
])
.directive('cmIdentityCreate', [
    'cmAuth', 'cmNotify', 'cmUserModel', 'cmLoader',
    '$location', '$q', '$rootScope',
    function(cmAuth, cmNotify, cmUserModel, cmLoader,
             $location, $q, $rootScope){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/identity/drtv-identity-create.html',
            controller: function ($scope) {

                var loader = new cmLoader($scope);

                function reset() {
                    $scope.formData = {
                        cameoId: '',
                        email: '',
                        phoneNumber: '',
                        mergedPhoneNumber: '',
                        displayName: ''
                    };
                }

                reset();

                $scope.validateDisplayName = function(){
                    if($scope.formData.displayName == undefined
                    || $scope.formData.displayName.length == 0
                    ){
                        $scope.cmForm.displayName.$pristine = true;
                        $scope.cmForm.displayName.$dirty = false;
                    }
                };

                $scope.validateForm = function(){
                    var deferred = $q.defer(),
                        objectChange = {};

                    function checkCameoId() {
                        var value = $scope.formData.cameoId;
                        if (value && value != '') {
                            objectChange.cameoId = value;
                            objectChange.reservationSecret = $scope.reservationSecrets[objectChange.cameoId];
                        }
                    }

                    function checkDisplayName() {
                        var value = $scope.formData.displayName;
                        if (value != undefined
                         && value != '') {
                            objectChange.displayName = value;
                        }
                    }

                    function checkPhoneNumber() {
                        var value = $scope.formData.mergedPhoneNumber;
                        if (value != undefined
                         && value != '') {
                            objectChange.phoneNumber = value;
                        }
                    }

                    function checkEmail() {
                        var value = $scope.formData.email;
                        if (value != undefined
                         && value != '') {
                            objectChange.email = value;
                        }
                    }

                    // check loginName aka cameoId
                    if ($scope.cmForm.cameoId.$valid == false) {
                        if($scope.cmForm.cameoId.$viewValue == undefined
                        || $scope.cmForm.cameoId.$viewValue.toString() == ''
                        ){
                            $rootScope.$broadcast('cm-login-name:invalid');
                        }
                    }

                    checkCameoId();
                    checkDisplayName();
                    checkPhoneNumber();
                    checkEmail();

                    if($scope.cmForm.$valid !== false && Object.keys(objectChange).length > 0){
                        deferred.resolve(objectChange);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.addIdentity = function(){
                    if(loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm().then(
                        function(objectChange){
                            cmAuth.addIdentity(objectChange).then(
                                function(res){
                                    loader.stop();
                                    cmUserModel.switchToIdentity(res.identity, res.token.token);
                                },
                                function(){
                                    loader.stop();
                                    cmNotify.warn('SETTINGS.PAGES.IDENTITY.CREATE.WARN.FAILED');
                                }
                            );
                            reset();
                        },
                        function(){
                            loader.stop();
                        }
                    )
                };
            }
        }
    }
])
.directive('cmIdentityEdit', [
    'cmUserModel', 'cmNotify', 'cmLoader', 'cmUtil', 'cmPristine',
    '$q', '$rootScope',
    function(cmUserModel, cmNotify, cmLoader, cmUtil, cmPristine,
             $q, $rootScope){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/identity/drtv-identity-edit.html',
            controller: function ($scope) {

                var loader = new cmLoader($scope);

                $scope.identity = cmUserModel.data.identity;

                function reset(){
                    $scope.formData = {
                        displayName: $scope.identity.displayName,
                        phoneNumber: $scope.identity.phoneNumber ? $scope.identity.phoneNumber.value : '',
                        mergedPhoneNumber: '',
                        email: $scope.identity.email ? $scope.identity.email.value : ''
                    };
                }

                if(('identity' in cmUserModel.data)
                && !('on' in cmUserModel.data.identity)){
                    cmUserModel.on('update:finished', function(){
                        reset();
                        cmUserModel.data.identity.on('update:finished', reset);
                    });
                } else {
                    cmUserModel.data.identity.on('update:finished', reset);
                }

                reset();

                $scope.goToKeys = function(){
                    $scope.goTo('/settings/identity/key/list');
                };

                $scope.validateDisplayName = function(){
                    if($scope.formData.displayName == undefined || $scope.formData.displayName.length == 0){
                        $scope.cmForm.displayName.$pristine = true;
                        $scope.cmForm.displayName.$dirty = false;
                    }
                };

                $scope.validateForm = function(){
                    var deferred = $q.defer(),
                        objectChange = {};

                    function checkDisplayName() {
                        var value = $scope.formData.displayName;
                        if (value != $scope.identity.displayName) {
                            objectChange.displayName = value;
                        }
                    }

                    function checkPhoneNumber() {
                        var value = $scope.formData.mergedPhoneNumber;
                        if (value != undefined
                         && value != $scope.identity.phoneNumber.value) {
                            objectChange.phoneNumber = value;
                        }
                    }

                    function checkEmail() {
                        var value = $scope.formData.email;
                        if (value != undefined
                            && value != $scope.identity.email.value) {
                            objectChange.email = value;
                        }
                    }

                    checkDisplayName();
                    checkPhoneNumber();
                    checkEmail();

                    if($scope.cmForm.$valid !== false && Object.keys(objectChange).length > 0){
                        deferred.resolve(objectChange);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.saveIdentity = function(){
                    if($scope.isPristine)
                        $scope.goTo('/settings/identity/list');

                    if(loader.isIdle())
                        return false;

                    loader.start();

                    $scope.validateForm()
                    .then(
                        function(objectChange){
                            cmUserModel.data.identity.one('update:finished',function(){
                                loader.stop();
                                cmPristine.resetView($scope);
                                reset();
                            });

                            cmUserModel.data.identity.update(objectChange);
                        },
                        function(){
                            loader.stop();
                            cmUtil.scrollToInputError()
                        }
                    )
                };

                /**
                 * Pristine Service Handling
                 */
                cmPristine.initView($scope);
            }
        }
    }
])
.directive('cmIdentityList', [
    'cmUserModel',
    '$rootScope',
    function(cmUserModel, $rootScope){
        return {
            restrict: 'E',
            scope: {
                identities: "=cmIdentities"
            },
            templateUrl: 'comps/user/identity/drtv-identity-list.html',
            controller: function ($scope) {
                $scope.switchToIdentity = function(identity){
                    cmUserModel.switchToIdentity(identity);
                };

                $scope.bam = function(identity){
                    if(identity.isActive == true){
                        $rootScope.goTo('/settings/identity/edit');
                    } else {
                        $scope.switchToIdentity(identity);
                    }
                };
            }
        }
    }
])
.directive('cmIdentity',[
    'cmUserModel', 'cmModal',
    '$rootScope', '$timeout',
    function (cmUserModel, cmModal,
              $rootScope, $timeout){
        return {
            restrict: 'AE',
            templateUrl: 'comps/user/identity/drtv-identity.html',
            scope: true,

            controller: function($scope){
                $scope.randModalId = Math.floor((Math.random()*6)+1);

                function setIdentity(){
                    $scope.identity = cmUserModel.data.identity;
                }

                setIdentity();

                cmUserModel.on('update:finished',function(){
                    setIdentity();
                });

                $scope.goToIdentity = function(){
                    $rootScope.goto('/settings/identity/list');
                };
            }
        }
    }
])
.directive('cmIdentityKeyCreate', [
    'cmUserModel', 'cmCrypt', 'cmUtil', 'cmLogger', 'cmNotify',
    'cmKey', 'cmJob', 'cmApi', 'cmDevice', 'cmLoader', 'cmHistory',
    '$window', '$rootScope',  '$timeout',
    function(cmUserModel, cmCrypt, cmUtil, cmLogger, cmNotify,
             cmKey, cmJob, cmApi, cmDevice, cmLoader, cmHistory,
             $window, $rootScope, $timeout){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/identity/key/drtv-identity-key-create.html',

            controller: function ($scope) {

                var loader = new cmLoader($scope);

                // only one privKey!!!
                if(cmUserModel.hasPrivateKey()){
                    if(cmHistory.comesFrom('/authentication')){
                        $scope.goTo('/talks', true);
                    } else {
                        $scope.goTo('/settings/identity/key/list', true);
                    }

                    return false;
                }

                $scope.identity = cmUserModel.data;

                /**
                 * scope vars for keypair generation
                 * @type {string[]}
                 */
                var detect      = cmDevice.detectOSAndBrowser(),
                    startTime   = undefined,
                    elapsedTime = 0,
                    generationTimeout = null,
                    generationTimeoutMinutes = 10;

                $scope.active = 'choose'; // choose, active, store
                //$scope.keySizes = cmCrypt.getKeySizes();
                $scope.keySize = 2048;
                $scope.keyName = '';

                $scope.showKeySize = false;
                $scope.toggleKeySize = function(){
                    if(!$scope.showKeySize){
                        $scope.showKeySize = true;
                    } else {
                        $scope.showKeySize = false;
                    }
                };

                $scope.keySize = 2048;
                $scope.chooseKeySize = function(size){
                    if(size == '4096'){
                        $scope.keySize = 4096;
                    } else {
                        $scope.keySize = 2048;
                    }
                };

                $scope.getElapsedTime = function(){
                    elapsedTime =   startTime 
                                    ?   Math.ceil(Math.max(new Date().getTime() - startTime, 0))
                                    :   Math.ceil(elapsedTime);
                    return elapsedTime;
                };

                function reset(){
                    $timeout.cancel(generationTimeout);
                    cmApi.listenToEvents();
                    cmJob.stop();
                }

                /**
                 * generate keypair
                 */
                $scope.generate = function(withoutTimerReset){
                    // generation timeout for very long generation
                    // especially for iphone 4/4s ios7 uiwebview
                    
                    $timeout.cancel(generationTimeout);
                    generationTimeout = $timeout(function(){
                        $scope.cancelGeneration();
                        $scope.generate(true);
                    },generationTimeoutMinutes * 60 * 1000);



                    $scope.active = 'generate';
                    cmJob.start('DRTV.CONFIRM.STANDARD', $scope.cancelGeneration);

                    var size = 2048;
                    if($scope.keySize == 4096){
                        size = 4096;
                    }

                    /**
                     * call cmCrypt to generate KeyPair
                     * with keySize and callback for onGeneration
                     * returns a promise
                     */
                    cmApi.stopListeningToEvents();

                    if(!withoutTimerReset) {
                        startTime = new Date().getTime();
                        elapsedTime = 0;
                    }

                    cmCrypt.generateAsyncKeypair(parseInt(size))
                    .then(
                        function(result){
                            $scope.privKey  = result.key.getPrivateKey();
                            $scope.pubKey   = result.key.getPublicKey();
                            $scope.keyName  = detect.os+' / '+detect.browser;

                            $scope.active = 'store';
                        },
                        function(reason){
                            $scope.active = 'choose';
                        }
                    ).finally(
                        function(){
                            reset();
                            startTime = undefined
                        }
                    );
                };

                $scope.$on('$destroy',function(){
                    reset();
                });


                $scope.cancel = function(){

                    cmCrypt.cancelGeneration()
                    .then(function(){
                        reset();
                        startTime = undefined;

                        if(typeof $rootScope.generateAutomatic != 'undefined'){
                            /**
                             * @TODO siwtch auch, wenn noch keine Talks vorhanden sind
                             */
                            $scope.goTo('/talks');
                        } else {
                            $scope.goBack();
                        }
                        
                    })
                };

                /**
                 * store key pair
                 */
                $scope.store = function(){
                    if(loader.isIdle())
                        return false;

                    loader.start();

                    var error = false;

                    if($scope.privKey == '' || !$scope.privKey){
                        error = true;
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.CHECK_PRIVKEY');
                    }

                    if($scope.pubKey == '' || !$scope.pubKey){
                        error = true;
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.CHECK_PUBKEY');
                    }

                    if($scope.keyName == ''){
                        error = true;
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.CHECK_KEYNAME');
                    }

                    if(error !== true){
                        var key = new cmKey({
                            name: $scope.keyName,
                            privKey: $scope.privKey
                        });

                        cmUserModel
                            .storeKey(key)
                            .syncLocalKeys();

                        cmUserModel
                            .when('key:saved', null, 5000)
                            .then(
                                function(result){
                                    if(cmUserModel.data.identity.keys.some(function(key){
                                        return key.id != result.data.keyId
                                    })){
                                        $scope.goTo('/authentication')
                                    } else {
                                        $scope.goTo('/talks');
                                    }
                                }
                            );

                        cmJob.stop();
                        loader.stop();
                    } else {
                        loader.stop();
                    }
                };

                var generateAutomatic = false;
                if(typeof $rootScope.generateAutomatic != 'undefined'){
                    if('generate' in $rootScope.generateAutomatic && $rootScope.generateAutomatic.generate == true){
                        generateAutomatic = true;

                        if('keySize' in $rootScope.generateAutomatic && parseInt($rootScope.generateAutomatic.keySize) == 4096){
                            $scope.keySize = 4096;
                        } else {
                            $scope.keySize = 2048;
                        }

                        $scope.generate();
                    }
                    $rootScope.generateAutomatic = {}
                }
            }
        }
    }
])
.directive('cmIdentityKeyEdit', [
    'cmNotify', 'cmKey', 'cmUtil', 'cmUserModel',
    '$rootScope', '$routeParams',
    function(cmNotify, cmKey, cmUtil, cmUserModel,
             $rootScope, $routeParams){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/identity/key/drtv-identity-key-edit.html',
            controller: function ($scope) {
                var localKeys   = cmUserModel.loadLocalKeys(),
                    key         = localKeys.find($routeParams.keyId) || cmUserModel.data.identity.keys.find($routeParams.keyId) || {};

                $scope.privKey      = key && key.getPrivateKey();
                $scope.pubKey       = key && key.getPublicKey();
                $scope.keyName      = key && key.name;
                $scope.keySize      = key && key.getSize();
                $scope.fingerprint  = key && key.getFingerprint();

                $scope.isTrusted    = undefined

                cmUserModel.verifyOwnPublicKey(key)
                .then(function(){
                    $scope.isTrusted = true
                })

            }
        }
    }
])

.directive('cmIdentityKeyImport', [
    'cmNotify',
    'cmKey',
    'cmUtil',
    'cmUserModel',
    'cmModal',
    'cmDevice',
    'cmLoader',
    '$window',
    '$rootScope',
    function(cmNotify, cmKey, cmUtil, cmUserModel, cmModal, cmDevice, cmLoader,
             $window, $rootScope){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/identity/key/drtv-identity-key-import.html',
            controller: function ($scope) {
                // only one privKey!!!
                if(cmUserModel.hasPrivateKey()){
                    $rootScope.goTo('/settings/identity/key/list', true);
                    return false;
                }

                var loader = new cmLoader($scope);

                $scope.isValid = false;
                $scope.isError = false;

                var detect = cmDevice.detectOSAndBrowser();

                $scope.import = function(){
                    var key = (new cmKey()).importData({
                        name: $scope.keyName,
                        privKey: $scope.privKey
                    });

                    if(!key.getPrivateKey() || !key.getPublicKey() || !key.getSize()){
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.IMPORT_FAILED')
                    } else {
                        $scope.isValid = true;
                        $scope.pubKey = key.getPublicKey();
                        $scope.keyName = detect.os+' / '+detect.browser;
                        $scope.keySize = key.getSize();
                    }
                };

                $scope.store = function(){
                    var error = false;

                    if (loader.isIdle())
                        return false;

                    if($scope.privKey == ''){
                        error = true;
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.CHECK_PRIVKEY');
                    }

                    if($scope.pubKey == ''){
                        error = true;
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.CHECK_PUBKEY');
                    }

                    if($scope.keyName == ''){
                        error = true;
                        cmNotify.warn('SETTINGS.PAGES.IDENTITY.KEYS.WARN.CHECK_KEYNAME');
                    }

                    if(error !== true){
                        loader.start();

                        var key = new   cmKey({
                                            name: $scope.keyName,
                                            privKey: $scope.privKey
                                        });

                        cmUserModel
                            .storeKey(key)
                            .syncLocalKeys();

                        cmUserModel
                            .when('key:saved', null, 5000)
                            .then(
                                function(result){
                                    loader.stop();

                                    if(cmUserModel.data.identity.keys.some(function(key){
                                        return key.id != result.data.keyId
                                    })){
                                        $scope.goTo('/authentication')
                                    } else {
                                        $scope.goTo('/talks');
                                    }
                                }
                            );
                    }
                };

                function callback_key_saving_failed(){
                    $scope.isError = true;
                }

                cmUserModel.on('key:removed', callback_key_saving_failed);

                $scope.$on('$destroy', function(){
                    cmUserModel.off('key:removed', callback_key_saving_failed);
                });
            }
        }
    }
])
.directive('cmIdentityKeyList', [
    'cmUserModel',
    'cmModal',
    'cmKey',
    '$timeout',
    function(cmUserModel, cmModal, cmKey, $timeout){
        return {
            restrict: 'E',
            templateUrl: 'comps/user/identity/key/drtv-identity-key-list.html',
            controller: function ($scope) {
                $scope.privateKeys = [];
                $scope.publicKeys = [];
                $scope.trustedKeys = [];
                $scope.signing = false;
                $scope.isHandshakePossible = false;
                $scope.showNoLocalKeysOnThisDevice = true;
                $scope.showUntrustedPublickeysExists = true;
                $scope.canCreate = true;

                var refresh_scheduled = false

                function schedule_refresh(){
                    if(!refresh_scheduled){
                        refresh_scheduled = true
                        $timeout(function(){
                            refresh_scheduled = false
                            refresh()
                        }, 1000)
                    }
                }

                function refresh(){
                    $scope.canCreate    =   !cmUserModel.hasPrivateKey();
                    $scope.privateKeys  =   cmUserModel.loadLocalKeys() || [];
                    $scope.publicKeys   =   cmUserModel.data.identity.keys || [];

                    $scope.trustedKeys  =   []
                    $scope.checking     =   $scope.publicKeys


                    cmUserModel.verifyIdentityKeys(null, null, true)
                    .then(function(ttrusted_keys){
                        $scope.checking     =   []
                        $scope.trustedKeys = ttrusted_keys
                    })
                        

                    $scope.signing      =   cmUserModel.state.is('signing');

                    $scope.isHandshakePossible = ($scope.privateKeys.length > 0);

                    // no key exists
                    //$scope.showNoLocalKeysOnThisDevice = $scope.trustedKeys.length == 0;
                    $scope.showNoLocalKeysOnThisDevice = $scope.canCreate;

                    // publickeys doesnt match trustedkeys
                    $scope.showUntrustedPublickeysExists =
                        $scope.trustedKeys.length != $scope.publicKeys.length &&
                        $scope.trustedKeys.length >= 1 &&
                        $scope.publicKeys.length >= 1;
                }

                $scope.remove = function(key){
                    $scope.confirm({
                        title: 'SETTINGS.PAGES.IDENTITY.KEYS.REMOVE_KEY',
                        text:  'SETTINGS.PAGES.IDENTITY.KEYS.REMOVE_KEY_REALLY',
                        html:  '<h3>'+key.name+'</h3>{{'+key.created+' | date:"dd.MM.yy - HH:mm"}}'
                    })
                    .then(function(){
                        cmUserModel.removeKey(key);                        
                    });
                    refresh();
                };

                $scope.someKeyNeedsAuthentication = function(){
                    return $scope.trustedKeys.length < $scope.publicKeys.length
                };

                $scope.showHandshake = function(key){
                    return !$scope.isTrustedKey(key) && $scope.isHandshakePossible;
                };

                $scope.isTrustedKey = function(key){
                    return $scope.trustedKeys.indexOf(key) != -1
                };

                $scope.stillChecking = function(key){
                    return $scope.checking.indexOf(key) != -1
                };

                $scope.sortByPrivKeys = function(key) {
                    return !($scope.privateKeys.find(key) instanceof cmKey);
                };

                $scope.startAuthentication = function(toKey){
                    cmUserModel.trigger('handshake:start', {key: toKey});
                };

                //Todo: check if refresh has to be called that often
                cmUserModel.state.on('change', schedule_refresh);
                cmUserModel.on('key:stored key:removed signatures:saved identity:updated update:finished cache:updated', schedule_refresh);

                $scope.$on('$destroy',function(){
                    cmUserModel.off('key:stored key:removed signatures:saved identity:updated update:finished cache:updated', schedule_refresh);
                });

                refresh();
            }
        }
    }
])
angular.module('comps/validate/drtv-cameo-id.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/validate/drtv-cameo-id.html',
'<label>{{placeholder|cmTranslate}} *</label><div data-qa="form-input" class="cm-input-ctn with-inside-icon" ng-class="{\'cm-input-error\':hasError()}" cm-input-watcher><input tabindex="{{tabindex}}" data-qa="input-cameoId" type="text" id="cameoId" name="cameoId" ng-class="{\'cm-input-error\':hasError()}" required ng-model="cameoId" cm-adaptive-change /><i class="fa cm-input-addon" ng-class="{ \'cm-write\': !hasReservationSecret(), \'cm-checkbox-right\':hasReservationSecret() }" data-qa="icon-cameoId-reserved"></i></div><cm-info-bubble class="cm-alert" ng-show="errors.toolong" data-qa="cameoId-info-user-max-letter-count"><i class="fa cm-info"></i>{{\'DRTV.VALIDATE_CAMEOID.INFO.MAX_LETTER_COUNT\'|cmTranslate:{count: max} }}</cm-info-bubble><cm-info-bubble class="cm-alert" ng-show="errors.tooshort" data-qa="cameoId-info-user-min-letter-count"><i class="fa cm-info"></i>{{\'DRTV.VALIDATE_CAMEOID.INFO.MIN_LETTER_COUNT\'|cmTranslate:{count: min} }}</cm-info-bubble><cm-info-bubble class="cm-alert" ng-show="errors.exists" data-qa="cameoId-info-username-exists"><i class="fa cm-info"></i>{{\'DRTV.VALIDATE_CAMEOID.INFO.INPUT.EXISTS\'|cmTranslate}}</cm-info-bubble><cm-info-bubble class="cm-alert" ng-show="errors.empty" data-qa="cameoId-info-username-empty"><i class="fa cm-info"></i>{{\'DRTV.VALIDATE_CAMEOID.INFO.INPUT.EMPTY\'|cmTranslate}}</cm-info-bubble><cm-info-bubble class="cm-alert" ng-show="errors.invalid" data-qa="cameoId-info-username-invalid"><i class="fa cm-info"></i>{{\'DRTV.VALIDATE_CAMEOID.INFO.INPUT.INVALID\'|cmTranslate}}</cm-info-bubble>');
}]);
angular.module('comps/validate/drtv-password.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/validate/drtv-password.html',
'<article class="content"><label>{{\'DRTV.PASSWORD.PASSWORD\'|cmTranslate}} <span ng-show="required">*</span></label><div class="cm-input-ctn with-inside-icons" ng-class="{\'cm-input-error\':(error.tooShort || error.empty)}" data-qa="form-input" cm-input-watcher><input tabindex="{{tabindex}}" data-qa="input-password" type="{{passwordType}}" id="password" ng-class="{\'cm-input-error\':(error.tooShort || error.empty)}" name="password" ng-model="pw" ng-change="validate()" cm-adaptive-change="300" ng-required="required" /><i class="fa" ng-class="{\'cm-hidden\':passwordType==\'password\',\'cm-visible\':passwordType==\'text\'}" ng-click="togglePassword()" data-qa="icon-toggle-password"></i><i class="fa cm-write"></i></div><div class="pw-progress" ng-model="progress"><div class="progress-bar pw-strength-{{bgColor}}" ng-style="{width:percent}"><span class="sr-only">{{percent}} {{strengthMessage}}</span></div></div><cm-info-bubble class="cm-alert" ng-show="(error.tooShort || error.empty)" ><div ng-show="error.tooShort" data-qa="register-info-pass-min-letter-count"><i class="fa cm-info"></i>{{\'DRTV.PASSWORD.INFO.MIN_LETTER_COUNT\' | cmTranslate : {count: 6} }}</div><div ng-show="error.empty" data-qa="drtv-password-error-empty"><i class="fa cm-info"></i>{{\'DRTV.PASSWORD.INFO.EMPTY\'|cmTranslate}}</div></cm-info-bubble></article><hr class="margin-small no-padding" ng-show="!showPassword"><article class="content" ng-show="!showPassword"><label>{{\'DRTV.PASSWORD.PASSWORD_CONFIRM\'|cmTranslate}} <span ng-show="required">*</span></label><div class="cm-input-ctn with-inside-icon" ng-class="{\'cm-input-error\':!error.confirmRight}" data-qa="form-input" cm-input-watcher><input tabindex="{{nextTabIndex}}" data-qa="input-passwordConfirm" type="password" id="password_confirm" name="password_confirm" ng-class="{\'cm-input-error\':!error.confirmRight}" ng-model="pwConfirm" ng-change="validate(true)" cm-adaptive-change="300" /><i class="fa" ng-class="{ \'cm-write\':!pw, \'cm-checkbox-wrong\':!error.confirmRight, \'cm-checkbox-right\':error.confirmRight }" data-qa="icon-passwordConfirm"></i></div></article>');
}]);
angular.module('comps/validate/form/drtv-form-email.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/validate/form/drtv-form-email.html',
'<article class="content" ng-form="cmInnerForm"><label data-qa="ctn-toggle-email-info" ng-click="toggleEmailInfo()" cm-reactive>{{::label|cmTranslate}}<i class="fa cm-ci-color cm-info" ng-show="toggleInfo"></i></label><cm-info-bubble ng-click="toggleEmailInfo()" ng-show="showEmailInfo" data-qa="ctn-email-info" nose-x="25%"> {{::toggleInfo|cmTranslate}}</cm-info-bubble><div class="cm-input-ctn" ng-class="{ \'cm-input-disabled\': disabled, \'with-inside-icon\': !disabled && !verification.isVisible, \'with-inside-icons\': !disabled && verification.isVisible }"><input type="text" tabindex="{{::tabIndex}}" data-qa="input-email" name="email" ng-model="ngModel" ng-disabled="disabled" cm-validate-email /><i class="fa" data-qa="btn-emailManuallyVerification" ng-show="!disabled && verification.isVisible" ng-click="sendVerification()" cm-reactive="{{verification.isVerified}}" ng-class="{ \'cm-checkbox-right\': verification.isVerified, \'cm-checkbox-wrong\': !verification.isVerified }"></i><i class="fa cm-write" ng-show="!disabled"></i></div><cm-info-bubble class="cm-alert" ng-show="cmInnerForm.$error.emailInvalid"><div data-qa="form-error-email-invalid"><i class="fa cm-info"></i> {{::info|cmTranslate}}</div></cm-info-bubble></article><article class="content emailVerification" ng-show="verification.isVisible && !verification.isVerified"><cm-info-bubble nose-x="85%" data-qa="info-emailNotVerified"><i class="fa cm-attention cm-orange"></i><span ng-bind-html="::\'DRTV.VALIDATE_EMAIL.INFO.ISNT_VERIFIED\'|cmTranslate:{ \'icon\':verificationManuallyIcon}"></span></cm-info-bubble><label class="dbl mt15">{{::\'DRTV.VALIDATE_EMAIL.LABEL_VERIFICATION_CODE\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon"><input type="text" data-qa="inp-emailCodeVerify" name="emailCodeVerify" cm-enter="checkVerificationCode()" ng-model="code" cm-pristine-ignore /><i class="fa cm-right" data-qa="btn-emailCodeVerify" ng-click="checkVerificationCode()" ng-show="!showLoader" cm-reactive></i><cm-loader cm-color="inp-grey" cm-size="small" ng-show="showLoader"></cm-loader></div><cm-info-bubble ng-show="cmUtil.objLen(infoBubble) > 0"><div data-qa="info-emailVerificationCodeEmpty" ng-show="infoBubble.empty"><i class="fa cm-attention cm-orange"></i><span ng-bind-html="::\'DRTV.VALIDATE_EMAIL.INFO.EMPTY_CODE\'|cmTranslate"></span></div><div data-qa="info-emailVerificationCodeInvalid" ng-show="infoBubble.invalid"><i class="fa cm-attention cm-orange"></i><span ng-bind-html="::\'DRTV.VALIDATE_EMAIL.INFO.INVALID_CODE\'|cmTranslate"></span></div></cm-info-bubble></article>');
}]);
angular.module('comps/validate/form/drtv-form-phonenumber.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('comps/validate/form/drtv-form-phonenumber.html',
'<article class="content" ng-form="cmInnerForm"><label data-qa="ctn-toggle-phone-info" ng-click="togglePhoneInfo()" cm-reactive>{{::label|cmTranslate}}<i class="fa cm-ci-color cm-info" ng-show="toggleInfo"></i></label><cm-info-bubble ng-click="togglePhoneInfo()" ng-show="showPhoneInfo" data-qa="ctn-phone-info" nose-x="25%"> {{::toggleInfo|cmTranslate}}</cm-info-bubble><div class="cm-input-ctn" ng-class="{ \'cm-input-disabled\':disabled, \'with-inside-icon\':!disabled && !verification.isVisible, \'with-inside-icons\':!disabled && verification.isVisible, \'with-inside-left-icon with-prefix-handler\':!disabled && prefixHandler.isVisible }"><cm-country-prefix-handler ng-model="ngModel"></cm-country-prefix-handler><input type="tel" tabindex="{{::tabIndex}}" data-qa="input-phoneNumber" name="phoneNumberDisp" ng-model="ngModel" cm-validate-phone ng-disabled="disabled" /><i class="fa" data-qa="btn-phoneNumberManuallyVerification" ng-show="!disabled && verification.isVisible" ng-click="sendVerification()" cm-reactive="{{verification.isVerified}}" ng-class="{ \'cm-checkbox-right\': verification.isVerified, \'cm-checkbox-wrong\': !verification.isVerified }"></i><i class="fa cm-write" ng-show="!disabled"></i><input type="hidden" name="phoneNumber" ng-model="ngModelOut" /></div><cm-country-prefix-list></cm-country-prefix-list><cm-info-bubble class="cm-alert" ng-show="cmInnerForm.$error.phoneNumberInvalid" ><div data-qa="form-error-phoneNumber-invalid"><i class="fa cm-info"></i> {{::info|cmTranslate}}</div></cm-info-bubble></article><article class="content phoneNumberVerification" ng-show="verification.isVisible && !verification.isVerified"><cm-info-bubble nose-x="85%" data-qa="info-phoneNumberNotVerified"><i class="fa cm-attention cm-orange"></i><span ng-bind-html="::\'DRTV.VALIDATE_PHONE.INFO.ISNT_VERIFIED\'|cmTranslate:{ \'icon\':verificationManuallyIcon}"></span></cm-info-bubble><label class="dbl mt15">{{::\'DRTV.VALIDATE_PHONE.LABEL_VERIFICATION_CODE\'|cmTranslate}}</label><div class="cm-input-ctn with-inside-icon without-validation"><input type="text" data-qa="inp-phoneNumberCodeVerify" name="phoneNumberCodeVerify" cm-enter="checkVerificationCode()" ng-model="code" cm-pristine-ignore /><i class="fa cm-right" data-qa="btn-phoneNumberCodeVerify" ng-click="checkVerificationCode()" ng-show="!showLoader" cm-reactive></i><cm-loader cm-color="inp-grey" cm-size="small" ng-show="showLoader"></cm-loader></div><cm-info-bubble ng-show="cmUtil.objLen(infoBubble) > 0"><div data-qa="info-phoneNumberVerificationCodeEmpty" ng-show="infoBubble.empty"><i class="fa cm-attention cm-orange"></i><span ng-bind-html="::\'DRTV.VALIDATE_PHONE.INFO.EMPTY_CODE\'|cmTranslate"></span></div><div data-qa="info-phoneNumberVerificationCodeInvalid" ng-show="infoBubble.invalid"><i class="fa cm-attention cm-orange"></i><span ng-bind-html="::\'DRTV.VALIDATE_PHONE.INFO.INVALID_CODE\'|cmTranslate"></span></div></cm-info-bubble></article>');
}]);
angular.module('cmValidate', [
    'cmCore',
    'cmUi'
,'comps/validate/drtv-cameo-id.html','comps/validate/drtv-password.html','comps/validate/form/drtv-form-email.html','comps/validate/form/drtv-form-phonenumber.html'])
.directive('cmCameoId',[
    'cmAuth', 'cmUserModel',
    '$q', '$rootScope',
    function (cmAuth, cmUserModel,
              $q, $rootScope){
        return {
            restrict: 'E',
            require: 'ngModel',
            templateUrl: 'comps/validate/drtv-cameo-id.html',
            scope: {
                cameoId: '=ngModel',
                formName: '@formName',
                tabindex: '@cmTabindex',
                placeholder: '@placeholder'
            },
            controller: function($scope){

                $scope.min = 3;
                $scope.max = 20;

                $scope.parentForm = $scope.$parent[$scope.formName];

                $scope.$parent.reservationSecrets = $scope.$parent.reservationSecrets || {};

                $scope.userNameAlternatives = [];
                $scope.showUserNameAlternatives = false;
                $scope.pendingAccountCheck = $q.when(true);

                function checkLength(value){
                    if(value.length < $scope.min || value.length > $scope.max){

                        if(value.length < $scope.min){
                            $scope.errors.tooshort = true;
                        }

                        if(value.length > $scope.max){
                            $scope.errors.toolong = true;
                        }

                        return false
                    }

                    return true;
                }

                function checkValue(value){
                    if(value == undefined || value == '' || !checkLength(value)){
                        $scope.parentForm.cameoId.$valid = false;
                        return false;
                    }

                    return true;
                }

                function setDefault(){
                    $scope.errors = {
                        toolong: false,
                        tooshort: false,
                        exists: false,
                        empty: false,
                        invalid: false
                    };
                }

                setDefault();

                function checkAccountName(newValue){
                    var deferred = $q.defer();

                    if(!checkValue(newValue)){
                        if($scope.parentForm.cameoId.$invalid && $scope.parentForm.cameoId.$dirty)
                            $scope.errors.empty = true;

                        deferred.reject();
                        return deferred.promise;
                    }

                    // if input is'nt empty && is valid && reservation secret is'nt exists
                    if(!(newValue in $scope.$parent.reservationSecrets)) {

                        // check cameoId#

                        /**
                         * @TODO !!!
                         */
                        var auth = undefined;
                        if(!cmUserModel.getToken()){
                            auth = cmUserModel.data.account.basicAuth;
                        }

                        $scope.pendingAccountCheck = cmAuth.checkAccountName(newValue, auth).then(
                            // valid case
                            function (data) {
                                // reservation secret to parent scope
                                $scope.$parent.reservationSecrets[newValue] = data.reservationSecret;

                                $scope.parentForm.cameoId.$valid = true;
                                deferred.resolve();
                            },
                            // invalid or exists
                            function (response) {
                                if (typeof response == "object") {
                                    // invalid case
                                    if (typeof response.data !== 'undefined'
                                        && typeof response.data.error !== 'undefined'
                                        && response.data.error.search('invalid') != -1
                                    ) {
                                        $scope.errors.invalid = true;
                                    }
                                    // show alternatives
                                    if (typeof response.alternative !== 'undefined') {
                                        $scope.errors.exists = true;
                                        /**
                                         * @TODO
                                         * show alternatives
                                         */
                                        $scope.userNameAlternatives = response.alternative;
                                        $scope.showUserNameAlternatives = true;
                                    }
                                }

                                $scope.parentForm.cameoId.$valid = false;
                                deferred.reject();
                            }
                        );
                    } else {
                        $scope.parentForm.cameoId.$valid = true;
                        deferred.resolve();
                    }

                    return deferred.promise;
                }

                var killWatcher = $rootScope.$on('cm-login-name:invalid', function(){
                    $scope.parentForm.cameoId.$invalid = true;
                    $scope.parentForm.cameoId.$dirty = true;

                    if(!checkValue($scope.parentForm.cameoId.$viewValue))
                        $scope.errors.empty = true;

                });

                $scope.hasReservationSecret = function(){
                    return $scope.cameoId in $scope.$parent.reservationSecrets;
                };

                $scope.hasError = function(){
                    if($scope.errors.exists
                    || $scope.errors.empty
                    || $scope.errors.invalid
                    || $scope.errors.tooshort
                    || $scope.errors.toolong
                    || ($scope.parentForm.cameoId.$invalid && $scope.parentForm.cameoId.$dirty)
                    ){
                        return true;
                    }
                    return false;
                };

                $scope.$watch('cameoId',function (newValue) {
                    setDefault();

                    checkAccountName(newValue);
                });

                var killWatcher2 = $rootScope.$on('registration:checkAccountName', function(){
                    setDefault();

                    $scope.$parent.reservationSecrets = {};

                    checkAccountName($scope.cameoId).then(
                        function(){
                            $rootScope.$emit('registration:createUser');
                        }, function(){
                            //console.log('check account again fail')
                        }

                    );
                });

                $scope.$on('$destroy', function(){
                    killWatcher();
                    killWatcher2()
                })
            }
        }
    }
])
.directive('cmValidateMixed',[
    'cmAuth',
    function (cmAuth){
        return {
            require: 'ngModel',
            scope: {
                model: '=ngModel'
            },
            link: function(scope, element, attrs, ngModel){
                var correctValue;

                scope.$watch('model',function (newValue) {
                    if(newValue && newValue != "" && correctValue == undefined || // value isnt empty and first-check
                        newValue && newValue != "" && correctValue != undefined && newValue != correctValue // value isnt the correct value from BE
                    ){
                        cmAuth.checkMixed(newValue).
                            then(
                            //success
                            function (mixed){
                                correctValue = mixed[Object.keys(mixed)[0]];
                                ngModel.$setValidity('mixed', true);
                                ngModel.$setViewValue(correctValue);
                                ngModel.$commitViewValue();
                                ngModel.$render();
                            },
                            //error
                            function (){
                                ngModel.$setValidity('mixed', false);
                            }
                        );
                    } else {
                        ngModel.$setValidity('mixed', true);
                        ngModel.$setPristine();
                    }
                });
            }
        }
    }
])
.directive('cmPassword', [
    'cmCrypt',
    function (cmCrypt) {
        return  {
            restrict: 'E',
            require: 'ngModel',
            templateUrl: 'comps/validate/drtv-password.html',
            scope: {
                password: '=ngModel',
                formName: '@formName',
                tabindex: '@cmTabindex'

            },
            controller: function($scope, $element, $attrs){

                $scope.required = true;
                if(('cmRequired' in $attrs)) {
                    $attrs.$observe('cmRequired', function (isRequired) {
                        $scope.required = isRequired == 'false' ? false : true;
                    });
                }

                $scope.nextTabIndex = parseInt($scope.tabindex) + 1;
                $scope.parentForm = $scope.$parent[$scope.formName];

                function reset(onlyError){

                    if(!onlyError) {
                        $scope.pw = '';
                        $scope.pwConfirm = '';

                        $scope.passwordType = 'password';
                        $scope.showPassword = false;
                    }

                    $scope.error = {
                        empty: false,
                        tooShort: false,
                        confirmEmpty: false,
                        confirmRight: true
                    };
                }

                $scope.togglePassword = function(){
                    if($scope.showPassword){
                        $scope.showPassword = false;
                        $scope.passwordType = 'password';
                    } else {
                        $scope.showPassword = true;
                        $scope.passwordType = 'text';
                    }

                    $scope.confirmPW();
                };

                $scope.validate = function(onlyConfirm){
                    if(!$scope.pw)
                        return false;

                    if(!onlyConfirm)
                        $scope.checkPWStrength('validate');

                    $scope.confirmPW();
                };

                $scope.checkPWStrength = function(whoIs){
                    var pw = $scope.pw;

                    $scope.error.empty = false;
                    $scope.error.tooShort = false;

                    if(pw && pw.length >= 6){
                        $scope.checkPasswordLength(pw);
                        $scope.showStrengthMeter = true;
                        var bits = passchk_fast.passEntropy(pw);

                        if(bits < 28){
                            $scope.bgColor = 'very-weak';
                        } else if(bits < 36){
                            $scope.bgColor = 'week';
                        } else if(bits < 60){
                            $scope.bgColor = 'reasonable-normal';
                        } else if(bits < 128){
                            $scope.bgColor = 'strong';
                        } else {
                            $scope.bgColor = 'very-strong';
                        }

                        $scope.percent = (1+(bits>10 ? 100*Math.pow((Math.log(bits-10)/Math.log(bits-3)), 10) : 0))+'%';
                        //100*Math.max(0,(1-Math.pow(1.4,((bits-10)*-0.08))))
                        //100*bits / Math.max(128, bits)
                    } else {
                        $scope.percent = '0%';
                        $scope.bgColor = 'very-weak';

                        if(pw && pw.length > 0) {
                            $scope.error.tooShort = true;
                            $scope.parentForm.$setValidity('passwordTooShort',false);
                        } else {
                            $scope.error.empty = true;
                            $scope.parentForm.$setValidity('passwordEmpty',false);
                        }
                    }
                };

                $scope.checkPasswordLength = function(pw){
                    if(pw.length > 0 && pw.length < 6){
                        $scope.error.tooShort = true;
                        $scope.parentForm.$setValidity('passwordTooShort',false);
                    } else {
                        $scope.error.tooShort = false;
                        $scope.parentForm.$setValidity('passwordTooShort',true);
                    }
                };

                /**
                 * validates both password inputs
                 */
                $scope.confirmPW = function(){
                    $scope.copyPW();

                    if(!$scope.pw || !$scope.pwConfirm){
                        $scope.error.confirmRight = false;
                        $scope.parentForm.$setValidity('passwordConfirmRight',false);
                        return false;
                    }

                    if(($scope.pw == $scope.pwConfirm)){
                        $scope.error.empty = false;
                        $scope.error.confirmRight = true;
                        $scope.parentForm.$setValidity('passwordConfirmRight',true);
                        setPassword(cmCrypt.hash($scope.pw));
                    } else {
                        $scope.parentForm.$setValidity('passwordConfirmRight',false);
                        $scope.error.confirmRight = false;
                        setPassword('none');
                    }
                };

                $scope.copyPW = function(){
                    if($scope.showPassword)
                        $scope.pwConfirm = $scope.pw;
                };

                /**
                 * Wrapper Function to inject Password in extern Controller
                 * if password (empty || none) it is wrong, else it is right
                 */
                function setPassword(pw){
                    if(angular.isDefined(pw)){
                        $scope.password = pw;
                    }
                }

                var killwatcher = $scope.$on('cm-password:empty', function(){
                    $scope.error.empty = true;
                });

                var killwatcher2 = $scope.$on('cm-password:reset', function(){
                    reset();
                });

                reset();

                $scope.$on('$destroy', function(){
                    killwatcher();
                    killwatcher2();
                });
            }
        }
    }
])
.directive('cmValidateEmail',[
    function (){
        //http://stackoverflow.com/questions/16863389/angular-js-email-validation-with-unicode-characters
        return {
            require: 'ngModel',
            scope: {
                model: '=ngModel'
            },
            link: function(scope, element, attrs, ngModel){

                var identifier = 'emailInvalid';

                scope.$watch('model',function (newValue) {
                    var check = true;

                    if(newValue && newValue != ''){
                        // http://stackoverflow.com/a/46181/11236
                        var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                        check = re.test(newValue);
                    }

                    if(check !== true){
                        ngModel.$setValidity(identifier, false);
                    } else {
                        ngModel.$setValidity(identifier, true);
                    }
                });
            }
        }
    }
])
.directive('cmValidatePhone',[
    function (){
        return {
            require: 'ngModel',
            scope: {
                model: '=ngModel'
            },
            link: function(scope, element, attrs, ngModel){

                var identifier = 'phoneNumberInvalid';

                function checkPhoneNumber(newValue){
                    if(newValue && newValue != "" && correctValue == undefined
                    || newValue && newValue != "" && correctValue != undefined && newValue != correctValue
                    ){
                        ngModel.$setViewValue(newValue.replace(/ /g,''));

                        if(newValue.search(/^[+]*[ ()0-9]*$/) == 0){
                            ngModel.$setValidity(identifier, true);
                        } else {
                            ngModel.$setValidity(identifier, false);
                        }
                    } else {
                        ngModel.$setValidity(identifier, true);
                        ngModel.$setPristine();
                    }
                }

                var correctValue;
                scope.$watch('model',function (newValue) {
                    checkPhoneNumber(newValue);
                });
            }
        }
    }
])

.directive('cmFormEmail', [
    'cmVerify',
    '$rootScope',
    function (cmVerify,
              $rootScope) {
        return {
            restrict: 'E',
            scope: {
                ngModel: '=ngModel',
                tabIndex: '@cmTabindex',
                label: '@cmLabel',
                info: '@cmInfo',
                toggleInfo: '@cmToggleInfo',
                disabled: '=cmDisable',
                verificationData: '=cmVerify'
            },
            templateUrl: 'comps/validate/form/drtv-form-email.html',
            controller: function($scope) {
                cmVerify.handleInput('email',$scope);

                $scope.showEmailInfo = false;
                $scope.toggleEmailInfo = function(){
                    if(typeof $scope.toggleInfo == 'string'){
                        $scope.showEmailInfo = !$scope.showEmailInfo ? true : false;
                    }
                };

                var killWatcher = $rootScope.$on('cmValidate:error', function(event, errorCodes){
                    if(errorCodes.length > 0 && errorCodes.indexOf('EMAIL_INVALID') >= 0) {
                        $scope.cmInnerForm.email.$setValidity('emailInvalid', false);
                    }
                });

                $scope.$watch('ngModel',function(newValue){
                    $scope.cmInnerForm.email.$setValidity('emailInvalid', true);
                });

                $scope.$on('$destroy', function(){
                    killWatcher();
                });
            }
        }
    }
])

.directive('cmFormPhonenumber', [
    'cmCountryPrefix', 'cmVerify',
    '$rootScope',
    function (cmCountryPrefix, cmVerify,
              $rootScope) {
        return {
            restrict: 'E',
            scope: {
                ngModel: '=ngModel',
                ngModelOut: '=ngModelOut',
                tabIndex: '@cmTabindex',
                label: '@cmLabel',
                info: '@cmInfo',
                toggleInfo: '@cmToggleInfo',
                disabled: '=cmDisable',
                verificationData: '=cmVerify'
            },
            templateUrl: 'comps/validate/form/drtv-form-phonenumber.html',
            controller: function($scope){
                cmCountryPrefix.handleView($scope);
                cmVerify.handleInput('phoneNumber',$scope);

                $scope.typeof = function(variable){
                    return typeof variable;
                };

                $scope.showPhoneInfo = false;
                $scope.togglePhoneInfo = function(){
                    if(typeof $scope.toggleInfo == 'string'){
                        $scope.showPhoneInfo = !$scope.showPhoneInfo ? true : false;
                    }
                };

                var killWatcher = $rootScope.$on('cmValidate:error', function(event, errorCodes){
                    if(errorCodes.length > 0 && errorCodes.indexOf('PHONENUMBER_INVALID') >= 0) {
                        $scope.cmInnerForm.phoneNumberDisp.$setValidity('phoneNumberInvalid',false);
                    }
                });

                $scope.$watch('ngModel',function(newValue){
                    $scope.cmInnerForm.phoneNumberDisp.$setValidity('phoneNumberInvalid',true);
                });

                $scope.$on('$destroy', function(){
                    killWatcher();
                });
            }
        }
    }
])

    .service('cmPristine',[
        'cmObject',
        'cmLogger',
        function(cmObject, cmLogger){
            var self = this,
                elements = [];
                /*
                element = {
                    name: 'moep',
                    isPristine: true || false
                }
                 */
            cmObject.addEventHandlingTo(this);

            function searchElement(element){
                return elements.some(function(e){
                    return (e.name == element.$name)
                });
            }

            function checkElement(element){
                if(typeof element.$name != 'undefined' && element.$name != ''){
                    return true;
                }

                return false;
            }

            function findIndex(element){
                var i = 0,
                    index = -1;

                while(i < elements.length){
                    if(elements[i].name == element.$name){
                        index = i;
                        break;
                    }
                    i++;
                }

                return index;
            }

            /**
             * add Element
             * @param element ngModel
             */
            this.initView = function(scope){
                scope.isPristine = true;
                function pristine_callback(){
                    scope.isPristine = self.is();
                }
                self.on('updated',pristine_callback);

                scope.$on('$destroy', function(){
                    self.off('updated',pristine_callback);
                })
            };

            this.resetView = function(scope){
                scope.isPristine = true;
                self.trigger('reinit');
            };

            this.add = function(element){
                //cmLogger.debug('cmPristine.add');

                if(!checkElement(element)){
                    cmLogger.warn('cmFormPristine (add) detects that element has no name! Is it an ngModel Object?');
                    return false;
                }

                if(!searchElement(element)){
                    elements.push({name: element.$name, isPristine: true});

                    this.trigger('added');
                } else {
                    cmLogger.debug('cmFormPristine detects same element more then one time!');
                }
            };

            this.is = function(){
                //cmLogger.debug('cmPristine.is');
                return !elements.some(function (e){
                    return (e.isPristine == false);
                })
            };

            this.set = function(element, bool){
                //cmLogger.debug('cmPristine.set');

                if(!checkElement(element)){
                    cmLogger.debug('cmFormPristine (set) detects that element has no name! Is it an ngModel Object?');
                    return false;
                }

                if(searchElement(element)){
                    elements[findIndex(element)].isPristine = bool;

                    this.trigger('updated');
                }
            };

            this.remove = function(element){
                //cmLogger.debug('cmPristine.remove');

                if(!checkElement(element)){
                    cmLogger.debug('cmFormPristine (remove) detects that element has no name! Is it an ngModel Object?');
                    return false;
                }

                if(searchElement(element)){
                    var index = findIndex(element);

                    if(index != -1){
                        elements.splice(index, 1);
                    }
                    this.trigger('removed');
                }
            };

            this.reset = function(){
                //cmLogger.debug('cmPristine.reset');

                elements = null;
                elements = [];

                this.trigger('reset');
            };

            this.getAll = function(){
                //cmLogger.debug('cmPristine.getAll');

                return elements;
            }
        }
    ]
)

.service('cmVerify',[
    'cmAuth', 'cmUtil', 'cmLoader',
    function (cmAuth, cmUtil, cmLoader){

        var self = {
            handleInput: function(type, scope){
                var loader = new cmLoader(scope);

                scope.cmUtil = cmUtil;
                scope.code = '';
                scope.verificationManuallyIcon = '<i class="fa cm-checkbox-wrong"></i>';

                scope.verification = {
                    isVisible: false,
                    isVerified: false
                };
                scope.infoBubble = {};

                scope.$watch('verificationData', function(data){
                    if(data && data.value != '') {
                        scope.verification.isVisible = true;
                        scope.verification.isVerified = 'isVerified' in data ? data.isVerified : false;
                        loader.stop();
                        scope.code = '';
                    } else {
                        scope.verification.isVisible = false;
                    }
                });

                scope.sendVerification = function(){
                    if (loader.isIdle())
                        return false;

                    if(!scope.verification.isVerified) {
                        cmAuth.sendVerification(type);
                    }
                };

                scope.checkVerificationCode = function(){
                    if (loader.isIdle())
                        return false;

                    scope.infoBubble = {};
                    loader.start();

                    if(!scope.code || scope.code == ''){
                        scope.infoBubble.empty = true;
                        loader.stop();
                    } else {
                        cmAuth.confirmVerification(scope.code)
                        .then(
                            function(){},
                            function(response){
                                loader.stop();
                                switch (response.data.errorCodes[0]){
                                    case "VERIFY.EXPIRED":
                                        scope.infoBubble.invalid = true;
                                    break;
                                }
                            }
                        )
                    }
                };
            }
        };

        return self;
    }
])
angular.module('widgets/cameo/wdgt-terms.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/cameo/wdgt-terms.html',
'<article class="terms is-selectable"><p class="is-selectable">{{\'TERMS.PARAGRAPH_1\'|cmTranslate}}</p><p class="is-selectable">{{\'TERMS.PARAGRAPH_2\'|cmTranslate}}</p></article>');
}]);
angular.module('widgets/contact/wdgt-contact-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/contact/wdgt-contact-create.html',
'<h2 class="border-bottom"><i class="fa cm-new-contact"></i> {{\'CONTACTS.HEADING.CREATE\'|cmTranslate}}</h2><cm-contact-create></cm-contact-create>');
}]);
angular.module('widgets/contact/wdgt-contact-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/contact/wdgt-contact-edit.html',
'<h2 class="border-bottom"><i class="fa cm-person"></i> {{\'CONTACT.HEADLINE\'|cmTranslate}}</h2><cm-contact-edit cm-data="contact" ng-if="contact"></cm-contact-edit>');
}]);
angular.module('widgets/contact/wdgt-contact-import.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/contact/wdgt-contact-import.html',
'<h2 class="border-bottom"><i class="fa cm-mobile"></i> {{\'CONTACTS.HEADING.IMPORT\'|cmTranslate}}</h2><cm-contact-import></cm-contact-import>');
}]);
angular.module('widgets/contact/wdgt-contact-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/contact/wdgt-contact-list.html',
'<cm-contact-list></cm-contact-list>');
}]);
angular.module('widgets/contact/wdgt-contact-request-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/contact/wdgt-contact-request-list.html',
'<h2 class="border-bottom no-margin-bottom"><i class="fa cm-contacts"></i> {{\'CONTACTS.HEADING.REQUESTS\'|cmTranslate}}</h2><cm-request-list></cm-request-list>');
}]);
angular.module('widgets/conversation/wdgt-conversation-recipients.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/conversation/wdgt-conversation-recipients.html',
'<cm-recipients cm-data="conversation"></cm-recipients>');
}]);
angular.module('widgets/conversation/wdgt-conversation-security.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/conversation/wdgt-conversation-security.html',
'<h2><i class="fa cm-lock"></i> {{\'SECURITY_ASPECT.HEADLINE\' | cmTranslate}}</h2><cm-security-settings cm-data="conversation" ng-if="conversation"></cm-security-settings>');
}]);
angular.module('widgets/conversation/wdgt-conversation.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/conversation/wdgt-conversation.html',
'<cm-conversation cm-data="conversation" ng-if="conversation"></cm-conversation>');
}]);
angular.module('widgets/help/wdgt-help-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/help/wdgt-help-list.html',
'<h2 class="no-margin-bottom border-bottom"><i class="fa cm-info"></i> {{\'HELP.HEADING\' | cmTranslate}}</h2><ul class="no-border-top"><li ng-repeat="page in overviewKeys" ng-click="handleLink($event, page, overview[page].disabled, overview[page])" ng-class="{ \'is-disabled\':overview[page].disabled,\'is-active\':checkActive(page) }" data-qa="{{overview[page][\'data-qa\']}}" cm-reactive><span class="item clearfix"><span class="title"><i class="fa" ng-class="overview[page].icon"></i><span>{{overview[page].i18n|cmTranslate}}</span></span><section class="icon-list"><i class="fa cm-right"></i></section></span></li></ul>');
}]);
angular.module('widgets/login/wdgt-login.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/login/wdgt-login.html',
'<section class="theme-b dtb"><div class="dtbr"><div class="head"><div class="rhino"><img src="gfx/rhino-bubble.png" /></div><div class="logo tac"><cm-logo class="fa-2x"></cm-logo></div><div class="bg-transparent"></div></div></div><div class="dtbr"><hr class="margin-small no-margin-top"><cm-login></cm-login><hr class="no-margin-top no-margin-bottom"><article class="item tac" ng-click="goTo(\'/registration\')" data-qa="register-btn" cm-reactive><span class="body"> {{\'REGISTER.LINK\'|cmTranslate}}</span><span class="icon-list"><i class="fa cm-right position-exception"></i></span></article><hr class="no-margin-top no-margin-bottom"><article class="cm-login-text mt15 is-selectable"> {{\'CAMEO.DESCRIBE\'|cmTranslate}}</article><article class="version is-selectable"> {{\'CAMEO.VERSION\'|cmTranslate}}: {{cmVersion.version}}</article></div></section>');
}]);
angular.module('widgets/password/wdgt-password-code.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/password/wdgt-password-code.html',
'<cm-scrollable><form name="cmForm" class="form-horizontal" autocomplete="off" novalidate><h2 cm-reactive><i class="fa cm-lock"></i> {{::\'PASSWORD_CODE.HEADING\'|cmTranslate}}<i class="fa cm-info"></i></h2><article class="content"><cm-info-bubble nose-x="50%" data-qa="info-confirmationSended"><span ng-bind-html="::\'PASSWORD_CODE.INFO.CONFIRMATION_SENDED\'|cmParse"></span></cm-info-bubble></article><hr class="margin-small"><article class="content"><label>{{::\'PASSWORD_CODE.LABEL.CODE\'|cmTranslate}} *</label><div class="cm-input-ctn with-inside-icon"><input tabindex="1" data-qa="inp-codeResetPassword" type="text" name="code" ng-model="formData.code" required cm-enter="checkCode()"/><i class="fa cm-write"></i></div></article><article class="content"><cm-info-bubble ng-show="cmUtil.objLen(info) > 0"><div ng-show="info.emptyCode" data-qa="info-codeEmpty"><i class="fa cm-info cm-orange"></i> {{::\'PASSWORD_CODE.INFO.EMPTY\'|cmTranslate}}</div><div ng-show="info.expired" data-qa="info-expired"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_CODE.INFO.EXPIRED\'|cmTranslate:{ linkGotoPasswordLost:link }" cm-html-compile></span></div></cm-info-bubble></article></form></cm-scrollable><cm-footer class="desktop-w-full"><button class="cm-btn-black w50 dib" ng-click="cancel()" data-qa="btn-cancelPasswordReset" cm-reactive><span> {{::\'PASSWORD_CODE.LABEL.CANCEL\'|cmTranslate}}</span><i class="fa cm-checkbox-wrong"></i></button><button class="cm-btn-black w50 dib" ng-click="checkCode()" data-qa="btn-checkResetPassword" cm-reactive><span ng-show="!showLoader"> {{::\'PASSWORD_CODE.LABEL.SUBMIT\'|cmTranslate}}</span><i class="fa cm-right" ng-show="!showLoader"></i><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('widgets/password/wdgt-password-lost.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/password/wdgt-password-lost.html',
'<cm-scrollable><form name="cmForm" class="form-horizontal" autocomplete="off" novalidate><h2 ng-click="showTitleText = showTitleText ? false : true" cm-reactive><i class="fa cm-lock"></i> {{::\'PASSWORD_LOST.HEADING\'|cmTranslate}}<i class="fa cm-info"></i></h2><article class="content" ng-show="showTitleText"><cm-info-bubble nose-x="50%"><span ng-bind-html="::\'PASSWORD_LOST.INFO.TITLE_TEXT\'|cmParse"></span></cm-info-bubble></article><hr class="margin-small"><article class="content"><label>{{::\'PASSWORD_LOST.LABEL.MIXED\'|cmTranslate}} *</label><div class="cm-input-ctn with-inside-icon"><input tabindex="1" data-qa="inp-passwordLost" type="text" name="identifier" ng-model="formData.identifier" required cm-enter="startResetPassword()"/><i class="fa cm-write"></i></div></article><article class="content"><cm-info-bubble ng-show="cmUtil.objLen(info) > 0"><div ng-show="info.empty" data-qa="info-identifierEmpty"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_LOST.INFO.EMPTY\'|cmParse"></span></div><div ng-show="info.loginNotFound" data-qa="info-loginNotFound"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_LOST.INFO.LOGIN_NOT_FOUND\'|cmParse"></span></div><div ng-show="info.phoneNumberNotFound" data-qa="info-phoneNumberNotFound"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_LOST.INFO.PHONENUMBER_NOT_FOUND\'|cmParse"></span></div><div ng-show="info.emailNotFound" data-qa="info-emailNotFound"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_LOST.INFO.EMAIL_NOT_FOUND\'|cmParse"></span></div><div ng-show="info.noEmailPhonenumber" data-qa="info-noEmailPhonenumber"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_LOST.INFO.NO_EMAIL_PHONENUMBER\'|cmParse"></span></div></cm-info-bubble></article></form></cm-scrollable><cm-footer class="desktop-w-full"><button class="cm-btn-black" ng-click="startResetPassword()" data-qa="btn-startResetPassword" cm-reactive><span ng-show="!showLoader"> {{::\'PASSWORD_LOST.LABEL.SUBMIT\'|cmTranslate}}</span><i class="fa cm-right" ng-show="!showLoader"></i><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('widgets/password/wdgt-password-reset.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/password/wdgt-password-reset.html',
'<cm-scrollable><h2 ng-click="showTitleText = showTitleText ? false : true" cm-reactive><i class="fa cm-lock"></i> {{::\'PASSWORD_RESET.HEADING\'|cmTranslate}}<i class="fa cm-info"></i></h2><article class="content"><cm-info-bubble ng-show="cmUtil.objLen(info) > 0"><div ng-show="info.expired" data-qa="info-requestExpired"><i class="fa cm-info cm-orange"></i><span ng-bind-html="::\'PASSWORD_RESET.INFO.EXPIRED\'|cmTranslate:{ linkGotoPasswordLost:link }" cm-html-compile></span></div></cm-info-bubble></article><form ng-show="!info.expired" name="cmForm" class="form-horizontal" autocomplete="off" novalidate><article class="content" ng-show="showTitleText"><cm-info-bubble nose-x="50%"><span ng-bind-html="::\'PASSWORD_RESET.INFO.TITLE_TEXT\'|cmParse"></span></cm-info-bubble></article><hr class="margin-small"><cm-password ng-model="formData.password" cm-tabindex="2" form-name="cmForm"></cm-password></form></cm-scrollable><cm-footer ng-show="!info.expired" class="desktop-w-full"><button class="cm-btn-black" ng-click="resetPassword()" data-qa="btn-resetPassword" cm-reactive><span ng-show="!showLoader"> {{::\'PASSWORD_RESET.LABEL.SUBMIT\'|cmTranslate}}</span><i class="fa cm-right" ng-show="!showLoader"></i><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('widgets/registration/wdgt-registration.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/registration/wdgt-registration.html',
'<cm-scrollable><form name="registrationForm" class="form-horizontal" role="form" autocomplete="off" novalidate><article class="content small-text mt5 tac is-selectable"> {{\'REGISTER.TITLE.MANDATORY_INFO\' | cmTranslate}}</article><hr class="margin-small"><h2 ng-click="toogleLoginInfo()" cm-reactive><i class="fa cm-key"></i> {{\'REGISTER.TITLE.HEAD_LOGIN\' | cmTranslate}}<i class="fa cm-info"></i></h2><article class="content" ng-show="showLoginInfo"><cm-info-bubble nose-x="50%"><span ng-bind-html="\'REGISTER.INFO.LOGIN_INFORMATION\'|cmParse"></span></cm-info-bubble></article><hr class="margin-small"><article class="content"><cm-cameo-id ng-model="formData.cameoId" form-name="registrationForm" cm-tabindex="1" placeholder="REGISTER.PLACEHOLDER.USERNAME"></cm-cameo-id></article><hr class="margin-small"><cm-password ng-model="formData.password" form-name="registrationForm" cm-tabindex="2"></cm-password><hr class="margin-small"><article class="content"><div class="cm-clear-bg terms-link is-selectable" data-qa="form-input"> {{\'REGISTER.LABEL.TERMS_ACCEPT\'|cmTranslate}}&nbsp;<a href="#/terms" data-qa="link-terms" class="classic-link">{{\'REGISTER.LABEL.TERMS\'|cmTranslate}}</a>&nbsp;*<input data-qa="checkbox-agb" type="checkbox" id="agbCheckboxInput" name="agb" ng-model="formData.agb" class="ng-hide" required /><i id="agbCheckbox" data-qa="icon-checkbox-agb" class="fa cm-ci-color ml15" ng-class="{ \'cm-checkbox\':registrationForm.agb.$invalid, \'cm-checkbox-right\':!registrationForm.agb.$invalid }" ng-click="acceptTerms()"></i></div><cm-info-bubble class="cm-alert" nose-x="55%" ng-show="formValidation && registrationForm.agb.$invalid" data-qa="register-info-terms"><div ng-show="registrationForm.agb.$invalid"><i class="fa cm-info"></i>{{\'REGISTER.INFO.TERMS\'|cmTranslate}}</div></cm-info-bubble></article></form></cm-scrollable><cm-footer class="desktop-w-full"><button id="registerUserButton" class="cm-btn-black" ng-click="createUser()" data-qa="btn-createUser" cm-reactive><span ng-show="!showLoader"> {{\'REGISTER.LABEL.SUBMIT\'|cmTranslate}}</span><i class="fa cm-right" ng-show="!showLoader"></i><cm-loader ng-show="showLoader" cm-color="ci-color"></cm-loader></button></cm-footer>');
}]);
angular.module('widgets/security/wdgt-authentication.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/security/wdgt-authentication.html',
'<cm-scrollable><h2 class="border-bottom"><i class="fa cm-key"></i> {{ [ BASE+"PAGE_HEADLINE", BASE+"PAGE_HEADLINE", BASE+"PAGE_HEADLINE", BASE+"PAGE_HEADLINE" ][step] | cmTranslate}}</h2><article class="content"><div class= "authentication-status"><i class= "fa cm-key-request" ng-class="{\'active\': step > 0}"></i><i class= "fa cm-key-response" ng-class="{\'active\': step > 1}"></i><i class= "fa cm-handshake" ng-class="{\'active\': step > 2}"></i></div><div class="space-for-loader"><cm-loader cm-halt="waiting" type="balls"></cm-loader></div><cm-info-bubble class="cm-alert" ng-show="ERROR"><div><i class="fa cm-attention"></i> {{BASE+"ERROR."+ERROR| uppercase |cmTranslate}}</div></cm-info-bubble></article><hr/><article class="content"><h3> {{ [ BASE+"HEADLINE", BASE+"HEADLINE", BASE+"HEADLINE", BASE+"HEADLINE" ][step] | cmTranslate}}</h3><cm-info-bubble nose-x = "40%"> {{ [ BASE+"EXPLANATION", BASE+"EXPLANATION", BASE+"EXPLANATION", BASE+"EXPLANATION" ][step] | cmTranslate:{\'identity\': toIdentity.getDisplayName()} }}<br/><br/><strong ng-bind-html="[BASE+\'START.INSTRUCTIONS\',BASE+\'WAIT.INSTRUCTIONS\',BASE+\'WAIT.INSTRUCTIONS\',BASE+\'DONE.INSTRUCTIONS\'] [step] | cmParse"></strong></cm-info-bubble></article><hr/><article ng-if="step > 0 && step <3" class="content"><div class="transaction-secret is-selectable" ng-if="transactionSecret" data-qa="transaction-secret-value"> {{transactionSecret || \'...\'}}</div><ng-loader ng-if = "!transactionSecret"></ng-loader></article><article class="content"><strong> {{ [ BASE+"START.NOTE", BASE+"WAIT.NOTE", BASE+"WAIT.NOTE", BASE+"DONE.NOTE" ][step] | cmTranslate:{\'identity\': toIdentity.getDisplayName()} }}</strong></article><br/><article ng-if="step != 3 && !!getTimeout()" class="content"><cm-timeout cm-data = "getTimeout()"> {{BASE+"TIMEOUT" | cmTranslate: {\'timeout\' : cmTimeout } }}</cm-timeout></article></cm-scrollable><cm-footer><button ng-if="step == 0" ng-click = "done()" class = "cm-btn-grey dib w50" data-qa = "btn-cancel-authentication" cm-reactive > {{BASE+"START.CANCEL_BUTTON"|cmTranslate}}<i class="fa cm-checkbox-wrong"></i></button><button ng-if="step == 0" ng-click = "startAuthenticationRequest()" class = "cm-btn-grey dib w50" data-qa = "btn-start-authentication" cm-reactive ><span ng-if = "!ERROR"> {{BASE+"START.START_BUTTON"|cmTranslate}}</span><span ng-if = "ERROR"> {{BASE+"START.RETRY_BUTTON"|cmTranslate}}</span><i class="fa cm-handshake"></i></button><button ng-if = "step > 0 && step < 3" ng-click = "cancel()" class = "cm-btn-grey" data-qa = "btn-cancel-authentication" cm-reactive > {{BASE+"WAIT.CANCEL_BUTTON"|cmTranslate}}<i class="fa cm-checkbox-wrong"></i></button><button ng-if = "step == 3" ng-click = "done()" class = "cm-btn-grey" data-qa = "btn-start-authentication" cm-reactive > {{BASE+"SUCCESSFUL.DONE_BUTTON"|cmTranslate}}<i class="fa cm-checkbox-wrong"></i></button></cm-footer>');
}]);
angular.module('widgets/settings/identity/key/wdgt-identity-key-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/key/wdgt-identity-key-create.html',
'<h2 class="border-bottom no-margin-bottom"><i class="fa cm-key"></i> {{\'IDENTITY.KEYS.HEADER\'|cmTranslate}}</h2><cm-identity-key-create class="theme-a"></cm-identity-key-create>');
}]);
angular.module('widgets/settings/identity/key/wdgt-identity-key-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/key/wdgt-identity-key-edit.html',
'<h2 class="border-bottom"><i class="fa cm-key"></i> {{\'SETTINGS.PAGES.IDENTITY.KEYS.DETAIL\'|cmTranslate}}</h2><cm-identity-key-edit></cm-identity-key-edit>');
}]);
angular.module('widgets/settings/identity/key/wdgt-identity-key-import.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/key/wdgt-identity-key-import.html',
'<h2 class="border-bottom"><i class="fa cm-import-key"></i> {{\'SETTINGS.PAGES.IDENTITY.KEYS.IMPORT.HEADER\'|cmTranslate}}</h2><cm-identity-key-import></cm-identity-key-import>');
}]);
angular.module('widgets/settings/identity/key/wdgt-identity-key-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/key/wdgt-identity-key-list.html',
'<h2 class="border-bottom no-margin-bottom"><i class="fa cm-key"></i> {{\'SETTINGS.PAGES.IDENTITY.KEYS.HEADER\'|cmTranslate}}</h2><cm-identity-key-list></cm-identity-key-list>');
}]);
angular.module('widgets/settings/identity/wdgt-identity-create.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/wdgt-identity-create.html',
'<h2 class="border-bottom"><i class="fa cm-avatar-add"></i> {{\'SETTINGS.PAGES.IDENTITY.CREATE.HEADER\'|cmTranslate}}</h2><cm-identity-create></cm-identity-create>');
}]);
angular.module('widgets/settings/identity/wdgt-identity-edit.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/wdgt-identity-edit.html',
'<h2 class="border-bottom"><i class="fa cm-avatar"></i> {{\'IDENTITY.LABEL.IDENTITY\'|cmTranslate}}</h2><cm-identity-edit></cm-identity-edit>');
}]);
angular.module('widgets/settings/identity/wdgt-identity-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/identity/wdgt-identity-list.html',
'<h2 class="border-bottom"><i class="fa cm-avatar"></i> {{\'IDENTITY.OVERVIEW.HEADER\'|cmTranslate}}</h2><article class="content mb15"><cm-info-bubble nose-x="55%"><span ng-bind-html="\'IDENTITY.OVERVIEW.INFO_TEXT\' | cmParse"></span></cm-info-bubble></article><cm-identity-list cm-identities="identities"></cm-identity-list>');
}]);
angular.module('widgets/settings/wdgt-settings-about-us.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/wdgt-settings-about-us.html',
'<h2 class="border-bottom"><i class="fa cm-rhino-bubble-glyph"></i> {{::\'SETTINGS.PAGES.ABOUT_US.TITLE\'|cmTranslate}}</h2><article class="about-us content tac is-selectable"><i class="fa cm-rhino-bubble-glyph"></i><br /> {{version}}<br /> {{::\'SETTINGS.PAGES.ABOUT_US.TEXT\'|cmTranslate}}</article><hr><h4 ng-bind-html="::\'DRTV.IMPRINT.HEADLINE\'|cmParse" cm-html-compile class="content is-selectable"></h4><article ng-bind-html="::\'DRTV.IMPRINT.CONTENT\'|cmParse" cm-html-compile class="content is-selectable"></article><hr><h3 class="content"> {{::\'SETTINGS.PAGES.ABOUT_US.3RD_PARTY.TITLE\'|cmTranslate}}&nbsp; (<cm-time-converter cm-timestamp="thirdPartyLibraries.date" cm-special-type="date-seperator"></cm-time-converter>)</h3><ul class="is-selectable-all"><li ng-repeat="lib in thirdPartyLibraries.libraries"><span class="item text mb5"> {{::lib.name}}<br /><a href="{{::lib.url}}" target="_blank">{{::lib.url}}</a></span></li></ul>');
}]);
angular.module('widgets/settings/wdgt-settings-account.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/wdgt-settings-account.html',
'<h2 class="border-bottom no-margin-bottom"><i class="fa cm-person"></i> {{\'SETTINGS.ACCOUNT\'|cmTranslate}}</h2><cm-account-edit></cm-account-edit>');
}]);
angular.module('widgets/settings/wdgt-settings-app.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/wdgt-settings-app.html',
'<h2 class="no-margin-bottom border-bottom"><i class="fa cm-fix"></i> {{\'SETTINGS.APP\' | cmTranslate}}</h2><ul class="no-border-top"><li><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.LANGUAGE\' | cmTranslate}}</span></span><section class="icon-list"><div class="cm-select-ctn" cm-language-select></div></section></article></li><li ng-click="handleBooleans(\'convertSmileysToEmojis\')" cm-reactive><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.EMOJI_CONVERT\' | cmTranslate}}</span></span><section class="icon-list"><i class="fa" ng-class="{\'cm-radio-0\':!settings.convertSmileysToEmojis,\'cm-radio-1\':settings.convertSmileysToEmojis}"></i></section></article></li><li ng-click="handleBooleans(\'sendOnReturn\')" cm-reactive><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.SEND_ON_RETURN\' | cmTranslate}}</span></span><section class="icon-list"><i class="fa" ng-class="{\'cm-radio-0\':!settings.sendOnReturn, \'cm-radio-1\':settings.sendOnReturn}"></i></section></article></li><li ng-click="handleBooleans(\'skipKeyInfo\')" cm-reactive><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.SKIP_KEY_INFO\' | cmTranslate}}</span></span><section class="icon-list"><i class="fa" ng-class="{\'cm-radio-0\':!settings.skipKeyInfo, \'cm-radio-1\':settings.skipKeyInfo}" data-qa="checkbox-skip-keyinfo"></i></section></article></li><li><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.DATE_FORMAT\' | cmTranslate}}</span></span><section class="icon-list"><div class="cm-select-ctn" cm-date-format-select></div></section></article></li><li><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.TIME_FORMAT\' | cmTranslate}}</span></span><section class="icon-list"><div class="cm-select-ctn" cm-time-format-select></div></section></article></li><li ng-click="handleBooleans(\'enableUnreadMessages\')" cm-reactive data-qa="ctn-settings-enable-unread-messages"><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.APP.ENABLE_UNREAD_MESSAGES\' | cmTranslate}}</span></span><section class="icon-list"><i class="fa" ng-class="{\'cm-radio-0\':!settings.enableUnreadMessages, \'cm-radio-1\':settings.enableUnreadMessages}" data-qa="checkbox-enable-unread-messages"></i></section></article></li></ul>');
}]);
angular.module('widgets/settings/wdgt-settings-list.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/wdgt-settings-list.html',
'<h2 class="no-margin-bottom border-bottom"><i class="fa cm-settings"></i> {{\'SETTINGS.LABEL\' | cmTranslate}}</h2><ul class="no-border-top"><li ng-repeat="page in overviewKeys" ng-click="goToSettingsPage($event, page, overview[page].disabled, overview[page])" ng-class="{\'is-disabled\':overview[page].disabled,\'is-active\':checkActive(page)}" data-qa="{{overview[page][\'data-qa\']}}" cm-reactive><span class="item clearfix"><span class="title single-line"><i class="fa" ng-class="overview[page].icon"></i><span>{{overview[page].i18n|cmTranslate}}</span></span><section class="icon-list"><i class="fa cm-right"></i></section></span></li><li ng-click="logout()" cm-reactive><span class="item clearfix"><i class="fa cm-logout icon-left"></i><span>{{\'MENU.LOGOUT\'|cmTranslate}}</span></span></li></ul>');
}]);
angular.module('widgets/settings/wdgt-settings-notify.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/settings/wdgt-settings-notify.html',
'<h2 class="no-margin-bottom border-bottom"><i class="fa cm-bell"></i> {{\'SETTINGS.NOTIFY\' | cmTranslate}}</h2><ul class="no-border-top"><li ng-click="handlePushNotifications()" ng-class="{\'is-disabled\':!isApp()}" cm-reactive><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.NOTIFY.PUSH_NOTIFICATIONS\' | cmTranslate}}</span></span><section class="icon-list"><i ng-show="!changePushNotifications" class="fa" ng-class="{ \'cm-radio-0\':!settings.pushNotifications, \'cm-radio-1\':settings.pushNotifications }"></i><cm-loader ng-show="changePushNotifications" class="in-icon-list"></cm-loader></section></article></li><li ng-click="handleBrowserNotifications()" ng-class="{\'is-disabled\':isApp() || !enabledBrowserNotification}" cm-reactive><article class="item clearfix"><span class="title"><span>{{\'SETTINGS.PAGES.NOTIFY.BROWSER_NOTIFICATIONS\' | cmTranslate}}</span></span><section class="icon-list"><i class="fa" ng-class="{ \'cm-radio-0\':!settings.browserNotifications, \'cm-radio-1\':settings.browserNotifications }"></i></section></article></li></ul>');
}]);
angular.module('widgets/setup/wdgt-setup-account.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/setup/wdgt-setup-account.html',
'<h2 class="border-bottom"><i class="fa cm-person"></i> {{\'ACCOUNT.CREATE.HEADER\'|cmTranslate}}</h2><cm-setup-account></cm-setup-account>');
}]);
angular.module('widgets/setup/wdgt-setup-identity.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/setup/wdgt-setup-identity.html',
'<h2 class="border-bottom"><i class="fa cm-person"></i> {{\'SETTINGS.PAGES.IDENTITY.CREATE.HEADER\'|cmTranslate}}</h2><cm-setup-identity></cm-setup-identity>');
}]);
angular.module('widgets/setup/wdgt-setup-keyinfo.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/setup/wdgt-setup-keyinfo.html',
'<cm-scrollable><h2 class="border-bottom is-selectable"><i class="fa cm-key"></i> {{\'IDENTITY.LABEL.KEYMANAGEMENT\'|cmTranslate}}</h2><article class="content"><cm-info-bubble nose-x="50%"><span ng-bind-html="\'SETTINGS.PAGES.IDENTITY.KEYS.NO_LOCALKEYS_ON_THIS_DEVICE\' | cmParse"></span></cm-info-bubble></article><ul class="border-top mt15"><li ng-click="toggleSkipKeyInfo()" cm-reactive><span class="item disabled is-selectable"> {{\'START.KEYINFO.SKIP_CHECKBOX_TEXT\' | cmTranslate}}</span><div class="short-links without-bg"><input id="skipKeyInfoInput" data-qa="checkbox-skip-key-info-input" name="skip" type="checkbox" class="ng-hide" /><i id="skipKeyInfoIcon" data-qa="checkbox-skip-key-info-icon" class="fa cm-grey" ng-class="{ \'cm-checkbox\':!skipKeyInfo, \'cm-checkbox-right\':skipKeyInfo }"></i></div></li><li ng-click="goTo(\'/talks\')" data-qa="btn-skip-keygen" cm-reactive><span class="item"> {{\'START.KEYINFO.SKIP_TEXT\' | cmTranslate}}</span><div class="short-links without-bg"><i class="fa cm-right"></i></div></li><li><span class="item is-selectable" ng-click="toggleKeySize()" cm-reactive> {{\'IDENTITY.KEYS.GENERATE.START.KEY_LENGTH.BUTTON_LABEL\'|cmTranslate}} <strong>2048 (default)</strong></span><div class="short-links without-bg" ng-click="toggleKeySize()" cm-reactive data-qa="btn-toggle-keysize"><i class="fa" ng-class="{\'cm-down\':!showKeySize,\'cm-up\':showKeySize}"></i></div><ul class="cm-submenu" ng-show="showKeySize"><li ng-click="chooseKeySize(\'2048\')" data-qa="checkbox-keysize-2048" cm-reactive><span class="item">2048</span><div class="short-links without-bg"><i class="fa" ng-class="{\'cm-checkbox\':keySize != 2048,\'cm-checkbox-right\':keySize == 2048}"></i></div></li><li ng-click="chooseKeySize(\'4096\')" data-qa="checkbox-keysize-4096" cm-reactive><span class="item">4096</span><div class="short-links without-bg"><i class="fa" ng-class="{\'cm-checkbox\':keySize != 4096,\'cm-checkbox-right\':keySize == 4096}"></i></div></li></ul></li></ul></cm-scrollable><cm-footer><button ng-click="generateKey()" class="cm-btn-grey" data-qa="btn-next-step" cm-reactive> {{\'SETTINGS.PAGES.IDENTITY.KEYS.CREATE.HEADER\' | cmTranslate}}<i class="fa cm-right"></i></button></cm-footer>');
}]);
angular.module('widgets/start/wdgt-download.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/start/wdgt-download.html',
'<h2 class="border-bottom is-selectable"><i class="fa cm-download-blanc"></i> {{::\'START.DOWNLOAD.HEADER\'|cmTranslate}}</h2><article class="content"><cm-info-bubble nose-x="50%"><span ng-bind-html="::\'START.DOWNLOAD.SUB_TEXT\' | cmParse"></span></cm-info-bubble></article><ul class="border-top border-bottom mt15"><li ng-repeat="app in appLinks"><span class="item tac without-height" cm-reactive ng-click="openExternalLink(app.href)"><img ng-src="{{app.icon}}" /></span><hr class="margin-small"><span class="item tac without-height" ng-if="app.direct && app.direct.href != \'\'" cm-reactive ng-click="openExternalLink(app.direct.href)"><img ng-src="{{app.direct.icon}}" /></span></li><li ng-click="goToSetup()" data-qa="btn-skip-download" cm-reactive><span class="item is-selectable"> {{::\'START.DOWNLOAD.SKIP_TEXT\' | cmTranslate}}</span><div class="short-links without-bg"><i class="fa cm-right"></i></div></li></ul>');
}]);
angular.module('widgets/start/wdgt-quickstart.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/start/wdgt-quickstart.html',
'<cm-scrollable><h2 class="border-bottom is-selectable"><i class="fa cm-rhino-positive"></i> {{::\'START.QUICKSTART.HEADLINE\'|cmTranslate}}</h2><article ng-bind-html="::\'START.QUICKSTART.SUB_TEXT\' | cmParse" class="cm-bold content is-selectable"></article><hr /><h4 class="content is-selectable"><i class=\'fa cm-key\'></i>&nbsp; {{::\'START.QUICKSTART.HEADLINE_1\'|cmTranslate}}</h4><article ng-bind-html="::\'START.QUICKSTART.TEXT_1\' | cmParse" class="content is-selectable"></article><hr /><h4 class="content is-selectable"><i class=\'fa cm-new-contact\'></i>&nbsp; {{::\'START.QUICKSTART.HEADLINE_2\'|cmTranslate}}</h4><article ng-bind-html="::\'START.QUICKSTART.TEXT_2\' | cmParse" class="content is-selectable"></article><hr /><h4 class="content is-selectable"><i class=\'fa cm-new-talk\'></i>&nbsp; {{::\'START.QUICKSTART.HEADLINE_3\'|cmTranslate}}</h4><article ng-bind-html="::\'START.QUICKSTART.TEXT_3\' | cmParse" class="content is-selectable"></article><hr /><h3 ng-bind-html="::\'START.WELCOME.TEXT_4\' | cmParse" class="content is-selectable"></h3><article ng-bind-html="::\'START.WELCOME.TEXT_5\' | cmParse" class="content is-selectable"></article></cm-scrollable><cm-footer ng-if="startRoute"><button ng-click="generateKey()" class="cm-btn-grey" data-qa="btn-next-step is-selectable" cm-reactive> {{::\'START.BTNS.NEXT\' | cmTranslate}}<i class="fa cm-right"></i></button></cm-footer>');
}]);
angular.module('widgets/start/wdgt-welcome.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/start/wdgt-welcome.html',
'<cm-scrollable><h2 class="border-bottom is-selectable"><i class="fa cm-rhino-positive"></i> {{\'START.WELCOME.HEADLINE\'|cmTranslate}}</h2><article ng-bind-html="\'START.WELCOME.TEXT_1\' | cmParse" class="content is-selectable"></article><hr/><article ng-bind-html="\'START.QUICKSTART.SUB_TEXT\' | cmParse" class="cm-bold content is-selectable"></article><hr /><h4 class="content is-selectable"><i class=\'fa cm-key\'></i>&nbsp; {{\'START.QUICKSTART.HEADLINE_1\'|cmTranslate}}</h4><article ng-bind-html="\'START.QUICKSTART.TEXT_1\' | cmParse" class="content is-selectable"></article><hr /><h4 class="content is-selectable"><i class=\'fa cm-new-contact\'></i>&nbsp; {{\'START.QUICKSTART.HEADLINE_2\'|cmTranslate}}</h4><article ng-bind-html="\'START.QUICKSTART.TEXT_2\' | cmParse" class="content is-selectable"></article><hr /><h4 class="content is-selectable"><i class=\'fa cm-new-talk\'></i>&nbsp; {{\'START.QUICKSTART.HEADLINE_3\'|cmTranslate}}</h4><article ng-bind-html="\'START.QUICKSTART.TEXT_3\' | cmParse" class="content is-selectable"></article><hr /><h3 ng-bind-html="\'START.WELCOME.TEXT_4\' | cmParse" class="content is-selectable"></h3><article ng-bind-html="\'START.WELCOME.TEXT_5\' | cmParse" class="content is-selectable"></article></cm-scrollable><cm-footer><button ng-click="generateKey()" class="cm-btn cm-btn-grey is-selectable" data-qa="btn-next-step" cm-reactive> {{\'START.BTNS.NEXT\' | cmTranslate}}<i class="fa cm-right"></i></button></cm-footer>');
}]);
angular.module('widgets/systemcheck/wdgt-systemcheck.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/systemcheck/wdgt-systemcheck.html',
'<h2>{{\'SYSTEMCHECK.HEADLINE\'|cmTranslate}}</h2><h3 class="content is-selectable" ng-class="{\'cm-green\':isClientUpToDate,\'cm-orange\':!isClientUpToDate}"> {{::\'SYSTEMCHECK.CLIENTVERSION.HEADLINE\'|cmTranslate}} <i class="fa" ng-class="{\'cm-checker\':isClientUpToDate,\'cm-checkbox-wrong\':!isClientUpToDate}"></i></h3><article class="content"><cm-info-bubble nose-x="15%"><section ng-if="!isClientUpToDate" ng-bind-html="::\'SYSTEMCHECK.CLIENTVERSION.TEXT_ERROR\'|cmParse:{data:{\'version\':version}} "></section><section ng-if="isClientUpToDate" ng-bind-html="::\'SYSTEMCHECK.CLIENTVERSION.TEXT_OK\'|cmParse:{data:{\'version\':version}}"></section></cm-info-bubble></article><ul class="border-top mt15 no-border-bottom" ng-if="(!isClientUpToDate && isApp)"><li ng-repeat="app in appLinks"><span class="item tac without-height" cm-reactive ng-click="openExternalLink(app.href)"><img ng-src="{{app.icon}}" /></span><hr class="margin-small"><span class="item tac without-height" ng-if="app.direct && app.direct.href != \'\'" cm-reactive ng-click="openExternalLink(app.direct.href)"><img ng-src="{{app.direct.icon}}" /></span></li></ul><hr /><h3 class="content is-selectable" ng-class="{\'cm-green\':localStorage,\'cm-orange\':!localStorage}"> {{::\'SYSTEMCHECK.LOCALSTORAGE.HEADLINE\'|cmTranslate}} <i class="fa" ng-class="{\'cm-checker\':localStorage,\'cm-checkbox-wrong\':!localStorage}"></i></h3><article class="content"><cm-info-bubble nose-x="15%"><section ng-if="!localStorage" ng-bind-html="::\'SYSTEMCHECK.LOCALSTORAGE.TEXT_ERROR\'|cmParse"></section><section ng-if="localStorage" ng-bind-html="::\'SYSTEMCHECK.LOCALSTORAGE.TEXT_OK\'|cmParse"></section></cm-info-bubble></article>');
}]);
angular.module('widgets/talks/wdgt-talks.html', []).run([
'$templateCache', function($templateCache) {
$templateCache.put('widgets/talks/wdgt-talks.html',
'<!--<cm-loader ng-show="conversations.state.is(\'initial-loading\')" class="fullscreen"></cm-loader>--><ul><li ng-if="!conversations.length && !conversations.state.is(\'loading\')" class="with-inside-left-icon"><i class="fa cm-info"></i><div class="item"> {{::\'TALKS.LIST_EMPTY\'|cmTranslate}}</div></li><li ng-repeat="conversation in conversations | orderBy:\'timeOfLastUpdate\':true | cmSearch:\'talks\':search as results" cm-reactive data-qa="conversation-list-element" cm-context="{model:conversation,type:\'conversation\',tap:goto(\'/conversation/\'+conversation.id)}"><cm-conversation-tag cm-data="conversation"></cm-conversation-tag></li><li cm-hide-on-filter="search" ng-if="moreTalksAvailable()"><button class="cm-btn-grey" ng-click="loadMoreTalks()" data-qa="load-more-btn" cm-reactive> {{::\'TALKS.MORE\'|cmTranslate}}</button></li><li class="with-inside-left-icon" ng-show="(results.length == 0)" data-qa="ctn-talks-not-found"><i class="fa cm-attention"></i><div class="item"> {{::\'TALKS.SEARCH.INFO_NOTHING_FOUND\' | cmTranslate}}</div></li><li cm-show-on-filter="search" cm-show-on-min-length="3" data-qa="btn-search-at-server"><cm-search-conversations></cm-search-conversations></li></ul>');
}]);
angular.module('cmWidgets',[
    'cmCore',
    'cmPhonegap'
,'widgets/cameo/wdgt-terms.html','widgets/contact/wdgt-contact-create.html','widgets/contact/wdgt-contact-edit.html','widgets/contact/wdgt-contact-import.html','widgets/contact/wdgt-contact-list.html','widgets/contact/wdgt-contact-request-list.html','widgets/conversation/wdgt-conversation-recipients.html','widgets/conversation/wdgt-conversation-security.html','widgets/conversation/wdgt-conversation.html','widgets/help/wdgt-help-list.html','widgets/login/wdgt-login.html','widgets/password/wdgt-password-code.html','widgets/password/wdgt-password-lost.html','widgets/password/wdgt-password-reset.html','widgets/registration/wdgt-registration.html','widgets/security/wdgt-authentication.html','widgets/settings/identity/key/wdgt-identity-key-create.html','widgets/settings/identity/key/wdgt-identity-key-edit.html','widgets/settings/identity/key/wdgt-identity-key-import.html','widgets/settings/identity/key/wdgt-identity-key-list.html','widgets/settings/identity/wdgt-identity-create.html','widgets/settings/identity/wdgt-identity-edit.html','widgets/settings/identity/wdgt-identity-list.html','widgets/settings/wdgt-settings-about-us.html','widgets/settings/wdgt-settings-account.html','widgets/settings/wdgt-settings-app.html','widgets/settings/wdgt-settings-list.html','widgets/settings/wdgt-settings-notify.html','widgets/setup/wdgt-setup-account.html','widgets/setup/wdgt-setup-identity.html','widgets/setup/wdgt-setup-keyinfo.html','widgets/start/wdgt-download.html','widgets/start/wdgt-quickstart.html','widgets/start/wdgt-welcome.html','widgets/systemcheck/wdgt-systemcheck.html','widgets/talks/wdgt-talks.html'])
.directive('cmWidgetTerms', [
    'cmConfig',
    function(cmConfig){
        return {
            restrict: 'E',
            templateUrl: 'widgets/cameo/wdgt-terms.html',
            controller: function ($scope) {
                $scope.version = cmConfig.version;
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactList
 * @description
 * Lists contacts.
 *
 * @restrict AE
 */


.directive('cmWidgetContactCreate', [
    function(){
        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'widgets/contact/wdgt-contact-create.html',
            controller: function(){
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactEdit
 * @description
 *
 * @restrict E
 */


.directive('cmWidgetContactEdit', [
    function(){
        return {
            restrict: 'E',
            scope: {
                contact: '=cmData'
            },
            templateUrl: 'widgets/contact/wdgt-contact-edit.html'
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactImport
 * @description
 * Lists contacts.
 *
 * @restrict AE
 */


.directive('cmWidgetContactImport', [
    function( ){
        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'widgets/contact/wdgt-contact-import.html'
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactList
 * @description
 * Lists contacts.
 *
 * @restrict AE
 */


.directive('cmWidgetContactList', [

    //no dependencies

    function () {
        return {
            restrict: 'AE',
            templateUrl: 'widgets/contact/wdgt-contact-list.html',
            scope: true,

            controller: function ($scope, $element, $attrs) {
                //nothing to do here yet
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetContactList
 * @description
 * Lists contacts.
 *
 * @restrict AE
 */


.directive('cmWidgetContactRequestList', [

    //no dependencies

    function () {
        return {
            restrict: 'AE',
            templateUrl: 'widgets/contact/wdgt-contact-request-list.html',
            scope: true,

            controller: function ($scope, $element, $attrs) {
                //nothing to do here yet
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetConversation
 * @description
 * Display Conversation and provides functionality.
 *
 * @restrict AE
 */


.directive('cmWidgetConversationRecipients', [
    function () {
        return {
            restrict: 'AE',
            templateUrl: 'widgets/conversation/wdgt-conversation-recipients.html',
            scope: {
                conversation: '=cmData',
                search: '=cmSearch'
            },
            controller: function () {

            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetConversation
 * @description
 * Display Conversation and provides functionality.
 *
 * @restrict AE
 */


.directive('cmWidgetConversationSecurity', [

    function () {
        return {
            restrict: 'AE',
            templateUrl: 'widgets/conversation/wdgt-conversation-security.html',
            scope: {
                conversation: '=cmData'
            },
            controller: function () {

            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetConversation
 * @description
 * Display Conversation and provides functionality.
 *
 * @restrict AE
 */


.directive('cmWidgetConversation', [

    'cmWidget',

    function (cmWidget){
        return {
            restrict: 'AE',
            templateUrl: 'widgets/conversation/wdgt-conversation.html',
            scope: {
               conversation: '=cmData'
            },
            link: function(scope, element, attrs){
                cmWidget.setup(scope, element, attrs)
            },
            controller: function ($scope) {

            }
        }
    }
])
.directive('cmWidgetHelpList', [
    'cmUserModel', 'cmConfig', 'cmUtil', 'cmNotify',
    '$window', '$location',
    function(cmUserModel, cmConfig, cmUtil, cmNotify,
             $window, $location){
        return {
            restrict: 'E',
            templateUrl: 'widgets/help/wdgt-help-list.html',
            controller: function ($scope) {
                $scope.overview = cmConfig.routeHelp;
                $scope.overviewKeys = Object.keys($scope.overview);

                cmNotify.unringBimmel('markHelp');

                $scope.handleLink = function($event, pageUrl, isDisabled, route){
                    if('externLink' in route){
                        $window.open(route.externLink);
                        return false;
                    }

                    if('link' in route){
                        // file:///android_asset/www/index.html#/login
                        if(cmUtil.startsWith($location.$$absUrl, 'file:///')) {
                            $window.location = route.link;
                        // http://localhost:8000/app/#/settings
                        } else if($location.$$absUrl.indexOf('/#/') != -1) {
                            var arr_location = $location.$$absUrl.split('/#/');
                            location.href = arr_location[0] + '/' + route.link;
                        }

                        return false;
                    }

                    if(typeof pageUrl !== 'undefined' && isDisabled == undefined){
                        $event.stopPropagation();
                        $event.preventDefault();
                        $scope.goTo(pageUrl);
                    }
                };

                $scope.checkActive = function(page){
                    if($location.$$url.indexOf('identity') != -1 && page.indexOf('identity') != -1){
                        if(page.indexOf('key') != -1 && $location.$$url.indexOf('key') != -1){
                            return true;
                        } else if(page.indexOf('key') == -1 && $location.$$url.indexOf('key') == -1){
                            return true;
                        }

                    } else if($location.$$url.indexOf(page) != -1){
                        return true;
                    }

                    return false;
                };

            }
        }
    }
])
.directive('cmWidgetLogin',[
    'cmVersion',
    '$rootScope',
    function(cmVersion,
             $rootScope) {
        return {
            restrict: 'AE',
            scope: true,
            templateUrl: 'widgets/login/wdgt-login.html',

            controller: function ($scope) {
                $scope.cmVersion = cmVersion;

                var app = angular.element(document.querySelector('#cm-app')),
                    frame = angular.element(document.querySelector('.view-frame'));

                app.addClass('full-height');
                frame.addClass('full-height');

                $scope.$on('$destroy', function () {
                    app.removeClass('full-height');
                    frame.removeClass('full-height');
                });
            }
        }
    }
])
.directive('cmWidgetPasswordCode', [
    'cmAuth', 'cmLoader', 'cmUtil',
    '$rootScope', '$q',
    function (cmAuth, cmLoader, cmUtil,
              $rootScope, $q) {
        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'widgets/password/wdgt-password-code.html',

            controller: function ($scope) {
                var loader = new cmLoader($scope);

                $scope.cmUtil = cmUtil;

                $scope.link = '<a href="#/password/lost">{{\'PASSWORD_RESET.LABEL.LINK_GOTO_PASSWORD_LOST\'|cmTranslate}}</a>';

                function reset(){
                    $scope.info = {};
                    $scope.formData = {
                        code: ''
                    };
                }

                reset();

                /**
                 * validate cmForm
                 * @returns {*}
                 */
                $scope.validateForm = function () {
                    var deferred = $q.defer(),
                        objectData = {};

                    if($scope.cmForm.code.$modelValue && $scope.cmForm.code.$modelValue != '')
                        objectData.code = $scope.cmForm.code.$modelValue;
                    else
                        $scope.info.emptyCode = true;

                    if(cmUtil.objLen(objectData) > 0) {
                        deferred.resolve(objectData);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                $scope.checkCode = function(){
                    if (loader.isIdle())
                        return false;

                    loader.start();

                    $scope.info = {};

                    $scope.validateForm().then(
                        function(objectChange) {

                            cmAuth.checkResetPassword(objectChange.code).then(
                                function(data){
                                    loader.stop();

                                    $rootScope.goTo('/password/reset/'+data.id);
                                },
                                function(response){
                                    loader.stop();
                                    switch(response.data.errorCodes[0]){
                                        case 'PASSWORD.RESET.EXPIRED':
                                            $scope.info.expired = true;
                                        break;
                                    }
                                }
                            )
                        },
                        function() {
                            loader.stop();
                        }
                    );
                };

                $scope.cancel = function(){
                    $rootScope.goTo('/password/lost');
                };
            }
        }
    }
])
.directive('cmWidgetPasswordLost', [
    'cmAuth', 'cmLoader', 'cmUtil',
    '$rootScope', '$q',
    function (cmAuth, cmLoader, cmUtil,
              $rootScope, $q) {
        return {
            restrict: 'E',
            scope: true,
            templateUrl: 'widgets/password/wdgt-password-lost.html',

            controller: function ($scope) {
                var loader = new cmLoader($scope);

                $scope.cmUtil = cmUtil;

                function reset(){
                    $scope.info = {};
                    $scope.formData = {
                        identifier: ''
                    };
                }

                reset();

                /**
                 * validate cmForm
                 * @returns {*}
                 */
                $scope.validateForm = function() {
                    var deferred = $q.defer(),
                        objectData = {};

                    if ($scope.cmForm.identifier.$modelValue && $scope.cmForm.identifier.$modelValue != '')
                        objectData.identifier = $scope.cmForm.identifier.$modelValue;
                    else
                        $scope.info.empty = true;

                    if(cmUtil.objLen(objectData) > 0) {
                        deferred.resolve(objectData);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                /**
                 * Form Validation and Apicall to send password reset
                 */
                $scope.startResetPassword = function () {
                    if (loader.isIdle())
                        return false;

                    loader.start();

                    $scope.info = {};

                    $scope.validateForm().then(
                        function(objectChange) {

                            cmAuth.sendPasswordLost(objectChange).then(
                                function(){
                                    loader.stop();

                                    $rootScope.goTo('/password/code');
                                },
                                function(response){
                                    loader.stop();
                                    switch(response.data.errorCodes[0]){
                                        case 'PASSWORD.RESET.LOGIN.NOT.FOUND':
                                            $scope.info.loginNotFound = true;
                                        break;
                                        case 'PASSWORD.RESET.PHONENUMBER.NOT.FOUND':
                                            $scope.info.phoneNumberNotFound = true;
                                        break;
                                        case 'PASSWORD.RESET.EMAIL.NOT.FOUND':
                                            $scope.info.emailNotFound = true;
                                        break;
                                        case 'PASSWORD.RESET.NO.EMAIL.PHONENUMBER':
                                            $scope.info.noEmailPhonenumber = true;
                                        break;
                                    }
                                }
                            )
                        },
                        function() {
                            loader.stop();
                        }
                    );
                };

                $scope.resetForm = function(){
                    reset();
                };
            }
        }
    }
])
.directive('cmWidgetPasswordReset', [
    'cmAuth', 'cmLoader', 'cmCrypt', 'cmUtil',
    '$rootScope', '$q',
    function (cmAuth, cmLoader, cmCrypt, cmUtil,
              $rootScope, $q) {
        return {
            restrict: 'E',
            scope: {
                resetId: '=cmData'
            },
            templateUrl: 'widgets/password/wdgt-password-reset.html',

            controller: function ($scope) {
                var loader = new cmLoader($scope);

                $scope.cmUtil = cmUtil;
                $scope.info = {};
                $scope.formData = {
                    password: ''
                };

                $scope.link = '<a href="#/password/lost">{{\'PASSWORD_RESET.LABEL.LINK_GOTO_PASSWORD_LOST\'|cmTranslate}}</a>';

                cmAuth.checkResetPassword($scope.resetId).then(
                    function(){

                    },
                    function(response){
                        switch(response.data.errorCodes[0]){
                            case 'PASSWORD.RESET.EXPIRED':
                                $scope.info.expired = true;
                            break;
                        }
                    }
                );

                /**
                 * validate cmForm
                 * @returns {*}
                 */
                $scope.validateForm = function () {
                    var deferred = $q.defer(),
                        objectData = {};

                    function checkPassword(){
                        // check password
                        if ($scope.formData.password == ''
                            || $scope.formData.password == 'none'
                            || $scope.formData.password == undefined) {
                            $rootScope.$broadcast('cm-password:empty');
                        } else {
                            objectData.newPassword = $scope.formData.password;
                        }
                    }

                    checkPassword();

                    if ($scope.cmForm.$valid !== false && cmUtil.objLen(objectData) > 0) {
                        deferred.resolve(objectData);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                /**
                 * Form Validation and Apicall to send password reset
                 */
                $scope.resetPassword = function () {
                    if (loader.isIdle())
                        return false;

                    loader.start();
                    $scope.info = {};

                    $scope.validateForm().then(
                        function(objectData) {

                            //$scope.resetId
                            cmAuth.resetPassword(objectData, $scope.resetId).then(
                                function(){
                                    loader.stop();
                                    // everything is fine goTo login
                                    // autologin???
                                    $rootScope.goTo('/login');
                                },
                                function(response){
                                    loader.stop();
                                    switch(response.data.errorCodes[0]) {
                                        case 'PASSWORD.RESET.EXPIRED':
                                            $scope.info.expired = true;
                                        break;
                                    }
                                }
                            )
                        },
                        function() {
                            loader.stop();
                        }
                    );
                };
            }
        }
    }
])
.directive('cmWidgetRegistration', [
    'cmAuth', 'cmUserModel', 'cmUtil', 'cmLogger', 'cmTransferScopeData',
    'cmNotify', 'cmSystemCheck', 'cmLoader', 'cmDevice', 'cmCrypt',
    '$rootScope', '$location', '$q',
    function (cmAuth, cmUserModel, cmUtil, cmLogger, cmTransferScopeData,
              cmNotify, cmSystemCheck, cmLoader, cmDevice, cmCrypt,
              $rootScope, $location, $q) {
        return {
            restrict: 'AE',
            scope: true,
            templateUrl: 'widgets/registration/wdgt-registration.html',

            controller: function ($scope) {
                cmSystemCheck.run(true);

                var loader = new cmLoader($scope);

                $scope.showLoginInfo = false;

                $scope.formValidation = false;

                $scope.toogleLoginInfo = function(){
                    if($scope.showLoginInfo){
                        $scope.showLoginInfo = false;
                    } else {
                        $scope.showLoginInfo = true;
                    }
                };

                $scope.formData = {
                    cameoId: '',
                    password: ''
                };

                $scope.handleGuest = false;

                /**
                 * Toogle Function for AGB Check
                 */
                $scope.acceptTerms = function () {
                    $scope.formData.agb = !$scope.formData.agb ? true : false;
                };

                /**
                 * validate Registration Form
                 * @returns {*}
                 */
                $scope.validateForm = function () {
                    var deferred = $q.defer(),
                        valid = true,
                        reservationCheck = false;

                    $scope.formValidation = true;

                    var data = {
                        loginName: null,
                        password: null,
                        reservationSecret: null
                    };

                    // check loginName aka cameoId
                    if ($scope.registrationForm.cameoId.$valid == false) {
                        if ($scope.registrationForm.cameoId.$viewValue == undefined
                            || $scope.registrationForm.cameoId.$viewValue.toString() == ''
                        ) {
                            valid = false;
                            $rootScope.$broadcast('cm-login-name:invalid');
                        }
                    } else {
                        data.loginName = $scope.registrationForm.cameoId.$viewValue;
                    }

                    // check password
                    if ($scope.formData.password == ''
                        || $scope.formData.password == 'none'
                        || $scope.formData.password == undefined) {
                        $rootScope.$broadcast('cm-password:empty');
                        valid = false;
                    } else {
                        data.password = $scope.formData.password;
                    }

                    // check agb
                    if ($scope.registrationForm.agb.$valid == false) {
                        $scope.registrationForm.agb.$invalid = true;
                    }

                    // check reservation secret - index for correct login name
                    if (data.loginName != null && cmUtil.objLen($scope.reservationSecrets) > 0) {
                        if (!(data.loginName in $scope.reservationSecrets)) {
                            cmNotify.warn('REGISTRATION.WARN.RESERVATIONSECRET_MISSING');
                            valid = false;
                        } else {
                            data.reservationSecret = $scope.reservationSecrets[data.loginName];
                            reservationCheck = true;
                        }
                    }

                    if ($scope.registrationForm.$valid !== false && reservationCheck == true) {
                        deferred.resolve(data);
                    } else {
                        deferred.reject();
                    }

                    return deferred.promise;
                };

                /**
                 * Form Validation and Apicall to create user
                 */
                $scope.createUser = function () {
                    if (loader.isIdle())
                        return false;

                    loader.start();

                    function sendCreateUserRequest(data) {
                        cmAuth.createUser(data).then(
                            function (accountData) {

                                cmUserModel.doLogin($scope.formData.cameoId, $scope.formData.password, accountData).then(
                                    function() {
                                        if(cmDevice.isDesktop('cmWidgetRegistration') || cmDevice.isApp())
                                            $rootScope.goTo("/setup/account");
                                        else
                                            $rootScope.goTo("/start/download");
                                    },
                                    function() {
                                        loader.stop();
                                    }
                                );
                                return true;
                            },
                            function (response) {
                                loader.stop();

                                if (typeof response == 'object' && 'data' in response && typeof response.data == 'object') {
                                    if (typeof response.data.error != 'undefined' && response.data.error == 'invalid reservation secret') {
                                        $rootScope.$broadcast('registration:checkAccountName');
                                    }
                                } else {
                                    cmNotify.warn('REGISTER.WARN.REGISTRATION_FAILED');
                                }
                            }
                        );
                    }

                    $scope.validateForm().then(
                        function (data) {
                            clearTransferScopeData();

                            sendCreateUserRequest(data);
                        },
                        function () {
                            loader.stop();
                            cmUtil.scrollToInputError();
                        }
                    );
                };

                var killWatcher = $rootScope.$on('registration:createUser', function () {
                    $scope.createUser();
                });

                /**
                 * Guest Handling
                 */
                if (cmUserModel.isGuest() !== false) {
                    $scope.handleGuest = true;
                }

                // transfer data between routeChanges
                var clearTransferScopeData = cmTransferScopeData.create($scope, {
                    id: 'registration',
                    ignoreVar: 'password',
                    scopeVar: 'formData',
                    onSet: function () {
                        this.noneScopeData = $scope.reservationSecrets;
                    },
                    onGet: function (formData, noneScopeData) {
                        if (noneScopeData != null)
                            $scope.reservationSecrets = noneScopeData
                    }
                });

                $scope.$on('$destroy', function(){
                    killWatcher();
                });
            }
        }
    }
])
.directive('cmWidgetAuthentication', [

    'cmUserModel',
    'cmAuthenticationRequest',
    'cmReKeying',
    'cmCallbackQueue',
    'cmIdentityFactory',
    'cmContactsModel',
    '$timeout',
    '$rootScope',
    '$q',

    function(cmUserModel, cmAuthenticationRequest, cmReKeying, cmCallbackQueue, cmIdentityFactory, cmContactsModel, $timeout, $rootScope, $q){
        return {
            restrict: 'E',
            templateUrl: 'widgets/security/wdgt-authentication.html',
            scope: {
                keyId:      '=',
                identityId: '='
            },

            controller: function ($scope, $element, $attrs) {

                var timeoutInterval,
                    timeoutPromise

                $scope.step         =   0
                $scope.waiting      =   false
                $scope.toIdentity   =   $scope.identityId 
                                        ?   cmIdentityFactory.find($scope.identityId)
                                        :   cmUserModel.data.identity

                //Without a key authetication won't work: 
                if(!cmUserModel.loadLocalKeys().length){
                    $rootScope.goTo('/settings/identity/keys', true)
                }

                //Without cameo id authentication won't work:
                if(!$scope.toIdentity.cameoId){
                    $rootScope.goTo('/settings/identity/keys', true)                  
                }


                $scope.BASE =   ($scope.toIdentity == cmUserModel.data.identity)
                                ?   'IDENTITY.KEYS.AUTHENTICATION.'
                                :   'IDENTITY.KEYS.TRUST.'


                $scope.getTimeout = function(){
                    return cmAuthenticationRequest.getTTL()
                }
               
                $scope.startAuthenticationRequest = function(){
                    $scope.ERROR    = undefined
                    $scope.waiting  = true;

                    cmAuthenticationRequest.generateTransactionSecret(120000)
                    $scope.transactionSecret = cmAuthenticationRequest.getTransactionSecret()
                    $scope.step = 1

                    cmCallbackQueue
                    .push(function(){
                        return cmAuthenticationRequest.send(
                            $scope.toIdentity.id,                           //The identity we ask to trust our key
                            cmAuthenticationRequest.getTransactionSecret(), //The secret will share through another channel with the person we believe is the owner of the above identity
                            $scope.keyId                                    //The key that should sign our own key; may be undefined
                        )
                    }, 100)
                    .then(function(){
                        //wait for response:
                        return  cmAuthenticationRequest.getTTL()
                             ?  cmAuthenticationRequest.when('started', 'canceled', cmAuthenticationRequest.getTTL())      
                             :  $q.reject()
                    })
                    .then(
                        function(result){
                            $scope.step = 2
                            //wait for key in response to be verified:
                            return cmAuthenticationRequest.when('verification:successful', 'verification:failed', 7000)  
                        },
                        function(result){
                            return  result == 'timeout'
                                    ?   $q.reject('TIMEOUT')
                                    :   $q.reject()
                        }
                    )
                    .then(
                        function(result){
                            var data = result.data

                            return  cmUserModel.signPublicKey(data.key, data.key.id, data.identity)      //wait for key in response to be signed
                                    //Todo: this 'then' should be elsewhere:
                                    .then(function(){    
                                        if(data.identity == cmUserModel.data.identity)      
                                        /*                              
                                        cmAuthenticationRequest.openBulkRequest({
                                            key1: cmUserModel.loadLocalKeys()[0].id,   // Todo: how to treat multiple local keys?
                                            key2: data.key.id
                                        })
                                        */

                                        cmReKeying.process(cmUserModel.loadLocalKeys()[0].id)
                                    })
                        },
                        function(result){
                            return  result && result.event &&  result.event.name == 'verification:failed'
                                    ?   $q.reject('VERIFY')
                                    :   $q.reject(result)
                        }
                    )
                    .then(
                        function(){
                            $scope.cancel()
                            $scope.step     = 3
                            $scope.waiting  = false
                        },
                        function(error){
                            if(error){
                                $scope.ERROR = error                                
                            }
                            $scope.cancel()
                        }
                    )

                }

                $scope.cancel = function(){
                    $scope.waiting  = false
                    $scope.step     = 0
                    cmAuthenticationRequest.cancel($scope.toIdentity.id)
                };

                $scope.done = function(){
                    $scope.cancel()
                    
                    if($scope.keyId){
                        $rootScope.goTo('settings/identity/key/list', true);
                        return null;
                    }

                    if($scope.identityId){
                        $rootScope.goTo('contact/edit/'+cmContactsModel.findByIdentityId($scope.identityId).id, true);
                        return null
                    }

                    $rootScope.goTo('settings/identity/key/list', true);
                    return null;
                }


                $scope.$on('$destroy', $scope.cancel)

            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityKeyCreate
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */
.directive('cmWidgetIdentityKeyCreate', [
    // no dependencies
    function(){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'widgets/settings/identity/key/wdgt-identity-key-create.html',
            controller: function(){
                //console.log('cmWidgetIdentityKeyCreate')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityKeyEdit
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */
.directive('cmWidgetIdentityKeyEdit', [
    // no dependencies
    function(){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'widgets/settings/identity/key/wdgt-identity-key-edit.html',
            controller: function(){
                //console.log('cmWidgetIdentityKeyEdit')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityKeyImport
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */
.directive('cmWidgetIdentityKeyImport', [
    // no dependencies
    function(){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'widgets/settings/identity/key/wdgt-identity-key-import.html',
            controller: function(){
                //console.log('cmWidgetIdentityKeyImport')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityKeyList
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */
.directive('cmWidgetIdentityKeyList', [
    'cmUserModel',
    function(cmUserModel){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'widgets/settings/identity/key/wdgt-identity-key-list.html',
            controller: function($scope){
                //console.log('cmWidgetIdentityKeyList')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityCreate
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */
.directive('cmWidgetIdentityCreate', [
    // no dependencies
    function(){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'widgets/settings/identity/wdgt-identity-create.html',
            controller: function(){
                //console.log('cmWidgetIdentityCreate')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityEdit
 * @description
 * List conversations.
 *
 * @restrict E
 * @example
 */
.directive('cmWidgetIdentityEdit', [
    // no dependencies
    function(){
        return {
            restrict:       'E',
            scope:          true,
            templateUrl:    'widgets/settings/identity/wdgt-identity-edit.html',
            controller: function(){
                //console.log('cmWidgetIdentityEdit')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetIdentityList
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */
.directive('cmWidgetIdentityList', [
    'cmUserModel',
    function(cmUserModel){
        return {
            restrict:       'AE',
            scope:          true,
            templateUrl:    'widgets/settings/identity/wdgt-identity-list.html',
            controller: function($scope){
                $scope.identities = cmUserModel.data.identities;
            }
        }
    }
])
.directive('cmWidgetSettingsAboutUs', [
    'cmConfig',
    function(cmConfig){
        return {
            restrict: 'E',
            templateUrl: 'widgets/settings/wdgt-settings-about-us.html',
            controller: function ($scope) {
                $scope.version = cmConfig.version;
                $scope.thirdPartyLibraries = cmConfig.static.thirdPartyLibraries;
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetSettingsAccount
 * @description
 * account settings
 *
 * @restrict E
 * @example
 */
.directive('cmWidgetSettingsAccount', [
    // no dependencies
    function(){
        return {
            restrict:       'E',
            scope:          true,
            templateUrl:    'widgets/settings/wdgt-settings-account.html',
            controller: function(){
                //console.log('cmWidgetSettingsAccount')
            }
        }
    }
])
.directive('cmWidgetSettingsApp', [
    'cmSettings',
    function(cmSettings){
        return {
            restrict: 'E',
            templateUrl: 'widgets/settings/wdgt-settings-app.html',
            controller: function ($scope) {
                $scope.settings = cmSettings.properties;

                cmSettings.on('update:finished',function(){
                    $scope.settings = cmSettings.properties;
                });

                $scope.handleBooleans = function(key) {
                    var newValue = $scope.settings[key] ? false : true;

                    if(cmSettings.set(key, newValue))
                        $scope.settings[key] = newValue;
                };
            }
        }
    }
])
.directive('cmWidgetSettingsList', [
    'cmUserModel', 'cmConfig', 'cmUtil',
    '$window', '$location',
    function(cmUserModel, cmConfig, cmUtil,
             $window, $location){
        return {
            restrict: 'E',
            templateUrl: 'widgets/settings/wdgt-settings-list.html',
            controller: function ($scope) {
                $scope.overview = cmConfig.routeSettings;
                $scope.overviewKeys = Object.keys($scope.overview);

                $scope.logout = function(){
                    cmUserModel.doLogout(true,'settings overview logout');
                };

                $scope.goToSettingsPage = function($event, pageUrl, isDisabled, route){

                    if('link' in route){
                        // file:///android_asset/www/index.html#/login
                        if(cmUtil.startsWith($location.$$absUrl, 'file:///')) {
                            $window.location = route.link;
                        // http://localhost:8000/app/#/settings
                        } else if($location.$$absUrl.indexOf('/#/') != -1) {
                            var arr_location = $location.$$absUrl.split('/#/');
                            location.href = arr_location[0] + '/' + route.link;
                        }

                        return false;
                    }

                    if(typeof pageUrl !== 'undefined' && isDisabled == undefined){
                        $event.stopPropagation();
                        $event.preventDefault();
                        $scope.goTo('/settings/'+pageUrl);
                    }
                };

                $scope.checkActive = function(page){
                    if($location.$$url.indexOf('identity') != -1 && page.indexOf('identity') != -1){
                        if(page.indexOf('key') != -1 && $location.$$url.indexOf('key') != -1){
                            return true;
                        } else if(page.indexOf('key') == -1 && $location.$$url.indexOf('key') == -1){
                            return true;
                        }

                    } else if($location.$$url.indexOf(page) != -1){
                        return true;
                    }

                    return false;
                };

            }
        }
    }
])

.directive('cmWidgetSettingsNotify', [
    'cmSettings', 'cmPushNotificationAdapter', 'cmBrowserNotifications', 'cmDevice',
    function(cmSettings, cmPushNotificationAdapter, cmBrowserNotifications, cmDevice){
        return {
            restrict: 'E',
            templateUrl: 'widgets/settings/wdgt-settings-notify.html',
            controller: function ($scope) {
                $scope.settings = cmSettings.properties;

                cmSettings.on('update:finished',function(){
                    $scope.settings = cmSettings.properties;
                });

                $scope.isApp = function(){
                    return cmDevice.isApp();
                };

                $scope.changePushNotifications = false;
                $scope.changeBrowserNotifications = false;

                $scope.handlePushNotifications = function() {
                    var key = 'pushNotifications';

                    if(!$scope.isApp() || $scope.changePushNotifications)
                        return false;

                    $scope.changePushNotifications = true;

                    var newValue = $scope.settings[key] ? false : true;

                    if(!newValue){//unregister checked to unchecked
                        cmPushNotificationAdapter.deleteDevice();
                        cmPushNotificationAdapter.one('device:unregistrated',function(){
                            $scope.changePushNotifications = false;
                        });
                    } else {
                        cmPushNotificationAdapter.registerDevice();
                        cmPushNotificationAdapter.one('device:registrated',function(){
                            $scope.changePushNotifications = false;
                        });
                    }

                    if(cmSettings.set(key, newValue)){
                        $scope.settings[key] = newValue;
                    }
                };

                $scope.enabledBrowserNotification = cmBrowserNotifications.checkBrowser();

                $scope.handleBrowserNotifications = function() {
                    var key = 'browserNotifications';

                    if($scope.isApp() || $scope.changeBrowserNotifications || !cmBrowserNotifications.checkBrowser())
                        return false;

                    $scope.changeBrowserNotifications = true;

                    var newValue = $scope.settings[key] ? false : true;

                    if(!newValue){
                        $scope.changeBrowserNotifications = false;
                    } else {
                        cmBrowserNotifications.askPermission();
                        $scope.changeBrowserNotifications = false;
                    }

                    if(cmSettings.set(key, newValue)){
                        $scope.settings[key] = newValue;
                    }
                };

                $scope.sendNotification = function(){
                    cmBrowserNotifications.show($scope.notificationTitle);
                }
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetSettingsAccount
 * @description
 * account setup
 *
 * @restrict E
 * @example
 */
.directive('cmWidgetSetupAccount', [
    // no dependencies
    function(){
        return {
            restrict:       'E',
            scope:          true,
            templateUrl:    'widgets/setup/wdgt-setup-account.html',
            controller: function(){
                //console.log('cmWidgetSetupAccount')
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetSettingsIdentity
 * @description
 * identity setup
 *
 * @restrict E
 * @example
 */
.directive('cmWidgetSetupIdentity', [
    // no dependencies
    function(){
        return {
            restrict:       'E',
            scope:          true,
            templateUrl:    'widgets/setup/wdgt-setup-identity.html',
            controller: function(){
                //console.log('cmWidgetSetupAccount')
            }
        }
    }
])
.directive('cmWidgetSetupKeyinfo', [
    'cmUserModel',
    'cmUtil',
    'cmSettings',
    '$rootScope',
    function(cmUserModel, cmUtil, cmSettings, $rootScope){
        return {
            restrict: 'E',
            templateUrl: 'widgets/setup/wdgt-setup-keyinfo.html',
            controller: function ($scope) {

                if(cmUserModel.hasPrivateKey()){
                    $scope.goTo('/settings/identity/key/list');
                    return false;
                }

                $scope.skipKeyInfo = false;
                $scope.skipKeyInfo = cmSettings.get('skipKeyInfo') || false;

                if(cmUserModel.loadLocalKeys().length > 0){
                    $scope.skipKeyInfo = true;
                }

                $scope.toggleSkipKeyInfo = function(){
                    if(!$scope.skipKeyInfo){
                        cmSettings.set('skipKeyInfo', true);
                        $scope.skipKeyInfo = true;
                    } else {
                        cmSettings.set('skipKeyInfo', true);
                        $scope.skipKeyInfo = false;
                    }
                };

                $scope.showKeySize = false;
                $scope.toggleKeySize = function(){
                    //console.log('toggleKeySize', $scope.showKeySize)
                    if(!$scope.showKeySize){
                        $scope.showKeySize = true;
                    } else {
                        $scope.showKeySize = false;
                    }
                };

                $scope.keySize = 2048;
                $scope.chooseKeySize = function(size){
                    if(size == '4096'){
                        $scope.keySize = 4096;
                    } else {
                        $scope.keySize = 2048;
                    }
                };

                $scope.generateKey = function(){
                    $rootScope.generateAutomatic = {
                        generate:true,
                        keySize: $scope.keySize
                    };

                    $scope.goTo('/settings/identity/key/create');
                }
            }
        }
    }
])
.service('cmWidget',[
    function(){
        this.setup = function(scope, element, attrs){
            element.addClass('widget')
        }
    }
])
.directive('cmWidgetDownload',
    function(cmConfig, cmDevice, cmUserModel,
             $rootScope,$filter){
        return {
            restrict: 'E',
            templateUrl: 'widgets/start/wdgt-download.html',
            controller: function ($scope) {
                $scope.appLinks = $filter('appStoreLink')(cmConfig.static.appLinks);

                $scope.goToWelcome = function(){
                    $scope.goTo('/start/welcome');
                };

                $scope.goToSetup = function(){
                    $scope.goTo('/setup/account');
                };


                // isDesktop or App or none apps are available for device
                if(cmDevice.isDesktop('cmWidgetDownload') || cmDevice.isApp() || $scope.appLinks.length == 0){
                    //$scope.goToWelcome();
                }

                function callbackAccountUpdate(){
                    if(typeof cmUserModel.data.account.registrationIncomplete != 'undefined' && cmUserModel.data.account.registrationIncomplete == false){
                        $rootScope.goTo('/setup/keyinfo');
                    }
                }

                cmUserModel.on('account:updated', callbackAccountUpdate);

                $scope.$on('$destroy', function(){
                    cmUserModel.off('account:update', callbackAccountUpdate);
                });
            }
        }
    }
)
.directive('cmWidgetQuickstart', [
    function(){
        return {
            restrict: 'E',
            scope: {
                startRoute: '=cmStartRoute'
            },
            templateUrl: 'widgets/start/wdgt-quickstart.html',
            controller: function ($scope) {
                
            }
        }
    }
])
.directive('cmWidgetWelcome', [
    '$rootScope',
    function($rootScope){
        return {
            restrict: 'E',
            templateUrl: 'widgets/start/wdgt-welcome.html',
            controller: function ($scope) {
                $scope.generateKey = function(){
                    $rootScope.generateAutomatic = {
                        generate:true,
                        keySize: 2048
                    };

                    $rootScope.goTo('/settings/identity/key/create');
                }
            }
        }
    }
])
.directive('cmWidgetSystemcheck',[
    'cmSystemCheck', 'cmVersion', 'cmDevice', 'cmConfig',
    '$filter',
    function(cmSystemCheck, cmVersion, cmDevice, cmConfig,
             $filter){

        return {
            restrict: 'E',
            templateUrl: 'widgets/systemcheck/wdgt-systemcheck.html',
            controller: function ($scope) {

                $scope.version = cmVersion.version;
                $scope.isApp = cmDevice.isApp();
                $scope.appLinks = $filter('appStoreLink')(cmConfig.static.appLinks);

                $scope.localStorage = cmSystemCheck.checkLocalStorage();

                cmSystemCheck.checkClientVersion(false).then(
                    function(){
                        $scope.isClientUpToDate = true;
                    },
                    function(){
                        $scope.isClientUpToDate = false;
                    }
                );
            }
        }
    }
])
/**
 * @ngdoc directive
 * @name cmWidgets.directive:cmWidgetConversationOverview
 * @description
 * List conversations.
 *
 * @restrict AE
 * @example
 */



.directive('cmWidgetTalks', [
    'cmUserModel', 'cmConversationFactory',
    function(cmUserModel, cmConversationFactory){
        return {
            restrict:       'AE',
            scope:          true,   
            templateUrl:    'widgets/talks/wdgt-talks.html',
            controller: function($scope){
                /**
                 * init conversations to scope
                 */
                $scope.conversations = cmConversationFactory;
                if($scope.conversations.length == 0){
                    $scope.conversations.getList();
                }

                /**
                 * load more Conversations
                 */
                $scope.loadMoreTalks = function(){
                    if(cmUserModel.isAuth() != false){
                        $scope.conversations.getList($scope.conversations.getLimit(), $scope.conversations.length);
                    }
                };

                /**
                 * Show More Button
                 * @returns {boolean}
                 */
                $scope.moreTalksAvailable = function(){
                    if($scope.conversations.length == 0){
                        return false;
                    }

                    if($scope.conversations.length == $scope.conversations.getQuantity()){
                        return false;
                    }

                    return true;
                };
            }
        }
    }
])