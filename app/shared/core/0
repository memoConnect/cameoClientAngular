'use strict';

angular.module('cmCore',[])
.provider('cmApi',[
function($injector){
    var rest_api    = "",
        stack_path   = ""

    this.restApiUrl = function(url){
        rest_api = url;
        return this
    }

    this.stackPath = function(path){
        stack_path = path
    }

    this.$get = [

    'cmLogger',
    '$http',
    '$injector',
    '$q',

    function(cmLogger, $http, $injector, $q){
        /***
        All api calls require a config object:

        ie.: api.get(config)

        config works almost like in $http(config)

        most important keys are:
            path:	api path to call i.e. '/account/check',
                    will give an error message if passed something different from a path (like 'http://dev.cameo.io/...')
                    in that case your call will most likely fail brutally

            data:	data to send, any plain object

            exp_ko: key you expect in response body if your request was granted(see below)
            exp_ok: key you expect in response body if your request was denied (see below)


        Authentication and error handling is dealt with automatically.


        example: (!!check tests in cmApi.spec.js!!)

        cmApi.get({
            path:     '/pony',
            exp_ok:  'pony',
        })


        ---> response:  {
                            "res" : 'OK',
                            "data": {
                                        "pony" : "my_new_pony"
                                    }
                        }

        .then(
            function(pony){         <--- gets called because response.res == 'OK', pony will equal 'my_pony'
                yay(pony)
            },

            function(alternative, res){
                alternative
                ? meh(alternative)
                : error(alternative) //yet error should have already been handled alesewhere
            }
        )


        ---> response:  {
                            "res" : 'OK',
                            "data": {
                                        "dog" : "my_new_dog"
                                    }
                        }

        .then(
            function(pony){
                yay(pony)
            },
            function(alternative,res){	<--- gets called because response is invalid, "pony" was expected, yet "dog" was delivered
                                             alternative will be undefined
                                             res however holds all the response
                alternative
                ? meh(alternative)
                : error(alternative) //yet error should have been handled already elesewhere
            }
        )




        ---> response:	{
                            "res" : 'KO',
                            "data": {
                                        "alternative" : "kitty"
                                    }
                        }

        .then(
            function(pony){
                yay(pony)
            },
            function(data, res){ <--- gets called because response.res == 'KO', data will be {'alternative': 'kitty'},
                                      because there was no specific key expected for KO.
                                      res however holds all the response
                alternative
                ? meh(alternative)
                : error(alternative) //yet error should have been handled already elesewhere
            }
        )




        ---> response:	{
                            "res" : 'XXX',
                            "data": {
                                        "kitty" : "grumpy cat"
                                    }
                        }

        .then(
            function(pony){
                yay(pony)
            },
            function(alternative,res){ <--- gets called because response is invalid for neither response.res == 'OK' nor response.res == 'KO',
                                            alternative will be undefined
                                            res however holds all the response
                alternative
                ? meh(alternative)
                : error(alternative) //yet error should have been handled already elesewhere
            }
        )



        */
       
        //check if the sever's response matches the api conventions
        function responseValid(response, exp_ok, exp_ko){
            var valid =    response
                            //response must have a res key that equals 'OK' or 'KO':
                        && (response.res == 'OK' || response.res == 'KO')
                            //if your request was granted and something was expected in return, it must be present:
                        && (response.res == "OK" && exp_ok ? exp_ok in response.data : true)
                            //if your request was denied and something was expected in return, it must be present:
                        && (response.res == "KO" && exp_ko ? exp_ko in response.data : true)

            if(!valid) cmLogger.error('Api response invalid; '+(exp_ok||exp_ko ? 'expected: ':'') + (exp_ok||'') +', '+(exp_ko||''), response)

            return(valid)
        }
       
       function handleSuccess(response, config, deferred){
            //$http call was successfull:
            //reponse includes config and data, we only need the data:
            var response = response.data

            responseValid(response, config.exp_ok, config.exp_ko)
            ?   //response valid, check if OK:
                //if a certain key was expected, resolve promise resp. reject the promise with the according values
                //if nothing was expected, just resolve or reject with value of 'data' in the response body if present or all the data
                //reponse should now look similar to this:
                /*
                    "res":  "OK",
                    "data": {
                                "some_key":             "some_value",
                                "some expected_key":    "some_other value"
                            }

                */
                response.res =='OK'
                ? deferred.resolve( config.exp_ok ? response.data[config.exp_ok] : response.data || response)
                : deferred.reject(  config.exp_ko ? response.data[config.exp_ko] : response.data || response)
            :   //response invalid, call through:
                deferred.reject(undefined, response)
        }
    

       function handleError(response, config, deferred){                                            
//                    cmLogger.error('Api call failed: \n '+config.method+' '+config.path, response)
//                    window.location.href='#/server_down' //@ Todo
                    //error messages should come trough backend
                    deferred.reject(response)
       }



        var api = function(method, config){

            config = config ? config : method

            if(config.url){
                cmLogger.warn('cmApi: "url" in config object is deprecated.')
            }

            var deferred	=	$q.defer(),

                //get authentification token from cmAuth if present
                token 		= 	$injector.has('cmAuth')
                                ?	$injector.get('cmAuth').getToken()
                                :	undefined,

                //get twoFactorAuth token from cmAuth if present
                twoFactorToken	= 	$injector.has('cmAuth')
                                ?	$injector.get('cmAuth').getTwoFactorToken()
                                :	undefined


            //extend or overwrite config
            config			=	config || {}	// make sure config is defined
            config.method	= 	method			// overwrite method
            config.url		= 	rest_api +		// base url API
                                config.path 	// path to specific method
            config.headers	=	angular.extend(token ? {'Authorization': token} : {}, config.headers || {})	//add authorization token to the header
            config.headers	=	angular.extend(twoFactorToken ? {'X-TwoFactorToken': twoFactorToken} : {}, config.headers || {})	//add two factor authorization token to the header


            $http(config).then(
                function(response){ handleSuccess(response, config, deferred) },
                function(response){ handleError(response, config, deferred) }
            )

            return deferred.promise
        }

        api.get				=	function(config){ return api('GET',		config) }
        api.post			=	function(config){ return api('POST',	config) }
        api.delete			=	function(config){ return api('DELETE',	config) }
        api.head			=	function(config){ return api('HEAD', 	config) }
        api.put				=	function(config){ return api('PUT', 	config) }
        api.jsonp			=	function(config){ return api('JSONP',	config) }

        api.stack = function(method, config){
            var deferred = $q.defer()

            api.call_stack = api.call_stack || []

            api.call_stack.push({
                deferred : deferred,
                config   : config
            })

            return deferred.promise
        }

        api.commit = function(){

            api.call_stack.forEach(function(){

            })

            api.post({
                path: '/callstack',
                data: {
                    requests: [] 
                } 
            })
        }

        return api
        }]
    }
])
.provider('cmLogger', [
    '$logProvider',
    function($logProvider){
        var debug_enabled = true;

        this.debugEnabled = function(flag){
            $logProvider.debugEnabled(flag);
            debug_enabled = flag;
        };

        this.$get = [
            '$log',
            function($log){
            /**
            * Format date as a string
            */
            function getTimestampAsString() {
                var d = (new Date()+'').split(' ');
                return [d[3], d[1], d[2], d[4]].join(' ');
            }

            function prefix(type, msg) {
                return getTimestampAsString() + " [cmLogger-"+type.toUpperCase()+"]> "  + msg;
            }

            function log_object(obj) {
                console.groupCollapsed(obj);
                console.dir(obj);
                console.groupEnd();
            }

            return {
                universal: function(type, loggerMessage, object) {
                    $log[type](prefix(type, loggerMessage))
                    if(object) log_object(object)
                },

                 /**
                 * simple info log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                info: function(loggerMessage, object){ this.universal('info', loggerMessage, object) },
                /**
                 * simple warn log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                warn: function(loggerMessage, object){ this.universal('warn', loggerMessage, object) },
                /**
                 * simple error log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                error: function(loggerMessage, object){ this.universal('error', loggerMessage, object) },
                /**
                 * simple debug log wrapper
                 * @param loggerMessage String that should logged
                 * @object any object that will be logged using toString()
                 */
                debug: function(loggerMessage, object){
                    if(!debug_enabled) return(undefined)
                    this.universal('debug', loggerMessage, object)
                }
            }
        }];
    }
])
.service('cmAuth', [
    'cmApi',
    function(cmApi){
        return {

            // ask the api for a new authentication token:
            requestToken: function(login, pass){
                var auth = _Base64.encode(login + ":" + pass);

                return cmApi.get({
                    path: '/token',
                    headers: { 'Authorization': 'Basic '+auth } ,
                    exp_ok: 'token'
                })
            },

            // delete Token
            removeToken: function(){
                return localStorage.removeItem('token');
            },

            // store the token in a cookie:
            storeToken: function(token){
                return localStorage.setItem('token', token);
            },

            // retrieve thr token from a cookie
            getToken: function(){
                return localStorage.getItem('token');
            },

            createUser: function(data){
                return cmApi.post({
                    path: '/account',
                    data: data
                })
            },

            checkAccountName: function(name, reservationSecret){
                return cmApi.post({
                    path: '/account/check',
                    data: {
                        loginName: name,
                        reservationSecret: reservationSecret
                    }
    //                exp_ok: 'reservationSecret',
    //                exp_ko: 'alternative'
                })
            },

            checkPhoneNumber: function(number){
                return cmApi.post({
                    path: '/services/checkPhoneNumber',
                    data: { phoneNumber:number },
                    exp_ok: 'phoneNumber'
                })
            },

            getIdentity: function(id){
                return cmApi.get({
                    path: '/identity'+ (id ? '/'+id : '')
                })
            },

            savePublicKey: function(data){
                return cmApi.post({
                    path: '/identity/publicKey',
                    data: {
                        name: data.name,
                        key: data.key,
                        keySize: parseInt(data.keySize)
                    }
                })
            },

            // two factor authentication
            requestTwoFactorKey: function() {
                return cmApi.get({
                    path: '/twoFactorAuth'
                })
            },

            // ask the api for a new authentication token:
            requestTwoFactorToken: function(key){
                return cmApi.post({
                    path: '/twoFactorAuth/confirm',
                    data: { key: key },
                    exp_ok: "token"
                })
            },

            // delete Token
            removeTwoFactorToken: function(){
                return localStorage.removeItem('twoFactorToken');
            },

            // store the token in a cookie:
            storeTwoFactorToken: function(twoFactorToken){
                return localStorage.setItem('twoFactorToken', twoFactorToken);
            },

            // retrieve thr token from a cookie
            getTwoFactorToken: function(){
                return localStorage.getItem('twoFactorToken');
            }

        }
    }]
)
.service('cmCrypt',[
    'cmLogger',
    '$q',
    '$rootScope',
    function (cmLogger, $q, $rootScope) {
        // private vars
        var async = {
            interval: null,
            promise: null,
            crypt: null
        };

        return {
            /**
             * this method calculates a secure hash
             * @param secretString String that should be hashed
             */
            hash: function (secretString) {
                if (null == secretString)
                    return "";

                return sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(secretString))
            },

            /**
             * this method encrypts strings
             * @param secretKey a secret key with max len of 10 chars
             * @param secretString a string that should be enrypted
             * @returns base64 encoded encrypted string
             */
            encryptWithShortKey: function (secretKey, secretString, withoutBase64) {
                var parameters = { cipher: "aes", ks: 256, iter: 4096 };

//                if(secretKey == ''){
//                    return withoutBase64 ? secretString : _Base64.encode(secretString);
//                }

                if (null == secretString)
                    return "";
                if (secretKey.length > 10)
                    return "";

                var encryptedSecretString = sjcl.json.encrypt(String(secretKey), String(secretString), parameters);

                return withoutBase64 ? encryptedSecretString : _Base64.encode(encryptedSecretString);
            },
            /**
             * this method encrypts strings
             * @param secretKey a secret key with min len of 60 chars
             * @param secretString a string that should be encrypted
             * @returns base64 encoded encrypted string
             */
            encrypt: function (secretKey, secretString, withoutBase64) {
                var parameters = {cipher: "aes", ks: 256, iter: 500 };

//                if(secretKey == ''){
//                    return withoutBase64 ? secretString : _Base64.encode(secretString);
//                }

                if (null == secretString)
                    return "";

                if (secretKey.length < 60)
                    return "";

                var encryptedSecretString = sjcl.json.encrypt(String(secretKey), String(secretString), parameters);

                return withoutBase64 ? encryptedSecretString : _Base64.encode(encryptedSecretString);
            },
            /**
             * this method decrypts uuencoded strings
             * @param secretKey a secret key
             * @param secretString a base64 encoded string that should be decrypted
             * @returns decrypted string
             */
            decrypt: function (secretKey, secretString, withoutBase64) {
//                if(secretKey == ''){
//                    return withoutBase64 ? secretString : _Base64.decode(secretString);
//                }

                if (null == secretString)
                    return false;

                var decodedSecretString = withoutBase64 ? secretString : _Base64.decode(secretString),
                    decryptedString;

                try {
                    decryptedString = sjcl.decrypt(secretKey, decodedSecretString)
                } catch (e) {
                    //cmLogger.warn('Unable to decrypt.', e)
                }

                return decryptedString || false
            },


            Key : function (data){
                //Wrapper for RSA Keys
                var self = this,
                    crypt

                if(typeof data == "object" && "updateKeyList" in data) return data //data is already a Key object
                    
                if(        
                       typeof data == "object"               
                    && "getPublicKey"   in data
                    && "getPrivateKey"  in data
                    && "encrypt"        in data
                    && "decrypt"        in data
                ){                    
                    crypt = data    //data is already a JSEncrypt object
                }else{                
                    crypt = new JSEncrypt()
                    crypt.setKey(data)
                }

                this.setId = function(id){
                    this.id = id
                    return this
                }

                this.setName = function(name){
                    this.name = name
                    return this
                }

                //set either public or private key
                this.setKey = function(key){
                    crypt.setKey(key)
                    return this
                }

                this.getPublicKey = function(){
                    var public_key
                    try{
                        public_key = crypt.getPublicKey()
                    }catch(e){}

                    return public_key
                }

                this.getPrivateKey = function(){
                    var private_key
                    try{
                        private_key = crypt.getPrivateKey()
                    }catch(e){}

                    return private_key
                }

                this.encrypt = function(secret){
                    return crypt.encrypt(secret)
                }

                this.decrypt = function(encrypted_secret){
                    return crypt.decrypt(encrypted_secret)
                }

                this.getSize = function(){
                    var size

                    try{
                        size = crypt.key.n.bitLength()
                    }catch(e){}

                    return size
                }

                this.exportData = function(){
                    var data        = {},
                        private_key = this.getPrivateKey(),
                        public_key  = this.getPublicKey(),
                        size        = this.getSize()

                    if(this.id)     data.id         = this.id
                    if(this.name)   data.name       = this.name
                    if(public_key)  data.pubKey     = public_key    
                    if(private_key) data.privKey    = private_key
                    if(size)        data.size       = size

                    return data
                }

                this.importData = function(data){
                    var public_key = this.getPublicKey()

                    data.pubKey = data.pubKey   ? data.pubKey.replace(/\n/g,'') : undefined
                    public_key  = public_key    ? public_key.replace(/\n/g,'')  : undefined
                    

                    if(data.name)   this.setName(data.name)
                    if(data.id)     this.setId(data.id)

                    if( data.pubKey && (data.pubKey != public_key) ){
                        this.setKey(data.pubKey)
                    }

                    if( data.key && (data.key != public_key) ){                      
                        this.setKey(data.key)
                    }

                    if(data.privKey) this.setKey(data.privKey)

                    return this
                }

                this.updateKeyList = function(key_list){
                    var check = false

                    key_list.forEach(function(key){
                        if(
                               (key.id && (key.id == self.id)) 
                            || key.getPublicKey() == self.getPublicKey()
                        ){ 
                            angular.extend(key, self)
                            check = true
                        }
                    })

                    if(!check) key_list.push(self)
                }

                this.updateKeyDataList = function(key_data_list){
                    var check = false

                    key_data_list.forEach(function(key_data){                        
                        if(
                               (key_data.id && (key_data.id == self.id)) 
                            || key_data.pubKey == self.getPublicKey()
                        ){
                            angular.extend(key_data, self.exportData())
                            check = true
                        }                        
                    })



                    if(!check) key_data_list.push(this.exportData())
                }
            },

            /**
             * return the bit size of possible keygeneration
             * @returns {string[]}
             */
            getKeySizes: function(){
                return ['512','1024','2048','4096'];
            },

            /**
             * start async process
             * @param keylen
             * @param $scopeState
             * @returns {Promise.promise|*|webdriver.promise.Deferred.promise}
             */
            generateAsyncKeypair: function(keySize, onGeneration){
                if ( keySize == undefined ||
                    typeof keySize != 'number' ||
                    async.interval != null ) {
                    return false;
                }

                cmLogger.debug('jsencrypt generateAsync '+keySize);

                // Create the encryption object.
                var self = this,
                    time = -((new Date()).getTime()),
                    counts = 0;
                // init vars
                async.crypt = new JSEncrypt({default_key_size: keySize}),
                async.promise = $q.defer();
                async.interval = setInterval(function () {
                    counts++;
                    if(typeof onGeneration == "function"){
                        onGeneration(counts, (time + ((new Date()).getTime())))
                    }
                }, 500);
                // start keypair generation
                async.crypt.getKey(function () {
                    self.cancelGeneration(true);

                    async.promise.resolve({
                        timeElapsed: (time + ((new Date()).getTime())),
                        counts: counts,
                        key : new self.Key(async.crypt)
                        //privKey: async.crypt.getPrivateKey(),
                        //pubKey: async.crypt.getPublicKey()
                    })

                    $rootScope.$apply() 
                });

                return async.promise.promise;
            },
            /**
             * cancel key generation process / simple clearInterval
             * if interval is pending
             * @returns {boolean}
             */
            cancelGeneration: function(withReject){
                if ( async.interval != null ) {
                    cmLogger.debug('jsencrypt cancelGeneration');
                    // clear interval
                    var id = async.interval;
                    async.interval = null;
                    clearInterval( id );
                    // clear promise and library vars if param withReject is true
                    if(withReject == undefined && async.promise != undefined){
                        async.promise.reject();
                        async.promise = null;
                        async.crypt = null;
                    }
                    return true;
                }
                return false;
            },

            generatePassphrase: function(){ //@Todo!!
                var bad_random_passphrase = _Base64.encode((Math.random()*(new Date()).getTime()).toString())
                return bad_random_passphrase.slice(bad_random_passphrase.length-10, bad_random_passphrase.length)
            }
        }
    }]
)